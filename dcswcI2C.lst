CCS PCH C Compiler, Version 5.090, 49113               13-Jan-22 13:49

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswcI2C\dcswcI2C.lst

               ROM used:   5824 bytes (18%)
                           Largest free fragment is 26940
               RAM used:   1571 (43%) at main() level
                           1606 (44%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 30

0000:  GOTO   1278
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   03BA
0060:  BTFSS  FA0.1
0062:  GOTO   006C
0066:  BTFSC  FA1.1
0068:  GOTO   02F2
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0428
0078:  BTFSS  FA3.5
007A:  GOTO   0084
007E:  BTFSC  FA4.5
0080:  GOTO   039A
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "dcswcI2C.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
0488:  DATA 23,20
048A:  DATA 64,63
048C:  DATA 73,77
048E:  DATA 63,49
0490:  DATA 32,43
0492:  DATA 20,28
0494:  DATA 25,63
0496:  DATA 25,6C
0498:  DATA 75,29
049A:  DATA 20,73
049C:  DATA 74,61
049E:  DATA 72,74
04A0:  DATA 20,75
04A2:  DATA 70,20
04A4:  DATA 28,64
04A6:  DATA 73,33
04A8:  DATA 30,20
04AA:  DATA 62,6F
04AC:  DATA 6F,74
04AE:  DATA 6C,6F
04B0:  DATA 61,64
04B2:  DATA 65,72
04B4:  DATA 20,73
04B6:  DATA 75,70
04B8:  DATA 70,6F
04BA:  DATA 72,74
04BC:  DATA 29,20
04BE:  DATA 28,77
04C0:  DATA 6F,72
04C2:  DATA 6C,64
04C4:  DATA 44,61
04C6:  DATA 74,61
04C8:  DATA 20,73
04CA:  DATA 74,72
04CC:  DATA 65,61
04CE:  DATA 6D,29
04D0:  DATA 20,28
04D2:  DATA 6D,6F
04D4:  DATA 64,62
04D6:  DATA 75,73
04D8:  DATA 20,61
04DA:  DATA 64,64
04DC:  DATA 72,65
04DE:  DATA 73,73
04E0:  DATA 3D,25
04E2:  DATA 75,29
04E4:  DATA 20,25
04E6:  DATA 73,0D
04E8:  DATA 0A,00
04EA:  DATA 31,33
04EC:  DATA 2D,4A
04EE:  DATA 61,6E
04F0:  DATA 2D,32
04F2:  DATA 32,00
04F4:  DATA 23,20
04F6:  DATA 74,65
04F8:  DATA 73,74
04FA:  DATA 69,6E
04FC:  DATA 67,20
04FE:  DATA 61,64
0500:  DATA 64,72
0502:  DATA 65,73
0504:  DATA 73,20
0506:  DATA 30,78
0508:  DATA 25,30
050A:  DATA 32,78
050C:  DATA 20,2E
050E:  DATA 2E,2E
0510:  DATA 00,00
0512:  DATA 20,67
0514:  DATA 6F,74
0516:  DATA 20,61
0518:  DATA 63,6B
051A:  DATA 21,0D
051C:  DATA 0A,00
051E:  DATA 23,20
0520:  DATA 52,6F
0522:  DATA 63,6B
0524:  DATA 42,4C
0526:  DATA 4F,43
0528:  DATA 4B,20
052A:  DATA 73,61
052C:  DATA 79,73
052E:  DATA 3A,20
0530:  DATA 27,25
0532:  DATA 63,27
0534:  DATA 0D,0A
0536:  DATA 00,00
0538:  DATA 23,20
053A:  DATA 79,6F
053C:  DATA 75,20
053E:  DATA 73,61
0540:  DATA 69,64
0542:  DATA 20,27
0544:  DATA 25,63
0546:  DATA 27,0D
0548:  DATA 0A,00
054A:  DATA 23,20
054C:  DATA 62,79
054E:  DATA 74,65
0550:  DATA 20,61
0552:  DATA 64,64
0554:  DATA 72,5B
0556:  DATA 30,78
0558:  DATA 25,30
055A:  DATA 32,78
055C:  DATA 5D,3D
055E:  DATA 30,78
0560:  DATA 25,30
0562:  DATA 32,78
0564:  DATA 20,28
0566:  DATA 25,75
0568:  DATA 29,0D
056A:  DATA 0A,00
056C:  DATA 23,20
056E:  DATA 72,65
0570:  DATA 67,20
0572:  DATA 61,64
0574:  DATA 64,72
0576:  DATA 5B,30
0578:  DATA 78,25
057A:  DATA 30,32
057C:  DATA 78,5D
057E:  DATA 3D,30
0580:  DATA 78,25
0582:  DATA 30,34
0584:  DATA 6C,78
0586:  DATA 20,28
0588:  DATA 25,6C
058A:  DATA 75,29
058C:  DATA 0D,0A
058E:  DATA 00,00
*
0CD2:  MOVLB  6
0CD4:  MOVF   x2F,W
0CD6:  MULWF  x31
0CD8:  MOVFF  FF3,01
0CDC:  MOVFF  FF4,00
0CE0:  MULWF  x32
0CE2:  MOVF   FF3,W
0CE4:  ADDWF  00,F
0CE6:  MOVF   x30,W
0CE8:  MULWF  x31
0CEA:  MOVF   FF3,W
0CEC:  ADDWFC 00,W
0CEE:  MOVWF  02
0CF0:  MOVLB  0
0CF2:  RETURN 0
0CF4:  BTFSC  FD8.1
0CF6:  BRA    0D00
0CF8:  MOVLW  06
0CFA:  MOVWF  FEA
0CFC:  MOVLW  3E
0CFE:  MOVWF  FE9
0D00:  CLRF   00
0D02:  CLRF   01
0D04:  CLRF   02
0D06:  CLRF   03
0D08:  MOVLB  6
0D0A:  CLRF   x3E
0D0C:  CLRF   x3F
0D0E:  CLRF   x40
0D10:  CLRF   x41
0D12:  MOVF   x3D,W
0D14:  IORWF  x3C,W
0D16:  IORWF  x3B,W
0D18:  IORWF  x3A,W
0D1A:  BZ    0D74
0D1C:  MOVLW  20
0D1E:  MOVWF  x42
0D20:  BCF    FD8.0
0D22:  RLCF   x36,F
0D24:  RLCF   x37,F
0D26:  RLCF   x38,F
0D28:  RLCF   x39,F
0D2A:  RLCF   x3E,F
0D2C:  RLCF   x3F,F
0D2E:  RLCF   x40,F
0D30:  RLCF   x41,F
0D32:  MOVF   x3D,W
0D34:  SUBWF  x41,W
0D36:  BNZ   0D48
0D38:  MOVF   x3C,W
0D3A:  SUBWF  x40,W
0D3C:  BNZ   0D48
0D3E:  MOVF   x3B,W
0D40:  SUBWF  x3F,W
0D42:  BNZ   0D48
0D44:  MOVF   x3A,W
0D46:  SUBWF  x3E,W
0D48:  BNC   0D68
0D4A:  MOVF   x3A,W
0D4C:  SUBWF  x3E,F
0D4E:  MOVF   x3B,W
0D50:  BTFSS  FD8.0
0D52:  INCFSZ x3B,W
0D54:  SUBWF  x3F,F
0D56:  MOVF   x3C,W
0D58:  BTFSS  FD8.0
0D5A:  INCFSZ x3C,W
0D5C:  SUBWF  x40,F
0D5E:  MOVF   x3D,W
0D60:  BTFSS  FD8.0
0D62:  INCFSZ x3D,W
0D64:  SUBWF  x41,F
0D66:  BSF    FD8.0
0D68:  RLCF   00,F
0D6A:  RLCF   01,F
0D6C:  RLCF   02,F
0D6E:  RLCF   03,F
0D70:  DECFSZ x42,F
0D72:  BRA    0D20
0D74:  MOVFF  63E,FEF
0D78:  MOVFF  63F,FEC
0D7C:  MOVFF  640,FEC
0D80:  MOVFF  641,FEC
0D84:  MOVLB  0
0D86:  GOTO   0F16 (RETURN)
*
0F3E:  TBLRD*+
0F40:  MOVFF  FF6,621
0F44:  MOVFF  FF7,622
0F48:  MOVF   FF5,W
0F4A:  BTFSS  FA4.4
0F4C:  BRA    0F4A
0F4E:  MOVWF  F79
0F50:  MOVFF  621,FF6
0F54:  MOVFF  622,FF7
0F58:  MOVLB  6
0F5A:  DECFSZ x20,F
0F5C:  BRA    0F60
0F5E:  BRA    0F64
0F60:  MOVLB  0
0F62:  BRA    0F3E
0F64:  MOVLB  0
0F66:  RETURN 0
0F68:  MOVFF  FEA,627
0F6C:  MOVFF  FE9,626
0F70:  MOVLB  6
0F72:  SWAPF  x20,W
0F74:  IORLW  F0
0F76:  MOVWF  x22
0F78:  ADDWF  x22,F
0F7A:  ADDLW  E2
0F7C:  MOVWF  x23
0F7E:  ADDLW  32
0F80:  MOVWF  x25
0F82:  MOVF   x20,W
0F84:  ANDLW  0F
0F86:  ADDWF  x23,F
0F88:  ADDWF  x23,F
0F8A:  ADDWF  x25,F
0F8C:  ADDLW  E9
0F8E:  MOVWF  x24
0F90:  ADDWF  x24,F
0F92:  ADDWF  x24,F
0F94:  SWAPF  x1F,W
0F96:  ANDLW  0F
0F98:  ADDWF  x24,F
0F9A:  ADDWF  x25,F
0F9C:  RLCF   x24,F
0F9E:  RLCF   x25,F
0FA0:  COMF   x25,F
0FA2:  RLCF   x25,F
0FA4:  MOVF   x1F,W
0FA6:  ANDLW  0F
0FA8:  ADDWF  x25,F
0FAA:  RLCF   x22,F
0FAC:  MOVLW  07
0FAE:  MOVWF  x21
0FB0:  MOVLW  0A
0FB2:  DECF   x24,F
0FB4:  ADDWF  x25,F
0FB6:  BNC   0FB2
0FB8:  DECF   x23,F
0FBA:  ADDWF  x24,F
0FBC:  BNC   0FB8
0FBE:  DECF   x22,F
0FC0:  ADDWF  x23,F
0FC2:  BNC   0FBE
0FC4:  DECF   x21,F
0FC6:  ADDWF  x22,F
0FC8:  BNC   0FC4
0FCA:  MOVLW  06
0FCC:  MOVWF  FEA
0FCE:  MOVLW  21
0FD0:  MOVWF  FE9
0FD2:  MOVLW  07
0FD4:  ANDWF  x26,W
0FD6:  BCF    x26.6
0FD8:  ADDWF  FE9,F
0FDA:  MOVLW  00
0FDC:  ADDWFC FEA,F
0FDE:  MOVF   FE9,W
0FE0:  SUBLW  25
0FE2:  BNZ   0FEC
0FE4:  MOVF   FEA,W
0FE6:  SUBLW  06
0FE8:  BNZ   0FEC
0FEA:  BSF    x26.6
0FEC:  MOVF   FEF,W
0FEE:  MOVWF  00
0FF0:  BNZ   1002
0FF2:  BTFSC  x26.6
0FF4:  BRA    1002
0FF6:  BTFSC  x26.4
0FF8:  BRA    1012
0FFA:  BTFSC  x26.3
0FFC:  BRA    1002
0FFE:  MOVLW  20
1000:  BRA    1008
1002:  BSF    x26.3
1004:  BCF    x26.4
1006:  MOVLW  30
1008:  ADDWF  00,F
100A:  MOVF   00,W
100C:  BTFSS  FA4.4
100E:  BRA    100C
1010:  MOVWF  F79
1012:  MOVF   FEE,W
1014:  BTFSS  x26.6
1016:  BRA    0FDE
1018:  MOVLB  0
101A:  RETURN 0
101C:  MOVLB  6
101E:  MOVF   x22,W
1020:  CLRF   01
1022:  SUBWF  x21,W
1024:  BC    102C
1026:  MOVFF  621,00
102A:  BRA    1044
102C:  CLRF   00
102E:  MOVLW  08
1030:  MOVWF  x23
1032:  RLCF   x21,F
1034:  RLCF   00,F
1036:  MOVF   x22,W
1038:  SUBWF  00,W
103A:  BTFSC  FD8.0
103C:  MOVWF  00
103E:  RLCF   01,F
1040:  DECFSZ x23,F
1042:  BRA    1032
1044:  MOVLB  0
1046:  RETURN 0
1048:  MOVF   01,W
104A:  MOVFF  61F,621
104E:  MOVLW  64
1050:  MOVLB  6
1052:  MOVWF  x22
1054:  MOVLB  0
1056:  RCALL  101C
1058:  MOVFF  00,61F
105C:  MOVF   01,W
105E:  MOVLW  30
1060:  BNZ   1072
1062:  MOVLB  6
1064:  BTFSS  x20.1
1066:  BRA    1084
1068:  BTFSC  x20.3
106A:  BRA    1084
106C:  BTFSC  x20.4
106E:  MOVLW  20
1070:  BRA    107A
1072:  MOVLB  6
1074:  BCF    x20.3
1076:  BCF    x20.4
1078:  BSF    x20.0
107A:  ADDWF  01,F
107C:  MOVF   01,W
107E:  BTFSS  FA4.4
1080:  BRA    107E
1082:  MOVWF  F79
1084:  MOVFF  61F,621
1088:  MOVLW  0A
108A:  MOVWF  x22
108C:  MOVLB  0
108E:  RCALL  101C
1090:  MOVFF  00,61F
1094:  MOVF   01,W
1096:  MOVLW  30
1098:  BNZ   10AA
109A:  MOVLB  6
109C:  BTFSC  x20.3
109E:  BRA    10B6
10A0:  BTFSS  x20.0
10A2:  BRA    10B6
10A4:  BTFSC  x20.4
10A6:  MOVLW  20
10A8:  MOVLB  0
10AA:  ADDWF  01,F
10AC:  MOVF   01,W
10AE:  BTFSS  FA4.4
10B0:  BRA    10AE
10B2:  MOVWF  F79
10B4:  MOVLB  6
10B6:  MOVLW  30
10B8:  ADDWF  x1F,F
10BA:  MOVF   x1F,W
10BC:  BTFSS  FA4.4
10BE:  BRA    10BC
10C0:  MOVWF  F79
10C2:  MOVLB  0
10C4:  RETURN 0
10C6:  TBLRD*+
10C8:  MOVF   FF5,F
10CA:  BZ    10E6
10CC:  MOVFF  FF6,61F
10D0:  MOVFF  FF7,620
10D4:  MOVF   FF5,W
10D6:  BTFSS  FA4.4
10D8:  BRA    10D6
10DA:  MOVWF  F79
10DC:  MOVFF  61F,FF6
10E0:  MOVFF  620,FF7
10E4:  BRA    10C6
10E6:  RETURN 0
*
1114:  MOVLB  6
1116:  BTFSC  x20.7
1118:  BRA    113A
111A:  MOVLW  0F
111C:  MOVWF  00
111E:  SWAPF  x1F,W
1120:  ANDWF  00,F
1122:  MOVLW  0A
1124:  SUBWF  00,W
1126:  BC    112E
1128:  MOVLW  30
112A:  ADDWF  00,F
112C:  BRA    1132
112E:  MOVF   x20,W
1130:  ADDWF  00,F
1132:  MOVF   00,W
1134:  BTFSS  FA4.4
1136:  BRA    1134
1138:  MOVWF  F79
113A:  MOVLW  0F
113C:  ANDWF  x1F,F
113E:  MOVLW  0A
1140:  SUBWF  x1F,W
1142:  BC    1148
1144:  MOVLW  30
1146:  BRA    114C
1148:  BCF    x20.7
114A:  MOVF   x20,W
114C:  ADDWF  x1F,F
114E:  MOVF   x1F,W
1150:  BTFSS  FA4.4
1152:  BRA    1150
1154:  MOVWF  F79
1156:  MOVLB  0
1158:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... 
.................... #if 1
.................... /* no boot loader */
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BORV30
.................... #fuses WDT32768
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... 
.................... #else
.................... 
.................... /* DS30 boot loader version 1.5.1 - engine 2.2.2 */
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */
.................... /* max mem address - 0x243, max mem address - 0x240 */
.................... #build(reset=0x7dbc:0x7dbf)
.................... /* max mem address - 0x23f, max mem address - see memory organization in datasheet */
.................... //#org 0x7dc0,0x7fff {}
.................... #org 0x7dc0,0x7fff {}
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
0662:  MOVLW  06
0664:  MOVWF  FEA
0666:  MOVLW  20
0668:  MOVWF  FE9
066A:  MOVF   FEF,W
066C:  BZ    0690
066E:  MOVLW  02
0670:  MOVWF  01
0672:  MOVLW  BF
0674:  MOVWF  00
0676:  CLRWDT
0678:  DECFSZ 00,F
067A:  BRA    0676
067C:  DECFSZ 01,F
067E:  BRA    0672
0680:  MOVLW  96
0682:  MOVWF  00
0684:  DECFSZ 00,F
0686:  BRA    0684
0688:  BRA    068A
068A:  CLRWDT
068C:  DECFSZ FEF,F
068E:  BRA    066E
0690:  GOTO   07EE (RETURN)
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x000
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... /* UART1 - RS-485 connection modbus */
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=9600,xmit=PIN_C6,rcv=PIN_C7,errors)	
*
03EA:  BTFSS  F9E.5
03EC:  BRA    03EA
03EE:  MOVFF  FAB,20
03F2:  MOVFF  FAE,01
03F6:  BTFSS  20.1
03F8:  BRA    03FE
03FA:  BCF    FAB.4
03FC:  BSF    FAB.4
03FE:  RETURN 0
.................... 
.................... 
.................... #byte TXSTA=GETENV("SFR:txsta1")
.................... #bit  TRMT=TXSTA.1
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... #byte PORTB=GETENV("SFR:portb")
.................... #byte INTCON2=GETENV("SFR:intcon2")
.................... #bit RBPU=INTCON2.7
.................... 
.................... /* UART2 - FTDI cable */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600,errors)	
*
0382:  BTFSS  FA4.5
0384:  BRA    0382
0386:  MOVFF  FA6,20
038A:  MOVFF  F7A,01
038E:  BTFSS  20.1
0390:  BRA    0396
0392:  BCF    FA6.4
0394:  BSF    FA6.4
0396:  GOTO   039C (RETURN)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
059A:  BCF    FC6.7
059C:  BCF    F9E.3
059E:  MOVFF  624,FC9
05A2:  MOVLW  02
05A4:  BTFSC  FC6.7
05A6:  BRA    05B2
05A8:  BTFSS  F9E.3
05AA:  BRA    05A8
05AC:  MOVLW  00
05AE:  BTFSC  FC5.6
05B0:  MOVLW  01
05B2:  MOVWF  01
05B4:  RETURN 0
*
115A:  BCF    FC6.6
115C:  BSF    FC5.3
115E:  BTFSC  FC5.3
1160:  BRA    115E
1162:  BTFSC  00.0
1164:  BCF    FC5.5
1166:  BTFSS  00.0
1168:  BSF    FC5.5
116A:  BSF    FC5.4
116C:  BTFSC  FC5.4
116E:  BRA    116C
1170:  MOVFF  FC9,01
1174:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... /* Modbus defines */
.................... #define MODBUS_MODE_RTU     0
.................... #define MODBUS_MODE_TCP_RTU 1
.................... 
.................... #define SERIAL_PREFIX_DEFAULT 'Z'
.................... #define SERIAL_NUMBER_DEFAULT 2221
.................... 
.................... 
.................... #define DCSW_FPF2700_ACS714     0
.................... #define DCSW_LATCHING_CONTACTOR 1
.................... #define DCSW_SMALL48            2
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 startup;
.................... 
.................... 	int16 off_below_adc;
.................... 	int16 off_below_delay;
.................... 	int16 on_above_adc;
.................... 	int16 on_above_delay;
.................... 	int16 override_timeout;
.................... 	int16 switch_type;
.................... 
.................... 	signed int8 i_mon_offset; /* applied in addition to config.adc_offset */
.................... 	int8 adc_channel; /* which ADC channel (0 to 15) for LVD and HVD */
.................... 	int8 invert;
.................... } struct_output_channel;
.................... 
.................... typedef struct {
.................... 	int8 revision;
.................... 	int8 modbus_address;
.................... 	int8 modbus_mode;
.................... 
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 
.................... 	struct_output_channel ch[5];
.................... 	signed int8 adc_offset[16];
.................... 
.................... 	int8 uart_sc_sbd;
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int16 modbus_our_packets;
.................... 	int16 modbus_other_packets;
.................... 	int16 modbus_last_error;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 	int8 p_on[5];
.................... 	int16 adc[16];
.................... 	
.................... 	int16 on_delay[5];
.................... 	int16 off_delay[5];
.................... 	int16 override_timeout[5];
.................... 
.................... 
.................... 	int8 decide_now;
.................... 	int8 restart_now;
.................... 	int8 adc_sample_ch;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	int8 led_on_green;
.................... 	int8 led_on_red;
.................... } struct_time_keep;
.................... 
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "i2c_access_dcswcI2C.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... //	int16 data;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
1208:  BSF    FC5.0
120A:  BTFSC  FC5.0
120C:  BRA    120A
.................... 	delay_us(15);
120E:  CLRWDT
1210:  MOVLW  09
1212:  MOVWF  00
1214:  DECFSZ 00,F
1216:  BRA    1214
1218:  NOP   
.................... 	i2c_write(i2c_address);
121A:  MOVFF  61F,624
121E:  CALL   059A
.................... 	i2c_write(regaddr);
1222:  MOVFF  620,624
1226:  CALL   059A
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
122A:  BSF    FC5.1
122C:  BTFSC  FC5.1
122E:  BRA    122C
.................... 	delay_us(15);
1230:  CLRWDT
1232:  MOVLW  09
1234:  MOVWF  00
1236:  DECFSZ 00,F
1238:  BRA    1236
123A:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
123C:  MOVLB  6
123E:  MOVF   x1F,W
1240:  IORLW  01
1242:  MOVWF  x23
1244:  MOVWF  x24
1246:  MOVLB  0
1248:  CALL   059A
.................... 	msb=i2c_read(1);
124C:  MOVLW  01
124E:  MOVWF  00
1250:  RCALL  115A
1252:  MOVFF  01,621
.................... 	lsb=i2c_read(0);                                
1256:  CLRF   00
1258:  RCALL  115A
125A:  MOVFF  01,622
.................... 	i2c_stop();
125E:  BSF    FC5.2
1260:  BTFSC  FC5.2
1262:  BRA    1260
.................... 
.................... 	return make16(msb,lsb);
1264:  MOVFF  621,03
1268:  MOVLB  6
126A:  MOVFF  622,01
126E:  MOVFF  03,02
1272:  MOVLB  0
1274:  GOTO   162C (RETURN)
.................... //	return data;
.................... }
.................... 
.................... #include "uart_sc16is740_dcswcI2C.c"
.................... /* register map for SCI16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
1176:  BSF    FC5.0
1178:  BTFSC  FC5.0
117A:  BRA    1178
.................... 	delay_us(15);
117C:  CLRWDT
117E:  MOVLW  09
1180:  MOVWF  00
1182:  DECFSZ 00,F
1184:  BRA    1182
1186:  NOP   
.................... 	i2c_write(UART_ADDR);
1188:  MOVLW  9A
118A:  MOVLB  6
118C:  MOVWF  x24
118E:  MOVLB  0
1190:  CALL   059A
.................... 	i2c_write(regaddr<<3);
1194:  MOVLB  6
1196:  RLCF   x1F,W
1198:  MOVWF  x21
119A:  RLCF   x21,F
119C:  RLCF   x21,F
119E:  MOVLW  F8
11A0:  ANDWF  x21,F
11A2:  MOVFF  621,624
11A6:  MOVLB  0
11A8:  CALL   059A
.................... 	i2c_start();
11AC:  BSF    FC5.1
11AE:  BTFSC  FC5.1
11B0:  BRA    11AE
.................... 	delay_us(15);
11B2:  CLRWDT
11B4:  MOVLW  09
11B6:  MOVWF  00
11B8:  DECFSZ 00,F
11BA:  BRA    11B8
11BC:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
11BE:  MOVLW  9B
11C0:  MOVLB  6
11C2:  MOVWF  x24
11C4:  MOVLB  0
11C6:  CALL   059A
.................... 	data=i2c_read(0);
11CA:  CLRF   00
11CC:  RCALL  115A
11CE:  MOVFF  01,620
.................... 	i2c_stop();
11D2:  BSF    FC5.2
11D4:  BTFSC  FC5.2
11D6:  BRA    11D4
.................... 
.................... 	return data;
11D8:  MOVLB  6
11DA:  MOVFF  620,01
11DE:  MOVLB  0
11E0:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
05B6:  BSF    FC5.0
05B8:  BTFSC  FC5.0
05BA:  BRA    05B8
.................... 	delay_us(15);                                                 
05BC:  CLRWDT
05BE:  MOVLW  09
05C0:  MOVWF  00
05C2:  DECFSZ 00,F
05C4:  BRA    05C2
05C6:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
05C8:  MOVLW  9A
05CA:  MOVLB  6
05CC:  MOVWF  x24
05CE:  MOVLB  0
05D0:  RCALL  059A
.................... 	i2c_write(regaddr<< 3);  // write cycle         
05D2:  MOVLB  6
05D4:  RLCF   x21,W
05D6:  MOVWF  x23
05D8:  RLCF   x23,F
05DA:  RLCF   x23,F
05DC:  MOVLW  F8
05DE:  ANDWF  x23,F
05E0:  MOVFF  623,624
05E4:  MOVLB  0
05E6:  RCALL  059A
.................... 	i2c_write(data);
05E8:  MOVFF  622,624
05EC:  RCALL  059A
.................... 	i2c_stop();
05EE:  BSF    FC5.2
05F0:  BTFSC  FC5.2
05F2:  BRA    05F0
05F4:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
11F6:  MOVLB  6
11F8:  CLRF   x21
11FA:  MOVFF  61F,622
11FE:  MOVLB  0
1200:  CALL   05B6
1204:  GOTO   153A (RETURN)
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
11E2:  MOVLW  05
11E4:  MOVLB  6
11E6:  MOVWF  x1F
11E8:  MOVLB  0
11EA:  RCALL  1176
11EC:  MOVF   01,W
11EE:  ANDLW  01
11F0:  MOVWF  01
11F2:  GOTO   14BC (RETURN)
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
*
14C0:  MOVLB  6
14C2:  CLRF   x1F
14C4:  MOVLB  0
14C6:  RCALL  1176
14C8:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
05F6:  MOVLW  03
05F8:  MOVLB  6
05FA:  MOVWF  x21
05FC:  MOVLW  80
05FE:  MOVWF  x22
0600:  MOVLB  0
0602:  RCALL  05B6
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
0604:  MOVLB  6
0606:  CLRF   x21
0608:  MOVFF  620,622
060C:  MOVLB  0
060E:  RCALL  05B6
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
0610:  MOVLW  01
0612:  MOVLB  6
0614:  MOVWF  x21
0616:  CLRF   x22
0618:  MOVLB  0
061A:  RCALL  05B6
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
061C:  MOVLW  03
061E:  MOVLB  6
0620:  MOVWF  x21
0622:  MOVLW  BF
0624:  MOVWF  x22
0626:  MOVLB  0
0628:  RCALL  05B6
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
062A:  MOVLW  02
062C:  MOVLB  6
062E:  MOVWF  x21
0630:  MOVLW  10
0632:  MOVWF  x22
0634:  MOVLB  0
0636:  RCALL  05B6
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0638:  MOVLW  03
063A:  MOVLB  6
063C:  MOVWF  x21
063E:  MOVWF  x22
0640:  MOVLB  0
0642:  RCALL  05B6
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
0644:  MOVLW  01
0646:  MOVLB  6
0648:  MOVWF  x21
064A:  CLRF   x22
064C:  MOVLB  0
064E:  RCALL  05B6
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0650:  MOVLW  02
0652:  MOVLB  6
0654:  MOVWF  x21
0656:  MOVLW  07
0658:  MOVWF  x22
065A:  MOVLB  0
065C:  RCALL  05B6
065E:  GOTO   07E4 (RETURN)
.................... }
.................... 
.................... 
.................... #include "mcp3208_dcswcI2C.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
*
0590:  BCF    F93.4
0592:  BSF    F8A.4
.................... 	output_high(CS_ADC0);
0594:  BCF    F93.0
0596:  BSF    F8A.0
0598:  RETURN 0
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
*
0BFC:  BCF    F93.3
0BFE:  BCF    F8A.3
.................... 	output_high(MCP3208_DIN);
0C00:  BCF    F93.1
0C02:  BSF    F8A.1
.................... 
.................... 
.................... 	if ( ch<8 ) {
0C04:  MOVLB  6
0C06:  MOVF   x21,W
0C08:  SUBLW  07
0C0A:  BNC   0C12
.................... 		output_low(CS_ADC0);
0C0C:  BCF    F93.0
0C0E:  BCF    F8A.0
.................... 	} else {
0C10:  BRA    0C1A
.................... 		output_low(CS_ADC1);
0C12:  BCF    F93.4
0C14:  BCF    F8A.4
.................... 		ch-=8;
0C16:  MOVLW  08
0C18:  SUBWF  x21,F
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
0C1A:  MOVF   x21,F
0C1C:  BNZ   0C24
.................... 		c=0b00011;
0C1E:  MOVLW  03
0C20:  MOVWF  x25
0C22:  BRA    0C6E
.................... 	else if ( 1 == ch ) 
0C24:  DECFSZ x21,W
0C26:  BRA    0C2E
.................... 		c=0b10011;
0C28:  MOVLW  13
0C2A:  MOVWF  x25
0C2C:  BRA    0C6E
.................... 	else if ( 2 == ch ) 
0C2E:  MOVF   x21,W
0C30:  SUBLW  02
0C32:  BNZ   0C3A
.................... 		c=0b01011;
0C34:  MOVLW  0B
0C36:  MOVWF  x25
0C38:  BRA    0C6E
.................... 	else if ( 3 == ch ) 
0C3A:  MOVF   x21,W
0C3C:  SUBLW  03
0C3E:  BNZ   0C46
.................... 		c=0b11011;
0C40:  MOVLW  1B
0C42:  MOVWF  x25
0C44:  BRA    0C6E
.................... 	else if ( 4 == ch )
0C46:  MOVF   x21,W
0C48:  SUBLW  04
0C4A:  BNZ   0C52
.................... 		c=0b00111;
0C4C:  MOVLW  07
0C4E:  MOVWF  x25
0C50:  BRA    0C6E
.................... 	else if ( 5 == ch ) 
0C52:  MOVF   x21,W
0C54:  SUBLW  05
0C56:  BNZ   0C5E
.................... 		c=0b10111;
0C58:  MOVLW  17
0C5A:  MOVWF  x25
0C5C:  BRA    0C6E
.................... 	else if ( 6 == ch )
0C5E:  MOVF   x21,W
0C60:  SUBLW  06
0C62:  BNZ   0C6A
.................... 		c=0b01111;
0C64:  MOVLW  0F
0C66:  MOVWF  x25
0C68:  BRA    0C6E
.................... 	else
.................... 		c=0b11111;
0C6A:  MOVLW  1F
0C6C:  MOVWF  x25
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0C6E:  CLRF   x24
0C70:  MOVF   x24,W
0C72:  SUBLW  04
0C74:  BNC   0C92
.................... 		output_low(MCP3208_CLK);
0C76:  BCF    F93.3
0C78:  BCF    F8A.3
.................... 		output_bit(MCP3208_DIN,c&1);
0C7A:  BTFSC  x25.0
0C7C:  BRA    0C82
0C7E:  BCF    F8A.1
0C80:  BRA    0C84
0C82:  BSF    F8A.1
0C84:  BCF    F93.1
.................... 		c=c>>1;
0C86:  BCF    FD8.0
0C88:  RRCF   x25,F
.................... 		output_high(MCP3208_CLK);
0C8A:  BCF    F93.3
0C8C:  BSF    F8A.3
0C8E:  INCF   x24,F
0C90:  BRA    0C70
.................... 	}
.................... 
.................... 
.................... 	value=0;
0C92:  CLRF   x23
0C94:  CLRF   x22
.................... 	for ( i=0 ; i<14 ; i++ ) {
0C96:  CLRF   x24
0C98:  MOVF   x24,W
0C9A:  SUBLW  0D
0C9C:  BNC   0CBA
.................... 		output_low(MCP3208_CLK);
0C9E:  BCF    F93.3
0CA0:  BCF    F8A.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
0CA2:  BSF    F93.2
0CA4:  BTFSC  F81.2
0CA6:  BRA    0CAC
0CA8:  BCF    FD8.0
0CAA:  BRA    0CAE
0CAC:  BSF    FD8.0
0CAE:  RLCF   x22,F
0CB0:  RLCF   x23,F
.................... 		output_high(MCP3208_CLK);
0CB2:  BCF    F93.3
0CB4:  BSF    F8A.3
0CB6:  INCF   x24,F
0CB8:  BRA    0C98
.................... 	}
.................... 
.................... 	bit_clear(value,13);
0CBA:  BCF    x23.5
.................... 	bit_clear(value,12);
0CBC:  BCF    x23.4
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
0CBE:  MOVLB  0
0CC0:  RCALL  0590
.................... 
.................... 	return value;
0CC2:  MOVLB  6
0CC4:  MOVFF  622,01
0CC8:  MOVFF  623,02
0CCC:  MOVLB  0
0CCE:  GOTO   137C (RETURN)
.................... }
.................... 
.................... #include "interrupt_dcswcI2C.c"
.................... 
.................... #int_timer3
.................... void isr_10ms(void) {
.................... 	static int16 uptimeTicks=0;
.................... 	static int16 ticks=0;
.................... 	static int8 adc_ch=0;
.................... 
.................... 	/* preset so we trigger again in 10 milliseconds */
.................... 	set_timer3(45536);
*
02F2:  MOVLW  B1
02F4:  MOVWF  FB3
02F6:  MOVLW  E0
02F8:  MOVWF  FB2
.................... 
.................... 	/* scan adc channels */
.................... 	current.adc_sample_ch = adc_ch;
02FA:  MOVFF  E1,DA
.................... 	/* each adc read gives us two channels */
.................... 	adc_ch+=2;
02FE:  MOVLW  02
0300:  ADDWF  xE1,F
.................... 
.................... 	if ( adc_ch >= 16 ) 
0302:  MOVF   xE1,W
0304:  SUBLW  0F
0306:  BC    030A
.................... 		adc_ch=0;
0308:  CLRF   xE1
.................... 
.................... 	/* LVD / HVD flag */
.................... 	current.decide_now=1;
030A:  MOVLW  01
030C:  MOVWF  xD8
.................... 
.................... 
.................... 	/* ticks(?) since last query */
.................... 	if ( current.interval_milliseconds < 65525 ) {
030E:  MOVF   x93,W
0310:  SUBLW  FF
0312:  BNC   0326
0314:  BNZ   031C
0316:  MOVF   x92,W
0318:  SUBLW  F4
031A:  BNC   0326
.................... 		current.interval_milliseconds+=10;
031C:  MOVLW  0A
031E:  ADDWF  x92,F
0320:  MOVLW  00
0322:  ADDWFC x93,F
.................... 	} else {
0324:  BRA    032A
.................... 		current.interval_milliseconds=65535;
0326:  SETF   x93
0328:  SETF   x92
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
032A:  INCF   xDF,F
032C:  BTFSC  FD8.2
032E:  INCF   xE0,F
.................... 	if ( ticks >= 100 ) {
0330:  MOVF   xE0,F
0332:  BNZ   033A
0334:  MOVF   xDF,W
0336:  SUBLW  63
0338:  BC    033E
.................... 		ticks=0;
033A:  CLRF   xE0
033C:  CLRF   xDF
.................... 	}
.................... 	
.................... 
.................... 	/* uptime counter */
.................... 	uptimeTicks++;
033E:  INCF   xDD,F
0340:  BTFSC  FD8.2
0342:  INCF   xDE,F
.................... 	if ( 6000 == uptimeTicks ) {
0344:  MOVF   xDD,W
0346:  SUBLW  70
0348:  BNZ   0364
034A:  MOVF   xDE,W
034C:  SUBLW  17
034E:  BNZ   0364
.................... 		uptimeTicks=0;
0350:  CLRF   xDE
0352:  CLRF   xDD
.................... 		if ( current.uptime_minutes < 65535 ) 
0354:  INCFSZ x90,W
0356:  BRA    035E
0358:  INCFSZ x91,W
035A:  BRA    035E
035C:  BRA    0364
.................... 			current.uptime_minutes++;
035E:  INCF   x90,F
0360:  BTFSC  FD8.2
0362:  INCF   x91,F
.................... 	}
.................... 
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
0364:  MOVF   xDB,F
0366:  BNZ   036E
.................... 		output_low(LED_GREEN);
0368:  BCF    F93.5
036A:  BCF    F8A.5
.................... 	} else {
036C:  BRA    0374
.................... 		output_high(LED_GREEN);
036E:  BCF    F93.5
0370:  BSF    F8A.5
.................... 		timers.led_on_green--;
0372:  DECF   xDB,F
.................... 	}
.................... 
.................... 	if ( 0==timers.led_on_red ) {
0374:  MOVF   xDC,F
0376:  BNZ   037A
.................... //		output_low(LED_RED);
.................... 	} else {
0378:  BRA    037C
.................... //		output_high(LED_RED);
.................... 		timers.led_on_red--;
037A:  DECF   xDC,F
.................... 	}
.................... }
.................... 
037C:  BCF    FA1.1
037E:  GOTO   0084
.................... #int_rda2
.................... /* any character on FTDI serial port (UART2) will case a reset */
.................... void ftdi_isr(void) {
.................... 	current.restart_now=fgetc(STREAM_WORLD);
*
039A:  BRA    0382
039C:  MOVFF  01,D9
.................... //	current.restart_now=1;
.................... }
.................... 
.................... #include "param_dcswcI2C.c"
03A0:  BCF    FA4.5
03A2:  GOTO   0084
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
085E:  MOVF   x2C,W
0860:  XORWF  x2D,W
0862:  MOVWF  01
*
08AC:  MOVF   x2C,W
08AE:  XORWF  x2D,W
08B0:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
07F2:  MOVLB  6
07F4:  CLRF   x28
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
07F6:  MOVFF  627,62A
07FA:  MOVF   x26,W
07FC:  BTFSC  FD8.2
07FE:  DECF   x27,F
0800:  DECF   x26,F
0802:  MOVWF  x29
0804:  MOVF   x29,F
0806:  BNZ   080C
0808:  MOVF   x2A,F
080A:  BZ    0870
.................... 		*data = read_eeprom( address++ );
080C:  MOVFF  625,03
0810:  MOVF   x24,W
0812:  MOVWF  FE9
0814:  MOVFF  03,FEA
0818:  MOVF   x23,W
081A:  MOVWF  03
081C:  MOVF   x22,W
081E:  INCF   x22,F
0820:  BTFSC  FD8.2
0822:  INCF   x23,F
0824:  MOVWF  x2B
0826:  MOVFF  03,62C
082A:  MOVFF  FF2,62D
082E:  BCF    FF2.7
0830:  MOVFF  62C,F75
0834:  MOVFF  62B,F74
0838:  BCF    F7F.6
083A:  BCF    F7F.7
083C:  BSF    F7F.0
083E:  MOVF   F73,W
0840:  BTFSC  x2D.7
0842:  BSF    FF2.7
0844:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0846:  MOVFF  625,03
084A:  MOVF   x24,W
084C:  MOVWF  FE9
084E:  MOVFF  03,FEA
0852:  MOVFF  FEF,629
0856:  MOVFF  628,62C
085A:  MOVFF  629,62D
*
0864:  MOVFF  01,628
.................... 		data++;
0868:  INCF   x24,F
086A:  BTFSC  FD8.2
086C:  INCF   x25,F
086E:  BRA    07F6
.................... 	}
.................... 	return crc;
0870:  MOVFF  628,01
0874:  MOVLB  0
0876:  GOTO   0BA2 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
087A:  MOVLB  6
087C:  CLRF   x2A
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
087E:  MOVFF  629,62C
0882:  MOVF   x28,W
0884:  BTFSC  FD8.2
0886:  DECF   x29,F
0888:  DECF   x28,F
088A:  MOVWF  x2B
088C:  MOVF   x2B,F
088E:  BNZ   0894
0890:  MOVF   x2C,F
0892:  BZ    0910
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0894:  MOVFF  627,03
0898:  MOVF   x26,W
089A:  MOVWF  FE9
089C:  MOVFF  03,FEA
08A0:  MOVFF  FEF,62B
08A4:  MOVFF  62A,62C
08A8:  MOVFF  62B,62D
*
08B2:  MOVFF  01,62A
.................... 		write_eeprom( address++, *data++ );
08B6:  MOVF   x25,W
08B8:  MOVWF  03
08BA:  MOVF   x24,W
08BC:  INCF   x24,F
08BE:  BTFSC  FD8.2
08C0:  INCF   x25,F
08C2:  MOVWF  x2B
08C4:  MOVFF  03,62C
08C8:  MOVF   x27,W
08CA:  MOVWF  03
08CC:  MOVF   x26,W
08CE:  INCF   x26,F
08D0:  BTFSC  FD8.2
08D2:  INCF   x27,F
08D4:  MOVWF  FE9
08D6:  MOVFF  03,FEA
08DA:  MOVFF  FEF,62D
08DE:  MOVF   FF2,W
08E0:  MOVWF  00
08E2:  BCF    FF2.7
08E4:  MOVFF  62C,F75
08E8:  MOVFF  62B,F74
08EC:  MOVFF  62D,F73
08F0:  BCF    F7F.6
08F2:  BCF    F7F.7
08F4:  BSF    F7F.2
08F6:  MOVLB  F
08F8:  MOVLW  55
08FA:  MOVWF  F7E
08FC:  MOVLW  AA
08FE:  MOVWF  F7E
0900:  BSF    F7F.1
0902:  BTFSC  F7F.1
0904:  BRA    0902
0906:  BCF    F7F.2
0908:  MOVF   00,W
090A:  IORWF  FF2,F
090C:  MOVLB  6
090E:  BRA    087E
.................... 	}
.................... 
.................... 	return crc;
0910:  MOVFF  62A,01
0914:  MOVLB  0
0916:  GOTO   0936 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
091A:  MOVLB  6
091C:  MOVLW  21
091E:  MOVWF  x22
0920:  CLRF   x25
0922:  MOVLW  02
0924:  MOVWF  x24
0926:  CLRF   x27
0928:  MOVFF  622,626
092C:  CLRF   x29
092E:  MOVLW  67
0930:  MOVWF  x28
0932:  MOVLB  0
0934:  BRA    087A
0936:  MOVFF  01,621
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
093A:  MOVF   FF2,W
093C:  MOVWF  00
093E:  BCF    FF2.7
0940:  CLRF   F75
0942:  CLRF   F74
0944:  MOVFF  621,F73
0948:  BCF    F7F.6
094A:  BCF    F7F.7
094C:  BSF    F7F.2
094E:  MOVLB  F
0950:  MOVLW  55
0952:  MOVWF  F7E
0954:  MOVLW  AA
0956:  MOVWF  F7E
0958:  BSF    F7F.1
095A:  BTFSC  F7F.1
095C:  BRA    095A
095E:  BCF    F7F.2
0960:  MOVF   00,W
0962:  IORWF  FF2,F
0964:  MOVLB  0
0966:  GOTO   0B84 (RETURN)
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
096A:  MOVLW  96
096C:  MOVWF  xDB
.................... 
.................... 	config.revision='a';
096E:  MOVLW  61
0970:  MOVWF  21
.................... 
.................... 	config.modbus_address=37;
0972:  MOVLW  25
0974:  MOVWF  22
.................... 	config.modbus_mode=MODBUS_MODE_RTU;
0976:  CLRF   23
.................... 
.................... 	config.serial_prefix=SERIAL_PREFIX_DEFAULT;
0978:  MOVLW  5A
097A:  MOVWF  24
.................... 	config.serial_number=SERIAL_NUMBER_DEFAULT;
097C:  MOVLW  08
097E:  MOVWF  26
0980:  MOVLW  AD
0982:  MOVWF  25
.................... 
.................... 	/* initialize the channel configurations */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0984:  MOVLB  6
0986:  CLRF   x20
0988:  MOVF   x20,W
098A:  SUBLW  04
098C:  BTFSS  FD8.0
098E:  BRA    0B64
.................... 		config.ch[i].startup=0;
0990:  MOVF   x20,W
0992:  MULLW  10
0994:  MOVF   FF3,W
0996:  CLRF   03
0998:  ADDLW  27
099A:  MOVWF  FE9
099C:  MOVLW  00
099E:  ADDWFC 03,W
09A0:  MOVWF  FEA
09A2:  CLRF   FEF
.................... 
.................... 		config.ch[i].adc_channel=i*2;
09A4:  MOVF   x20,W
09A6:  MULLW  10
09A8:  MOVF   FF3,W
09AA:  CLRF   03
09AC:  ADDLW  06
09AE:  MOVWF  x21
09B0:  MOVLW  00
09B2:  ADDWFC 03,W
09B4:  MOVWF  x22
09B6:  MOVLW  0E
09B8:  ADDWF  x21,W
09BA:  MOVWF  01
09BC:  MOVLW  00
09BE:  ADDWFC x22,W
09C0:  MOVWF  03
09C2:  MOVF   01,W
09C4:  ADDLW  21
09C6:  MOVWF  FE9
09C8:  MOVLW  00
09CA:  ADDWFC 03,W
09CC:  MOVWF  FEA
09CE:  BCF    FD8.0
09D0:  RLCF   x20,W
09D2:  MOVWF  FEF
.................... 		config.ch[i].off_below_adc=500;
09D4:  MOVF   x20,W
09D6:  MULLW  10
09D8:  MOVF   FF3,W
09DA:  CLRF   03
09DC:  ADDLW  06
09DE:  MOVWF  x21
09E0:  MOVLW  00
09E2:  ADDWFC 03,W
09E4:  MOVWF  x22
09E6:  MOVLW  01
09E8:  ADDWF  x21,W
09EA:  MOVWF  01
09EC:  MOVLW  00
09EE:  ADDWFC x22,W
09F0:  MOVWF  03
09F2:  MOVF   01,W
09F4:  ADDLW  21
09F6:  MOVWF  FE9
09F8:  MOVLW  00
09FA:  ADDWFC 03,W
09FC:  MOVWF  FEA
09FE:  MOVLW  01
0A00:  MOVWF  FEC
0A02:  MOVF   FED,F
0A04:  MOVLW  F4
0A06:  MOVWF  FEF
.................... 		config.ch[i].off_below_delay=500;
0A08:  MOVF   x20,W
0A0A:  MULLW  10
0A0C:  MOVF   FF3,W
0A0E:  CLRF   03
0A10:  ADDLW  06
0A12:  MOVWF  x21
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  x22
0A1A:  MOVLW  03
0A1C:  ADDWF  x21,W
0A1E:  MOVWF  01
0A20:  MOVLW  00
0A22:  ADDWFC x22,W
0A24:  MOVWF  03
0A26:  MOVF   01,W
0A28:  ADDLW  21
0A2A:  MOVWF  FE9
0A2C:  MOVLW  00
0A2E:  ADDWFC 03,W
0A30:  MOVWF  FEA
0A32:  MOVLW  01
0A34:  MOVWF  FEC
0A36:  MOVF   FED,F
0A38:  MOVLW  F4
0A3A:  MOVWF  FEF
.................... 		config.ch[i].on_above_adc=700;
0A3C:  MOVF   x20,W
0A3E:  MULLW  10
0A40:  MOVF   FF3,W
0A42:  CLRF   03
0A44:  ADDLW  06
0A46:  MOVWF  x21
0A48:  MOVLW  00
0A4A:  ADDWFC 03,W
0A4C:  MOVWF  x22
0A4E:  MOVLW  05
0A50:  ADDWF  x21,W
0A52:  MOVWF  01
0A54:  MOVLW  00
0A56:  ADDWFC x22,W
0A58:  MOVWF  03
0A5A:  MOVF   01,W
0A5C:  ADDLW  21
0A5E:  MOVWF  FE9
0A60:  MOVLW  00
0A62:  ADDWFC 03,W
0A64:  MOVWF  FEA
0A66:  MOVLW  02
0A68:  MOVWF  FEC
0A6A:  MOVF   FED,F
0A6C:  MOVLW  BC
0A6E:  MOVWF  FEF
.................... 		config.ch[i].on_above_delay=1000;
0A70:  MOVF   x20,W
0A72:  MULLW  10
0A74:  MOVF   FF3,W
0A76:  CLRF   03
0A78:  ADDLW  06
0A7A:  MOVWF  x21
0A7C:  MOVLW  00
0A7E:  ADDWFC 03,W
0A80:  MOVWF  x22
0A82:  MOVLW  07
0A84:  ADDWF  x21,W
0A86:  MOVWF  01
0A88:  MOVLW  00
0A8A:  ADDWFC x22,W
0A8C:  MOVWF  03
0A8E:  MOVF   01,W
0A90:  ADDLW  21
0A92:  MOVWF  FE9
0A94:  MOVLW  00
0A96:  ADDWFC 03,W
0A98:  MOVWF  FEA
0A9A:  MOVLW  03
0A9C:  MOVWF  FEC
0A9E:  MOVF   FED,F
0AA0:  MOVLW  E8
0AA2:  MOVWF  FEF
.................... 
.................... 		config.ch[i].override_timeout=300;
0AA4:  MOVF   x20,W
0AA6:  MULLW  10
0AA8:  MOVF   FF3,W
0AAA:  CLRF   03
0AAC:  ADDLW  06
0AAE:  MOVWF  x21
0AB0:  MOVLW  00
0AB2:  ADDWFC 03,W
0AB4:  MOVWF  x22
0AB6:  MOVLW  09
0AB8:  ADDWF  x21,W
0ABA:  MOVWF  01
0ABC:  MOVLW  00
0ABE:  ADDWFC x22,W
0AC0:  MOVWF  03
0AC2:  MOVF   01,W
0AC4:  ADDLW  21
0AC6:  MOVWF  FE9
0AC8:  MOVLW  00
0ACA:  ADDWFC 03,W
0ACC:  MOVWF  FEA
0ACE:  MOVLW  01
0AD0:  MOVWF  FEC
0AD2:  MOVF   FED,F
0AD4:  MOVLW  2C
0AD6:  MOVWF  FEF
.................... 
.................... 		config.ch[i].switch_type=DCSW_FPF2700_ACS714;
0AD8:  MOVF   x20,W
0ADA:  MULLW  10
0ADC:  MOVF   FF3,W
0ADE:  CLRF   03
0AE0:  ADDLW  06
0AE2:  MOVWF  x21
0AE4:  MOVLW  00
0AE6:  ADDWFC 03,W
0AE8:  MOVWF  x22
0AEA:  MOVLW  0B
0AEC:  ADDWF  x21,W
0AEE:  MOVWF  01
0AF0:  MOVLW  00
0AF2:  ADDWFC x22,W
0AF4:  MOVWF  03
0AF6:  MOVF   01,W
0AF8:  ADDLW  21
0AFA:  MOVWF  FE9
0AFC:  MOVLW  00
0AFE:  ADDWFC 03,W
0B00:  MOVWF  FEA
0B02:  CLRF   FEC
0B04:  MOVF   FED,F
0B06:  CLRF   FEF
.................... 		config.ch[i].i_mon_offset=0;
0B08:  MOVF   x20,W
0B0A:  MULLW  10
0B0C:  MOVF   FF3,W
0B0E:  CLRF   03
0B10:  ADDLW  06
0B12:  MOVWF  x21
0B14:  MOVLW  00
0B16:  ADDWFC 03,W
0B18:  MOVWF  x22
0B1A:  MOVLW  0D
0B1C:  ADDWF  x21,W
0B1E:  MOVWF  01
0B20:  MOVLW  00
0B22:  ADDWFC x22,W
0B24:  MOVWF  03
0B26:  MOVF   01,W
0B28:  ADDLW  21
0B2A:  MOVWF  FE9
0B2C:  MOVLW  00
0B2E:  ADDWFC 03,W
0B30:  MOVWF  FEA
0B32:  CLRF   FEF
.................... 		config.ch[i].invert=0;
0B34:  MOVF   x20,W
0B36:  MULLW  10
0B38:  MOVF   FF3,W
0B3A:  CLRF   03
0B3C:  ADDLW  06
0B3E:  MOVWF  x21
0B40:  MOVLW  00
0B42:  ADDWFC 03,W
0B44:  MOVWF  x22
0B46:  MOVLW  0F
0B48:  ADDWF  x21,W
0B4A:  MOVWF  01
0B4C:  MOVLW  00
0B4E:  ADDWFC x22,W
0B50:  MOVWF  03
0B52:  MOVF   01,W
0B54:  ADDLW  21
0B56:  MOVWF  FE9
0B58:  MOVLW  00
0B5A:  ADDWFC 03,W
0B5C:  MOVWF  FEA
0B5E:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* spanish fork */
.................... 	/*
.................... 		ch0 (A) - 12 volt bus
.................... 			off at 12.0 (adc=819 input=0) volts 60 second delay
.................... 
.................... 		ch1 (B) - 24 volt bus
.................... 			off at 24.0 (adc=1638 input=1) volts 60 second delay
.................... 
.................... 		ch2 (C) - Wind MPPT to 24 volt controller (unused)
.................... 			off at 24.0 (adc=1638 input=1) volts 60 second delay
.................... 		
.................... 		ch3 (D) - 48 volt LVD bus
.................... 			off at 48.0 (adc=3277 input=2) volts 60 second delay
.................... 
.................... 		ch4 (E) - wind MPPT to 48 volt controller (unused)
.................... 			off at 48.0 (adc=3277 input=3) volts 60 second delay
.................... 	*/
.................... 
.................... 	config.serial_prefix='A';
.................... 	config.serial_number=3387;
.................... 	config.modbus_address=50;
.................... 
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=0;
.................... 	config.ch[0].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[0].off_below_adc=819;
.................... 	config.ch[0].off_below_delay=6000;
.................... 	config.ch[0].on_above_adc=839;
.................... 	config.ch[0].on_above_delay=6000;
.................... 
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=2;
.................... 	config.ch[1].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[1].off_below_adc=1638;
.................... 	config.ch[1].off_below_delay=6000;
.................... 	config.ch[1].on_above_adc=1658;
.................... 	config.ch[1].on_above_delay=6000;
.................... 
.................... 	config.ch[2].startup=0;
.................... 	config.ch[2].adc_channel=2;
.................... 	config.ch[2].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[2].off_below_adc=1638;
.................... 	config.ch[2].off_below_delay=6000;
.................... 	config.ch[2].on_above_adc=1658;
.................... 	config.ch[2].on_above_delay=6000;
.................... 
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=4;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].off_below_adc=3277;
.................... 	config.ch[3].off_below_delay=6000;
.................... 	config.ch[3].on_above_adc=3297;
.................... 	config.ch[3].on_above_delay=6000;
.................... 
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=4;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].off_below_adc=3277;
.................... 	config.ch[4].off_below_delay=6000;
.................... 	config.ch[4].on_above_adc=3297;
.................... 	config.ch[4].on_above_delay=6000;
.................... 
.................... #endif
.................... 
.................... #if 0
.................... 	/* porcupine dome LVD */
.................... 	/*
.................... 	ch4 (top) - classic for kestrel
.................... 		off at 47.0 (adc=3209) volts with 60 second delay
.................... 	ch3 - DAS panel
.................... 		off at 47.5 (adc=3243) volts with 60 second delay
.................... 	ch2 - CAM panel
.................... 		off at 48.5 (adc=3311) volts with 60 second delay
.................... 	ch1 - inverter (satellite)
.................... 		off at 50.0 (adc=3413) volts with 300 second delay
.................... 	ch0 - heater for anemometer
.................... 		off at 54.0 (adc=3685) volts with 10 second delay
.................... 	*/
.................... 
.................... 	config.serial_prefix='A';
.................... 	config.serial_number=3420;
.................... 	config.modbus_address=50;
.................... 
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=0;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].off_below_adc=3209;
.................... 	config.ch[4].off_below_delay=6000;
.................... 	config.ch[4].on_above_adc=3229;
.................... 	config.ch[4].on_above_delay=6000;
.................... 
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=0;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].off_below_adc=3243;
.................... 	config.ch[3].off_below_delay=6000;
.................... 	config.ch[3].on_above_adc=3263;
.................... 	config.ch[3].on_above_delay=6000;
.................... 
.................... 	config.ch[2].startup=0;
.................... 	config.ch[2].adc_channel=0;
.................... 	config.ch[2].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[2].off_below_adc=3311;
.................... 	config.ch[2].off_below_delay=6000;
.................... 	config.ch[2].on_above_adc=3331;
.................... 	config.ch[2].on_above_delay=6000;
.................... 
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=0;
.................... 	config.ch[1].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[1].off_below_adc=3413;
.................... 	config.ch[1].off_below_delay=30000;
.................... 	config.ch[1].on_above_adc=3433;
.................... 	config.ch[1].on_above_delay=30000;
.................... 
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=0;
.................... 	config.ch[0].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[0].off_below_adc=3685;
.................... 	config.ch[0].off_below_delay=1000;
.................... 	config.ch[0].on_above_adc=3705;
.................... 	config.ch[0].on_above_delay=1000;
.................... 
.................... #endif
.................... 
.................... 
.................... #if 0
0B60:  INCF   x20,F
0B62:  BRA    0988
.................... 	/* porcupine dome turbine stop controller */
.................... 	config.modbus_address=51;
.................... 
.................... 	/* 3 phase SSR for ? */
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=16;
.................... 	config.ch[0].switch_type=DCSW_FPF2700_ACS714;
.................... 	config.ch[0].invert=1;
.................... 
.................... 	/* 3 phase SSR for ? */
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=16;
.................... 	config.ch[1].switch_type=DCSW_FPF2700_ACS714;
.................... 	config.ch[1].invert=1;
.................... 
.................... 	/* unused */
.................... 
.................... 	/* 2 x latching contactor (to disconnect / stop) for ? */
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=16;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].invert=0;
.................... 
.................... 	/* 2 x latching contactor (to disconnect / stop) for ? */
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=16;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].invert=0;
.................... #endif
.................... 
.................... 	for ( i=0 ; i<16 ; i++ ) {
0B64:  CLRF   x20
0B66:  MOVF   x20,W
0B68:  SUBLW  0F
0B6A:  BNC   0B80
.................... 		config.adc_offset[i]=0;
0B6C:  CLRF   03
0B6E:  MOVF   x20,W
0B70:  ADDLW  77
0B72:  MOVWF  FE9
0B74:  MOVLW  00
0B76:  ADDWFC 03,W
0B78:  MOVWF  FEA
0B7A:  CLRF   FEF
0B7C:  INCF   x20,F
0B7E:  BRA    0B66
.................... 	}
.................... 
.................... 
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0B80:  MOVLB  0
0B82:  BRA    091A
0B84:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
0B86:  MOVLB  6
0B88:  MOVLW  21
0B8A:  MOVWF  x20
0B8C:  CLRF   x23
0B8E:  MOVLW  02
0B90:  MOVWF  x22
0B92:  CLRF   x25
0B94:  MOVFF  620,624
0B98:  CLRF   x27
0B9A:  MOVLW  67
0B9C:  MOVWF  x26
0B9E:  MOVLB  0
0BA0:  BRA    07F2
0BA2:  MOVFF  01,61F
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) {
0BA6:  MOVFF  FF2,620
0BAA:  BCF    FF2.7
0BAC:  CLRF   F75
0BAE:  CLRF   F74
0BB0:  BCF    F7F.6
0BB2:  BCF    F7F.7
0BB4:  BSF    F7F.0
0BB6:  MOVF   F73,W
0BB8:  MOVLB  6
0BBA:  BTFSC  x20.7
0BBC:  BSF    FF2.7
0BBE:  SUBWF  x1F,W
0BC0:  BNZ   0BCE
0BC2:  MOVF   21,W
0BC4:  SUBLW  60
0BC6:  BC    0BCE
0BC8:  MOVF   21,W
0BCA:  SUBLW  7A
0BCC:  BC    0BD4
.................... 		write_default_param_file();
0BCE:  MOVLB  0
0BD0:  RCALL  096A
0BD2:  MOVLB  6
.................... 	}
0BD4:  MOVLB  0
0BD6:  GOTO   133A (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... #include "modbus_slave_dcswcI2C.c"
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us
.................... 
.................... 
.................... //#use rs232(baud=9600, UART1, parity=N, stream=MODBUS_SERIAL)
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... 
.................... void rcv_off(void) {
.................... 	output_high(RS485_DE);
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE);
.................... 	disable_interrupts(INT_RDA);
.................... }
.................... 
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
0BDA:  BTFSS  F9E.5
0BDC:  BRA    0BE2
.................... 		fgetc(MODBUS_SERIAL);
0BDE:  RCALL  03EA
0BE0:  BRA    0BDA
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0BE2:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0BE4:  BCF    F94.5
0BE6:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0BE8:  BSF    F9D.5
0BEA:  GOTO   0BF0 (RETURN)
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init() {
.................... //	output_low(MODBUS_SERIAL_ENABLE_PIN);
.................... 
.................... 	RCV_ON();
0BEE:  BRA    0BDA
.................... 
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT);
0BF0:  MOVLW  C4
0BF2:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL);
0BF4:  MOVLW  C0
0BF6:  IORWF  FF2,F
0BF8:  GOTO   134C (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable) {
.................... 	disable_interrupts(INT_TIMER0);
*
03A6:  BCF    FF2.5
.................... 	if (enable) {
03A8:  MOVLB  6
03AA:  MOVF   x44,F
03AC:  BZ    03B6
.................... 		set_timer0(0);
03AE:  CLRF   FD7
03B0:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0);
03B2:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0);
03B4:  BSF    FF2.5
.................... 	}
03B6:  MOVLB  0
03B8:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer0
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
03BA:  MOVF   xE3,W
03BC:  SUBLW  02
03BE:  BNZ   03D4
03C0:  MOVF   xE4,F
03C2:  BNZ   03D4
03C4:  MOVF   xE5,F
03C6:  BNZ   03D4
03C8:  BTFSC  xE2.0
03CA:  BRA    03D4
....................    {
....................       modbus_rx.len-=2;
03CC:  MOVLW  02
03CE:  SUBWF  xE7,F
....................       modbus_serial_new=TRUE;
03D0:  BSF    xE2.0
....................    }
03D2:  BRA    03D6
....................    else
....................       modbus_serial_new=FALSE;
03D4:  BCF    xE2.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
03D6:  SETF   xE5
03D8:  SETF   xE4
....................    modbus_serial_state=MODBUS_GETADDY;
03DA:  CLRF   xE3
....................    modbus_enable_timeout(FALSE);
03DC:  MOVLB  6
03DE:  CLRF   x44
03E0:  MOVLB  0
03E2:  RCALL  03A6
03E4:  BCF    FF2.2
03E6:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   unsigned int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
0400:  MOVF   xE5,W
0402:  MOVLB  6
0404:  XORWF  x44,W
0406:  MOVWF  x45
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0408:  CLRF   03
040A:  MOVF   x45,W
040C:  MOVLB  0
040E:  RCALL  00D2
0410:  MOVWF  01
0412:  MOVF   xE4,W
0414:  XORWF  01,W
0416:  MOVWF  xE5
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0418:  CLRF   03
041A:  MOVLB  6
041C:  MOVF   x45,W
041E:  MOVLB  0
0420:  RCALL  01E2
0422:  MOVWF  xE4
0424:  GOTO   0478 (RETURN)
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c) {
.................... 	
.................... 	fputc(c, MODBUS_SERIAL);
.................... 	modbus_calc_crc(c);
.................... 	/* one stop bit delay */
.................... 	delay_us(104);
.................... 
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #int_rda
.................... void incomming_modbus_serial() {
.................... 	int8 c;
.................... 
.................... 	c=fgetc(MODBUS_SERIAL);
0428:  RCALL  03EA
042A:  MOVFF  01,643
.................... 	if (!modbus_serial_new) {
042E:  BTFSC  xE2.0
0430:  BRA    0482
.................... 		if(modbus_serial_state == MODBUS_GETADDY) {
0432:  MOVF   xE3,F
0434:  BNZ   0446
.................... 			modbus_serial_crc.d = 0xFFFF;
0436:  SETF   xE5
0438:  SETF   xE4
.................... 			modbus_rx.address = c;
043A:  MOVFF  643,E6
.................... 			modbus_serial_state++;
043E:  INCF   xE3,F
.................... 			modbus_rx.len = 0;
0440:  CLRF   xE7
.................... 			modbus_rx.error=0;
0442:  CLRF   xE9
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) {
0444:  BRA    0472
0446:  DECFSZ xE3,W
0448:  BRA    0452
.................... 			modbus_rx.func = c;
044A:  MOVFF  643,E8
.................... 			modbus_serial_state++;
044E:  INCF   xE3,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) {
0450:  BRA    0472
0452:  MOVF   xE3,W
0454:  SUBLW  02
0456:  BNZ   0472
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {
0458:  INCFSZ xE7,W
045A:  BRA    0460
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;
045C:  MOVLW  FE
045E:  MOVWF  xE7
.................... 			}
.................... 			modbus_rx.data[modbus_rx.len]=c;
0460:  MOVLW  EA
0462:  ADDWF  xE7,W
0464:  MOVWF  FE9
0466:  CLRF   FEA
0468:  BTFSC  FD8.0
046A:  INCF   FEA,F
046C:  MOVFF  643,FEF
.................... 			modbus_rx.len++;
0470:  INCF   xE7,F
.................... 		}
.................... 
.................... 		modbus_calc_crc(c);
0472:  MOVFF  643,644
0476:  BRA    0400
.................... 		modbus_enable_timeout(TRUE);
0478:  MOVLW  01
047A:  MOVLB  6
047C:  MOVWF  x44
047E:  MOVLB  0
0480:  RCALL  03A6
.................... 	}
0482:  BCF    F9E.5
0484:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func) {
.................... 	modbus_serial_crc.d=0xFFFF;
.................... 	modbus_serial_new=FALSE;
.................... 
.................... 	rcv_off();
....................   
.................... 	// delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
.................... 	/* 3.5 character delay */
.................... 	delay_us(365);
.................... 
.................... 	modbus_serial_putc(to);
.................... 	modbus_serial_putc(func);
.................... }
.................... 
.................... void modbus_serial_send_stop() {
.................... 	int8 crc_low, crc_high;
.................... 
.................... 	crc_high=modbus_serial_crc.b[1];
.................... 	crc_low=modbus_serial_crc.b[0];
.................... 
.................... 	modbus_serial_putc(crc_high);
.................... 	modbus_serial_putc(crc_low);
.................... 
.................... 	/* wait for data to actually be sent */
.................... 	while ( ! TRMT );
....................     
.................... 	// delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
.................... 	delay_us(365);
.................... 	
.................... 	rcv_on();
.................... 
.................... 	modbus_serial_crc.d=0xFFFF;
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
....................       return FALSE;
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
....................       modbus_rx.len = 1;
....................    }
....................    modbus_serial_new=FALSE;
....................    return TRUE;
.................... }
.................... 
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... 
.................... #include "modbus_handler_dcswcI2C.c"
.................... #define MAX_COIL_REGISTER   4
.................... 
.................... #define MAX_STATUS_REGISTER 27
.................... #define MIN_CONFIG_REGISTER 1000
.................... #define MAX_CONFIG_REGISTER 1088
.................... 
.................... 
.................... void reset_modbus_stats(void) {
.................... 	current.modbus_our_packets=0;
.................... 	current.modbus_other_packets=0;
.................... 	current.modbus_last_error=0;
.................... }
.................... 
.................... 
.................... int16 map_modbus(int16 addr) {
.................... 	int16 l;
.................... 	int8 ch;
.................... 
.................... 	/* channel config registers */
.................... 	if ( addr >= 1008 && addr <= 1088 ) {
.................... 		/* subtract offset */
.................... 		addr = (addr-1008);
.................... 		/* mod 16 (block size) for channel */
.................... 		ch = ((int8) addr)>>4;
.................... 		/* low nibble is the address */
.................... 		addr = ((int8) addr) & 0x0f;
.................... 
.................... 		switch ( addr ) {
.................... 			case 0: return config.ch[ch].startup;
.................... 			case 1: return config.ch[ch].off_below_adc;
.................... 			case 2: return config.ch[ch].off_below_delay;
.................... 			case 3: return config.ch[ch].on_above_adc;
.................... 			case 4: return config.ch[ch].on_above_delay;
.................... 			case 5: return config.ch[ch].override_timeout;
.................... 			case 6: return config.ch[ch].switch_type;
.................... 			case 7: return config.ch[ch].i_mon_offset;
.................... 			case 8: return config.ch[ch].adc_channel;
.................... 			case 9: return config.ch[ch].invert;
.................... 		}
.................... 
.................... 		/* if reserved space then return all bits set */
.................... 		return 0xffff;		
.................... 	}
.................... 
.................... 	switch ( addr ) {
.................... 		case  0: return current.p_on[0];
.................... 		case  1: return current.p_on[1];
.................... 		case  2: return current.p_on[2];
.................... 		case  3: return current.p_on[3];
.................... 		case  4: return current.p_on[4];
.................... 
.................... 		case  5: // 0 
.................... 		case  6: // 1
.................... 		case  7: // 2
.................... 		case  8: // 3
.................... 		case  9: // 4
.................... 		case 10: // 5
.................... 		case 11: // 6
.................... 		case 12: // 7
.................... 		case 13: // 8
.................... 		case 14: // 9
.................... 		case 15: // 10
.................... 		case 16: // 11
.................... 		case 17: // 12
.................... 		case 18: // 13
.................... 		case 19: // 14
.................... 		case 20: // 15
.................... 				return current.adc[(int8) addr - 5];
.................... 
.................... 
.................... 		/* meta status */
.................... 		case 21: return current.sequence_number++;
.................... 		case 22: /* milliseconds since last query */
.................... 			l=current.interval_milliseconds;
.................... 			current.interval_milliseconds=0;
.................... 			return l; 
.................... 		case 23: return current.uptime_minutes; /* uptime  */
.................... 		/* modbus statistics */
.................... 		case 24: return current.modbus_our_packets;
.................... 		case 25: return current.modbus_other_packets;
.................... 		case 26: return current.modbus_last_error;
.................... 		/* 27 triggers a modbus statistics reset */
.................... 		case 27: reset_modbus_stats(); return 0;
.................... 
.................... 		/* configuration */
.................... 		case 1000: return config.serial_prefix;
.................... 		case 1001: return config.serial_number;
.................... 		case 1002: return 'D';
.................... 		case 1003: return 'C';
.................... 		case 1004: return 'S';
.................... 		case 1005: return 2;
.................... 		case 1006: return config.modbus_address;
.................... 		case 1007: return config.modbus_mode;
.................... 
.................... 		/* channel config blocks are handled above */
.................... 		/* case 1008 ... case 1088 */
.................... 
.................... 
.................... 
.................... 		/* we should have range checked, and never gotten here */
.................... 		default: return 65535;
.................... 	}
.................... 
.................... }
.................... 
.................... int8 modbus_valid_read_registers(int16 start, int16 end) {
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 )
.................... 		return 1;
.................... 	
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */
.................... 	if ( end <= MAX_STATUS_REGISTER+1)
.................... 		return 1;
.................... 
.................... 	return 0;
.................... }
.................... 
.................... void modbus_read_register_response(int8 function, int8 address, int16 start_address, int16 register_count ) {
.................... 	int16 i;
.................... 	int16 l;
.................... 
.................... //	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 	modbus_serial_send_start(address, function);
.................... 	modbus_serial_putc(register_count*2);
.................... 
.................... 
.................... 	for( i=0 ; i<register_count ; i++ ) {
.................... 		l=map_modbus(start_address+i);
.................... 		modbus_serial_putc(make8(l,1));
....................   		modbus_serial_putc(make8(l,0));
.................... 	}
.................... 
.................... 	modbus_serial_send_stop();
.................... }
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception modbus_write_register(int16 address, int16 value) {
.................... 	int8 ch;
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( current.factory_unlocked ) {
.................... 		if ( 1000 == address ) {
.................... 			config.serial_prefix=value;
.................... 			return 0;
.................... 		} else if ( 1001 == address ) {
.................... 			config.serial_number=value;
.................... 			return 0;
.................... 		}
.................... 	}
.................... 	if ( address >= 1008 && address <= 1088 ) {
.................... 		/* subtract offset */
.................... 		address = (address-1008);
.................... 		/* mod 16 (block size) for channel */
.................... 		ch = ((int8) address)>>4;
.................... 		/* low nibble is the address */
.................... 		address = ((int8) address) & 0x0f;
.................... 
.................... 		switch ( address ) {
.................... 			/* 1008, 1024, 1040, 1056, 1072 */
.................... 			case 0: 
.................... 				if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].startup=(int8) value;
.................... 				break;
.................... 
.................... 			/* 1009, 1025, 1041, 1057, 1073 */
.................... 			case 1: 
.................... 				if ( value > 4096 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].off_below_adc=value;
.................... 				break;
.................... 
.................... 			/* 1010, 1026, 1042, 1058, 1074 */
.................... 			case 2: 
.................... 				config.ch[ch].off_below_delay=value;
.................... 				break;
.................... 
.................... 			/* 1011, 1027, 1043, 1059, 1075 */
.................... 			case 3: 
.................... 				if ( value > 4096 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].on_above_adc=value;
.................... 				break;
.................... 
.................... 			/* 1012, 1028, 1044, 1060, 1076 */
.................... 			case 4: 
.................... 				config.ch[ch].on_above_delay=value;
.................... 				break;
.................... 
.................... 			/* 1013, 1029, 1045, 1061, 1077 */
.................... 			case 5: 
.................... 				config.ch[ch].override_timeout=value;
.................... 				break;
.................... 
.................... 			/* 1014, 1030, 1046, 1062, 1078 */
.................... 			case 6: 
.................... 				config.ch[ch].switch_type=value;
.................... 				break;
.................... 
.................... 			/* 1015, 1031, 1047, 1063, 1079 */
.................... 			case 7: 
.................... 				if ( value > 255 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].i_mon_offset=(signed int8) value;
.................... 				break;
.................... 
.................... 			/* 1016, 1032, 1048, 1064, 1080 */
.................... 			case 8: 
.................... 				if ( value > 16 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].adc_channel=(int8) value;
.................... 				break;
.................... 
.................... 			/* 1017, 1033, 1049, 1065, 1081 */
.................... 			case 9: 
.................... 				if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].invert=(int8) value;
.................... 				break;
.................... 		}
.................... 
.................... 		/* no exception */
.................... 		return 0;		
.................... 	}
.................... 
.................... 
.................... 	/* publicly writeable addresses */
.................... 	switch ( address ) {
.................... 		case 0:
.................... 		case 1:
.................... 		case 2:
.................... 		case 3:
.................... 		case 4:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			current.p_on[(int8) address]=value;
.................... 			/* set counter that will be decremented in decision loop */
.................... 			current.override_timeout[(int8) address]=config.ch[(int8) address].override_timeout;
.................... 			break;
.................... 
.................... 		case 1006:
.................... 			/* Modbus address {0 to 127} */
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE;
.................... 			config.modbus_address=value;
.................... 			break;
.................... 		case 1007:
.................... 			/* Modbus mode {0,1} */
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.modbus_mode=value;
.................... 			break;
.................... 
.................... 
.................... #if 0
.................... 		/* inital state of the outputs */
.................... 		case 1008:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[0]=value;
.................... 			break;
.................... 		case 1009:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[1]=value;
.................... 			break;
.................... 		case 1010:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[2]=value;
.................... 			break;
.................... 		case 1011:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[3]=value;
.................... 			break;
.................... 		case 1012:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[4]=value;
.................... 			break;
.................... #endif
.................... 
.................... 
.................... 		/* control */
.................... 		case 1997:
.................... 			/* reset now, won't acknowledge */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			reset_cpu();
.................... 			break;
.................... 		case 1998:
.................... 			/* write default config to EEPROM */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			write_default_param_file();
.................... 			break;
.................... 		case 1999:
.................... 			/* write config to EEPROM */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			write_param_file();
.................... 			break;
.................... 		case 19999:
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */
.................... 			if ( 1802 != value ) {
.................... 				current.factory_unlocked=0;
.................... 				return ILLEGAL_DATA_VALUE;
.................... 			}
.................... 			current.factory_unlocked=1;
.................... 			/* green LED for 2 seconds */
.................... 			timers.led_on_green=200;
.................... 			timers.led_on_red=0;
.................... 			break;
.................... 		default:
.................... 			return ILLEGAL_DATA_ADDRESS;
.................... 
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
.................... }
.................... 
.................... void modbus_process(void) {
.................... 	int16 start_addr;
.................... 	int16 num_registers;
.................... 	exception result;
.................... 	int8 i;
.................... 
.................... 
.................... 	/* check for message */
.................... 	if ( modbus_kbhit() ) {
.................... 		/* check if it is addressed to us */
.................... 		if ( modbus_rx.address==config.modbus_address ) {
.................... 			/* Modbus statistics */
.................... 			if ( current.modbus_our_packets < 65535 )
.................... 				current.modbus_our_packets++;
.................... 	
.................... 			/* green LED for 200 milliseconds */
.................... 			timers.led_on_green=20;
.................... 			timers.led_on_red=0;
.................... 
.................... 			switch(modbus_rx.func) {
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]);
.................... 	
.................... 					/* make sure our address is within range */
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					} else {
.................... 						modbus_read_register_response(modbus_rx.func,config.modbus_address,start_addr,num_registers);
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_SINGLE_COIL: /* 5 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 
.................... 					if ( start_addr <= MAX_COIL_REGISTER && modbus_rx.data[2]==0xFF && modbus_rx.data[3]==0x00 ) {
.................... 						/* turn on */
.................... 						modbus_write_register(start_addr, 1);
.................... 					} else if ( start_addr <= MAX_COIL_REGISTER && modbus_rx.data[2]==0x00 && modbus_rx.data[3]==0x00 ) {
.................... 						/* turn off */
.................... 						modbus_write_register(start_addr, 0);
.................... 					} else if ( start_addr > MAX_COIL_REGISTER ) {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					} else {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_VALUE);
.................... 						current.modbus_last_error=ILLEGAL_DATA_VALUE;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 
.................... 					/* try the write */
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3]));
.................... 
.................... 					if ( result ) {
.................... 						/* exception */
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result);
.................... 						current.modbus_last_error=result;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					}  else {
.................... 						/* no exception, send ack */
.................... 						modbus_write_single_register_rsp(config.modbus_address,
.................... 							start_addr,
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3])
.................... 						);
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]);
.................... 
.................... 					/* attempt to write each register. Stop if exception */
.................... 					for ( i=0 ; i<num_registers ; i++ ) {
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2]));
.................... 
.................... 						if ( result ) {
.................... 							/* exception */
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result);
.................... 							current.modbus_last_error=result;
.................... 	
.................... 							/* red LED for 1 second */
.................... 							timers.led_on_red=100;
.................... 							timers.led_on_green=0;
.................... 			
.................... 							break;
.................... 						}
.................... 					}
.................... 		
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */
.................... 					if ( 0 == result ) {
.................... 						/* no exception, send ack */
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers);
.................... 					}
.................... 
.................... 					break;  
.................... 				default:
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION);
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION;
.................... 
.................... 					/* red led for 1 second */
.................... 					timers.led_on_red=100;
.................... 					timers.led_on_green=0;
.................... 			}
.................... 		} else {
.................... 			/* MODBUS packet for somebody else */
.................... 			if ( current.modbus_other_packets < 65535 )
.................... 				current.modbus_other_packets++;
.................... 
.................... 			/* yellow LED 200 milliseconds */
.................... 			timers.led_on_green=20;
.................... 			timers.led_on_red=20;
.................... 		}
.................... 	}
.................... }
.................... 
.................... 
.................... #include "filter_dcswcI2C.c"
.................... #define MEAN_FILTER_WIDTH    16
.................... #define MEAN_FILTER_CHANNELS 16
.................... 
.................... int16 mean_filter_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	static int8 num_elements[MEAN_FILTER_CHANNELS];
.................... 	int32 mean;
.................... 	int32 sum;
.................... 	int8 i;
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index[ch]] = latest_element;
*
0D8A:  MOVLB  6
0D8C:  CLRF   x30
0D8E:  MOVFF  623,62F
0D92:  CLRF   x32
0D94:  MOVLW  20
0D96:  MOVWF  x31
0D98:  MOVLB  0
0D9A:  RCALL  0CD2
0D9C:  MOVFF  02,630
0DA0:  MOVFF  01,62F
0DA4:  CLRF   03
0DA6:  MOVLB  6
0DA8:  MOVF   x23,W
0DAA:  ADDLW  E9
0DAC:  MOVWF  FE9
0DAE:  MOVLW  03
0DB0:  ADDWFC 03,W
0DB2:  MOVWF  FEA
0DB4:  CLRF   03
0DB6:  MOVFF  FEF,02
0DBA:  BCF    FD8.0
0DBC:  RLCF   02,F
0DBE:  RLCF   03,F
0DC0:  MOVF   02,W
0DC2:  ADDWF  01,W
0DC4:  MOVWF  01
0DC6:  MOVF   x30,W
0DC8:  ADDWFC 03,F
0DCA:  MOVF   01,W
0DCC:  ADDLW  E9
0DCE:  MOVWF  FE9
0DD0:  MOVLW  01
0DD2:  ADDWFC 03,W
0DD4:  MOVWF  FEA
0DD6:  MOVFF  625,FEC
0DDA:  MOVF   FED,F
0DDC:  MOVFF  624,FEF
.................... 	inbuf_index[ch]++;
0DE0:  CLRF   03
0DE2:  MOVF   x23,W
0DE4:  ADDLW  E9
0DE6:  MOVWF  FE9
0DE8:  MOVLW  03
0DEA:  ADDWFC 03,W
0DEC:  MOVWF  FEA
0DEE:  INCF   FEF,F
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
0DF0:  CLRF   03
0DF2:  MOVF   x23,W
0DF4:  ADDLW  E9
0DF6:  MOVWF  FE9
0DF8:  MOVLW  03
0DFA:  ADDWFC 03,W
0DFC:  MOVWF  FEA
0DFE:  MOVF   FEF,W
0E00:  SUBLW  0F
0E02:  BC    0E14
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
0E04:  CLRF   03
0E06:  MOVF   x23,W
0E08:  ADDLW  E9
0E0A:  MOVWF  FE9
0E0C:  MOVLW  03
0E0E:  ADDWFC 03,W
0E10:  MOVWF  FEA
0E12:  CLRF   FEF
.................... 
.................... 	if(num_elements[ch] < MEAN_FILTER_WIDTH)
0E14:  CLRF   03
0E16:  MOVF   x23,W
0E18:  ADDLW  F9
0E1A:  MOVWF  FE9
0E1C:  MOVLW  03
0E1E:  ADDWFC 03,W
0E20:  MOVWF  FEA
0E22:  MOVF   FEF,W
0E24:  SUBLW  0F
0E26:  BNC   0E38
.................... 	   num_elements[ch]++;
0E28:  CLRF   03
0E2A:  MOVF   x23,W
0E2C:  ADDLW  F9
0E2E:  MOVWF  FE9
0E30:  MOVLW  03
0E32:  ADDWFC 03,W
0E34:  MOVWF  FEA
0E36:  INCF   FEF,F
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
0E38:  CLRF   x2D
0E3A:  CLRF   x2C
0E3C:  CLRF   x2B
0E3E:  CLRF   x2A
.................... 	for(i = 0; i < num_elements[ch]; i++)
0E40:  CLRF   x2E
0E42:  CLRF   03
0E44:  MOVF   x23,W
0E46:  ADDLW  F9
0E48:  MOVWF  FE9
0E4A:  MOVLW  03
0E4C:  ADDWFC 03,W
0E4E:  MOVWF  FEA
0E50:  MOVF   FEF,W
0E52:  SUBWF  x2E,W
0E54:  BC    0EAA
.................... 		sum += input_buffer[ch][i];
0E56:  CLRF   x30
0E58:  MOVFF  623,62F
0E5C:  CLRF   x32
0E5E:  MOVLW  20
0E60:  MOVWF  x31
0E62:  MOVLB  0
0E64:  RCALL  0CD2
0E66:  MOVFF  02,630
0E6A:  MOVFF  01,62F
0E6E:  CLRF   03
0E70:  MOVLB  6
0E72:  MOVFF  62E,02
0E76:  BCF    FD8.0
0E78:  RLCF   02,F
0E7A:  RLCF   03,F
0E7C:  MOVF   02,W
0E7E:  ADDWF  01,W
0E80:  MOVWF  01
0E82:  MOVF   x30,W
0E84:  ADDWFC 03,F
0E86:  MOVF   01,W
0E88:  ADDLW  E9
0E8A:  MOVWF  FE9
0E8C:  MOVLW  01
0E8E:  ADDWFC 03,W
0E90:  MOVWF  FEA
0E92:  MOVFF  FEC,03
0E96:  MOVF   FED,F
0E98:  MOVF   FEF,W
0E9A:  ADDWF  x2A,F
0E9C:  MOVF   03,W
0E9E:  ADDWFC x2B,F
0EA0:  MOVLW  00
0EA2:  ADDWFC x2C,F
0EA4:  ADDWFC x2D,F
0EA6:  INCF   x2E,F
0EA8:  BRA    0E42
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... 	mean = (sum + (int32)(num_elements[ch] >> 1)) / num_elements[ch];
0EAA:  CLRF   03
0EAC:  MOVF   x23,W
0EAE:  ADDLW  F9
0EB0:  MOVWF  FE9
0EB2:  MOVLW  03
0EB4:  ADDWFC 03,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,62F
0EBC:  BCF    FD8.0
0EBE:  RRCF   x2F,W
0EC0:  MOVWF  00
0EC2:  CLRF   01
0EC4:  CLRF   02
0EC6:  CLRF   03
0EC8:  MOVF   00,W
0ECA:  ADDWF  x2A,W
0ECC:  MOVWF  x2F
0ECE:  MOVF   01,W
0ED0:  ADDWFC x2B,W
0ED2:  MOVWF  x30
0ED4:  MOVF   02,W
0ED6:  ADDWFC x2C,W
0ED8:  MOVWF  x31
0EDA:  MOVF   03,W
0EDC:  ADDWFC x2D,W
0EDE:  MOVWF  x32
0EE0:  CLRF   03
0EE2:  MOVF   x23,W
0EE4:  ADDLW  F9
0EE6:  MOVWF  FE9
0EE8:  MOVLW  03
0EEA:  ADDWFC 03,W
0EEC:  MOVWF  FEA
0EEE:  MOVFF  FEF,63A
0EF2:  MOVFF  FEA,635
0EF6:  MOVFF  FE9,634
0EFA:  BCF    FD8.1
0EFC:  MOVFF  632,639
0F00:  MOVFF  631,638
0F04:  MOVFF  630,637
0F08:  MOVFF  62F,636
0F0C:  CLRF   x3D
0F0E:  CLRF   x3C
0F10:  CLRF   x3B
0F12:  MOVLB  0
0F14:  BRA    0CF4
0F16:  MOVFF  635,FEA
0F1A:  MOVFF  634,FE9
0F1E:  MOVFF  03,629
0F22:  MOVFF  02,628
0F26:  MOVFF  01,627
0F2A:  MOVFF  00,626
.................... 
.................... 	return((int16)mean);
0F2E:  MOVLB  6
0F30:  MOVFF  626,01
0F34:  MOVFF  627,02
0F38:  MOVLB  0
0F3A:  GOTO   13B4 (RETURN)
.................... }
.................... 
.................... /* 
.................... special case of mean filter. For a 16 element filter, max value of 4096, and equal
.................... number of samples for each channel. Filter result doesn't become valid until at least
.................... 16 samples have been added
.................... */
.................... int16 mean_filter16_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	int16 sum;
.................... 	int16 min, max;
.................... 	int8 i;
.................... 
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index] = latest_element;
.................... 	inbuf_index[ch]++;
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	min=65535;
.................... 	max=0;
.................... 	sum = 0;
.................... 	for( i = 0; i < MEAN_FILTER_WIDTH ; i++ ) {
.................... 		sum += input_buffer[ch][i];
.................... 
.................... 		if ( input_buffer[ch][i] > max )
.................... 			max=input_buffer[ch][i];
.................... 		if ( input_buffer[ch][i] < min )
.................... 			min=input_buffer[ch][i];
.................... 	}
.................... 
.................... 	/* throw out the highest and lowest values */
.................... 	sum -= max;
.................... 	sum -= min;
.................... 
.................... 	return ( (sum+7) / 14 );
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... //	return ( (sum+8) >> 4 );
.................... }
.................... 
.................... 
.................... 
.................... void init() {
.................... 	int8 i;
.................... 
.................... 	setup_oscillator(OSC_8MHZ || OSC_INTRC); 
*
0694:  MOVLW  60
0696:  MOVWF  FD3
0698:  CLRF   F9B
069A:  CLRF   F64
.................... //	setup_adc(ADC_CLOCK_INTERNAL);
.................... 	setup_adc_ports(NO_ANALOGS);
069C:  MOVLB  F
069E:  MOVF   x5C,W
06A0:  ANDLW  80
06A2:  MOVWF  x5C
06A4:  MOVLW  00
06A6:  MOVWF  x5D
06A8:  BCF    FC1.3
06AA:  BCF    FC1.4
06AC:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
06AE:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
06B0:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
06B2:  MOVLW  1F
06B4:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
06B6:  MOVLW  F0
06B8:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
06BA:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
06BC:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
06BE:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
06C0:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
06C2:  BCF    F94.5
06C4:  BCF    F8B.5
.................... 
.................... 	/* data structure initialization */
.................... 	timers.led_on_green=0;
06C6:  MOVLB  0
06C8:  CLRF   xDB
.................... 	timers.led_on_red=0;
06CA:  CLRF   xDC
.................... 
.................... 	current.modbus_our_packets=0;
06CC:  CLRF   x89
06CE:  CLRF   x88
.................... 	current.modbus_other_packets=0;
06D0:  CLRF   x8B
06D2:  CLRF   x8A
.................... 	current.modbus_last_error=0;
06D4:  CLRF   x8D
06D6:  CLRF   x8C
.................... 	current.sequence_number=0;
06D8:  CLRF   x8F
06DA:  CLRF   x8E
.................... 	current.uptime_minutes=0;
06DC:  CLRF   x91
06DE:  CLRF   x90
.................... 	current.interval_milliseconds=0;
06E0:  CLRF   x93
06E2:  CLRF   x92
.................... 	current.factory_unlocked=0;
06E4:  CLRF   x94
.................... 	current.restart_now=0;
06E6:  CLRF   xD9
.................... 
.................... 	for ( i=0 ; i<5 ; i++ ) {
06E8:  MOVLB  6
06EA:  CLRF   x1F
06EC:  MOVF   x1F,W
06EE:  SUBLW  04
06F0:  BNC   07C4
.................... 		current.on_delay[i]=config.ch[i].on_above_delay;
06F2:  BCF    FD8.0
06F4:  RLCF   x1F,W
06F6:  CLRF   03
06F8:  ADDLW  BA
06FA:  MOVWF  01
06FC:  MOVLW  00
06FE:  ADDWFC 03,F
0700:  MOVFF  01,620
0704:  MOVFF  03,621
0708:  MOVF   x1F,W
070A:  MULLW  10
070C:  MOVF   FF3,W
070E:  CLRF   03
0710:  ADDLW  06
0712:  MOVWF  x22
0714:  MOVLW  00
0716:  ADDWFC 03,W
0718:  MOVWF  x23
071A:  MOVLW  07
071C:  ADDWF  x22,W
071E:  MOVWF  01
0720:  MOVLW  00
0722:  ADDWFC x23,W
0724:  MOVWF  03
0726:  MOVF   01,W
0728:  ADDLW  21
072A:  MOVWF  FE9
072C:  MOVLW  00
072E:  ADDWFC 03,W
0730:  MOVWF  FEA
0732:  MOVFF  FEC,03
0736:  MOVF   FED,F
0738:  MOVFF  FEF,622
073C:  MOVFF  621,FEA
0740:  MOVFF  620,FE9
0744:  MOVFF  03,FEC
0748:  MOVF   FED,F
074A:  MOVFF  622,FEF
.................... 		current.off_delay[i]=config.ch[i].off_below_delay;
074E:  BCF    FD8.0
0750:  RLCF   x1F,W
0752:  CLRF   03
0754:  ADDLW  C4
0756:  MOVWF  01
0758:  MOVLW  00
075A:  ADDWFC 03,F
075C:  MOVFF  01,620
0760:  MOVFF  03,621
0764:  MOVF   x1F,W
0766:  MULLW  10
0768:  MOVF   FF3,W
076A:  CLRF   03
076C:  ADDLW  06
076E:  MOVWF  x22
0770:  MOVLW  00
0772:  ADDWFC 03,W
0774:  MOVWF  x23
0776:  MOVLW  03
0778:  ADDWF  x22,W
077A:  MOVWF  01
077C:  MOVLW  00
077E:  ADDWFC x23,W
0780:  MOVWF  03
0782:  MOVF   01,W
0784:  ADDLW  21
0786:  MOVWF  FE9
0788:  MOVLW  00
078A:  ADDWFC 03,W
078C:  MOVWF  FEA
078E:  MOVFF  FEC,03
0792:  MOVF   FED,F
0794:  MOVFF  FEF,622
0798:  MOVFF  621,FEA
079C:  MOVFF  620,FE9
07A0:  MOVFF  03,FEC
07A4:  MOVF   FED,F
07A6:  MOVFF  622,FEF
.................... 		current.override_timeout[i]=0;
07AA:  BCF    FD8.0
07AC:  RLCF   x1F,W
07AE:  CLRF   03
07B0:  ADDLW  CE
07B2:  MOVWF  FE9
07B4:  MOVLW  00
07B6:  ADDWFC 03,W
07B8:  MOVWF  FEA
07BA:  CLRF   FEC
07BC:  MOVF   FED,F
07BE:  CLRF   FEF
07C0:  INCF   x1F,F
07C2:  BRA    06EC
.................... 	}
.................... 
.................... 
.................... 
.................... 	/* interrupts */
.................... 	/* timer0 - Modbus slave timeout timer */
.................... 	/* configured in modbus_slave_sdc.c */
.................... 
.................... 	/* timer1 - unused */
.................... 
.................... 	/* timer2 - unused */
.................... 
.................... 	/* timer3 - general housekeeping Prescaler=1:1; TMR1 Preset=45536; Freq=100.00Hz; Period=10.00 ms */
.................... 	setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);
07C4:  CLRF   FB0
07C6:  MOVLW  07
07C8:  MOVWF  FB1
.................... 	set_timer3(45536);
07CA:  MOVLW  B1
07CC:  MOVWF  FB3
07CE:  MOVLW  E0
07D0:  MOVWF  FB2
.................... 	enable_interrupts(INT_TIMER3);
07D2:  BSF    FA0.1
.................... 
.................... 	/* timer4 - unused */
.................... 
.................... 	/* FTDI serial cable receive character */
.................... 	enable_interrupts(INT_RDA2);
07D4:  BSF    FA3.5
.................... 
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
07D6:  MOVLB  0
07D8:  RCALL  0590
.................... 
.................... 
.................... 	/* initialize SCI UART @ 19200 */
.................... 	uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
07DA:  MOVLW  06
07DC:  MOVLB  6
07DE:  MOVWF  x20
07E0:  MOVLB  0
07E2:  BRA    05F6
.................... 
.................... 
.................... 	delay_ms(14);
07E4:  MOVLW  0E
07E6:  MOVLB  6
07E8:  MOVWF  x20
07EA:  MOVLB  0
07EC:  BRA    0662
07EE:  GOTO   1338 (RETURN)
.................... 
.................... }
.................... 
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start();
*
10E8:  BSF    FC5.0
10EA:  BTFSC  FC5.0
10EC:  BRA    10EA
.................... 	status = i2c_write(address);  // Status = 0 if got an ACK
10EE:  MOVFF  61F,624
10F2:  CALL   059A
10F6:  MOVFF  01,620
.................... 	i2c_stop();
10FA:  BSF    FC5.2
10FC:  BTFSC  FC5.2
10FE:  BRA    10FC
.................... 
.................... 	if ( 0 == status )
1100:  MOVLB  6
1102:  MOVF   x20,F
1104:  BNZ   110C
.................... 		return TRUE;
1106:  MOVLW  01
1108:  MOVWF  01
110A:  BRA    1110
.................... 
....................    return FALSE;
110C:  MOVLW  00
110E:  MOVWF  01
1110:  MOVLB  0
1112:  RETURN 0
.................... }
.................... 
.................... void main(void) {
*
1278:  CLRF   FF8
127A:  BCF    FD0.7
127C:  BSF    07.7
127E:  MOVLW  62
1280:  MOVWF  FD3
1282:  CLRF   F9B
1284:  CLRF   F64
1286:  CLRF   20
1288:  BCF    FA7.3
128A:  MOVLW  0C
128C:  MOVWF  FAF
128E:  MOVLW  A2
1290:  MOVWF  FAC
1292:  MOVLW  90
1294:  MOVWF  FAB
1296:  BSF    FB9.3
1298:  MOVLW  22
129A:  MOVWF  F7B
129C:  MOVLW  00
129E:  MOVWF  F7C
12A0:  MOVLW  A6
12A2:  MOVWF  FBA
12A4:  MOVLW  90
12A6:  MOVWF  FA6
12A8:  BSF    F94.3
12AA:  BSF    F94.4
12AC:  MOVLW  04
12AE:  MOVWF  FC8
12B0:  MOVLW  28
12B2:  MOVWF  FC6
12B4:  BCF    FC7.7
12B6:  BCF    FC7.6
12B8:  BCF    xE2.0
12BA:  CLRF   xE3
12BC:  MOVLB  6
12BE:  CLRF   x1A
12C0:  CLRF   x19
12C2:  MOVLB  F
12C4:  MOVF   x5C,W
12C6:  ANDLW  80
12C8:  MOVWF  x5C
12CA:  MOVLW  00
12CC:  MOVWF  x5D
12CE:  BCF    FC1.3
12D0:  BCF    FC1.4
12D2:  BCF    FC1.5
12D4:  CLRF   x5E
12D6:  CLRF   x5F
12D8:  BRA    12F4
12DA:  DATA 02,00
12DC:  DATA 1A,00
12DE:  DATA 00,C1
12E0:  DATA 40,21
12E2:  DATA 00,FF
12E4:  DATA 41,E9
12E6:  DATA 00,FF
12E8:  DATA C0,00
12EA:  DATA FF,C0
12EC:  DATA 00,FF
12EE:  DATA C0,00
12F0:  DATA 34,C0
12F2:  DATA 00,00
12F4:  MOVLW  00
12F6:  MOVWF  FF8
12F8:  MOVLW  12
12FA:  MOVWF  FF7
12FC:  MOVLW  DA
12FE:  MOVWF  FF6
1300:  TBLRD*+
1302:  MOVF   FF5,W
1304:  MOVWF  00
1306:  XORLW  00
1308:  BZ    1330
130A:  TBLRD*+
130C:  MOVF   FF5,W
130E:  MOVWF  01
1310:  BTFSC  FE8.7
1312:  BRA    131E
1314:  ANDLW  3F
1316:  MOVWF  FEA
1318:  TBLRD*+
131A:  MOVFF  FF5,FE9
131E:  BTFSC  01.6
1320:  TBLRD*+
1322:  BTFSS  01.6
1324:  TBLRD*+
1326:  MOVFF  FF5,FEE
132A:  DCFSNZ 00,F
132C:  BRA    1300
132E:  BRA    1322
1330:  CLRF   FF8
.................... 	int8 i,j;
.................... 	int16 l;
.................... 
.................... 	init();
1332:  MOVLB  0
1334:  GOTO   0694
.................... 	read_param_file();
1338:  BRA    0B86
.................... 
.................... 	if ( config.modbus_address > 127 ) {
133A:  MOVF   22,W
133C:  SUBLW  7F
133E:  BC    1344
.................... 		write_default_param_file();
1340:  CALL   096A
.................... 	}
.................... 
.................... 	/* start out Modbus slave */
.................... 	setup_uart(TRUE);
1344:  BSF    FAB.7
1346:  BSF    FAB.4
1348:  BSF    FAC.5
.................... 	/* modbus_init turns on global interrupts */
.................... 	modbus_init();
134A:  BRA    0BEE
.................... 	/* modbus initializes @ 9600 */
.................... 
.................... 	/* prime filters */
.................... 	for ( i=0 ; i<20 ; i++ ) {
134C:  MOVLB  6
134E:  CLRF   x1B
1350:  MOVF   x1B,W
1352:  SUBLW  13
1354:  BNC   13D0
.................... 		for ( j=0 ; j<16 ; j++ ) {
1356:  CLRF   x1C
1358:  MOVF   x1C,W
135A:  SUBLW  0F
135C:  BNC   13CC
.................... 			current.adc[j]=mean_filter_n(j,mcp3208_read(j) + config.adc_offset[j]);
135E:  BCF    FD8.0
1360:  RLCF   x1C,W
1362:  CLRF   03
1364:  ADDLW  9A
1366:  MOVWF  01
1368:  MOVLW  00
136A:  ADDWFC 03,F
136C:  MOVFF  01,61F
1370:  MOVFF  03,620
1374:  MOVFF  61C,621
1378:  MOVLB  0
137A:  BRA    0BFC
137C:  MOVFF  02,622
1380:  MOVFF  01,621
1384:  CLRF   03
1386:  MOVLB  6
1388:  MOVF   x1C,W
138A:  ADDLW  77
138C:  MOVWF  FE9
138E:  MOVLW  00
1390:  ADDWFC 03,W
1392:  MOVWF  FEA
1394:  MOVF   FEF,W
1396:  CLRF   03
1398:  MOVWF  00
139A:  BTFSC  FE8.7
139C:  DECF   03,F
139E:  ADDWF  x21,F
13A0:  MOVF   03,W
13A2:  ADDWFC x22,F
13A4:  MOVFF  61C,623
13A8:  MOVFF  622,625
13AC:  MOVFF  621,624
13B0:  MOVLB  0
13B2:  BRA    0D8A
13B4:  MOVFF  620,FEA
13B8:  MOVFF  61F,FE9
13BC:  MOVFF  02,FEC
13C0:  MOVF   FED,F
13C2:  MOVFF  01,FEF
13C6:  MOVLB  6
13C8:  INCF   x1C,F
13CA:  BRA    1358
.................... 		}
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... #if 1
13CC:  INCF   x1B,F
13CE:  BRA    1350
.................... 	fprintf(STREAM_WORLD,"# dcswcI2C (%c%lu) start up (ds30 bootloader support) (worldData stream) (modbus address=%u) %s\r\n",
.................... 		config.serial_prefix,
.................... 		config.serial_number,
.................... 		config.modbus_address,
.................... 		__DATE__
.................... 	);
13D0:  MOVLW  88
13D2:  MOVWF  FF6
13D4:  MOVLW  04
13D6:  MOVWF  FF7
13D8:  MOVLW  0C
13DA:  MOVWF  x20
13DC:  MOVLB  0
13DE:  RCALL  0F3E
13E0:  MOVF   24,W
13E2:  BTFSS  FA4.4
13E4:  BRA    13E2
13E6:  MOVWF  F79
13E8:  MOVLW  10
13EA:  MOVWF  FE9
13EC:  MOVFF  26,620
13F0:  MOVFF  25,61F
13F4:  RCALL  0F68
13F6:  MOVLW  99
13F8:  MOVWF  FF6
13FA:  MOVLW  04
13FC:  MOVWF  FF7
13FE:  MOVLW  48
1400:  MOVLB  6
1402:  MOVWF  x20
1404:  MOVLB  0
1406:  RCALL  0F3E
1408:  MOVFF  22,61F
140C:  MOVLW  1B
140E:  MOVLB  6
1410:  MOVWF  x20
1412:  MOVLB  0
1414:  RCALL  1048
1416:  MOVLW  29
1418:  BTFSS  FA4.4
141A:  BRA    1418
141C:  MOVWF  F79
141E:  MOVLW  20
1420:  BTFSS  FA4.4
1422:  BRA    1420
1424:  MOVWF  F79
1426:  MOVLW  EA
1428:  MOVWF  FF6
142A:  MOVLW  04
142C:  MOVWF  FF7
142E:  RCALL  10C6
1430:  MOVLW  0D
1432:  BTFSS  FA4.4
1434:  BRA    1432
1436:  MOVWF  F79
1438:  MOVLW  0A
143A:  BTFSS  FA4.4
143C:  BRA    143A
143E:  MOVWF  F79
.................... #endif	
.................... 
.................... 
.................... #if 1
.................... 	/* scan I2C bus */
.................... 	for (i=0x10 ; i<0xF0 ; i+=2) {
1440:  MOVLW  10
1442:  MOVLB  6
1444:  MOVWF  x1B
1446:  MOVF   x1B,W
1448:  SUBLW  EF
144A:  BNC   149C
.................... 		if ( get_ack_status(i) ) {
144C:  MOVFF  61B,61F
1450:  MOVLB  0
1452:  RCALL  10E8
1454:  MOVF   01,F
1456:  BZ    1494
.................... 			fprintf(STREAM_WORLD,"# testing address 0x%02x ...",i);
1458:  MOVLW  F4
145A:  MOVWF  FF6
145C:  MOVLW  04
145E:  MOVWF  FF7
1460:  MOVLW  14
1462:  MOVLB  6
1464:  MOVWF  x20
1466:  MOVLB  0
1468:  RCALL  0F3E
146A:  MOVFF  61B,61F
146E:  MOVLW  57
1470:  MOVLB  6
1472:  MOVWF  x20
1474:  MOVLB  0
1476:  RCALL  1114
1478:  MOVLW  0C
147A:  MOVWF  FF6
147C:  MOVLW  05
147E:  MOVWF  FF7
1480:  MOVLW  04
1482:  MOVLB  6
1484:  MOVWF  x20
1486:  MOVLB  0
1488:  RCALL  0F3E
.................... 			fprintf(STREAM_WORLD," got ack!\r\n");
148A:  MOVLW  12
148C:  MOVWF  FF6
148E:  MOVLW  05
1490:  MOVWF  FF7
1492:  RCALL  10C6
....................     	} else {
.................... //			fprintf(STREAM_FTDI," nothing\r\n");
.................... 		}
1494:  MOVLW  02
1496:  MOVLB  6
1498:  ADDWF  x1B,F
149A:  BRA    1446
....................    	}
.................... #endif
.................... 
.................... 
.................... 	config.uart_sc_sbd=get_ack_status(0x9a);
149C:  MOVLW  9A
149E:  MOVWF  x1F
14A0:  MOVLB  0
14A2:  RCALL  10E8
14A4:  MOVFF  01,87
.................... 
.................... 	timers.led_on_red=timers.led_on_green=0;
14A8:  CLRF   xDB
14AA:  MOVFF  DB,DC
.................... 
.................... #if 0
.................... 	/* set ports to their startup state */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		current.p_on[i]=config.ch[i].startup;
.................... 	}
.................... #endif
.................... 
.................... 
.................... 	i=0;
14AE:  MOVLB  6
14B0:  CLRF   x1B
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
14B2:  CLRWDT
.................... 
.................... #if 0
.................... 		/* set the output bits to reflect their requested state */
.................... 		output_bit(CTRL_0,config.ch[0].invert ^ current.p_on[0]);
.................... 		output_bit(CTRL_1,config.ch[1].invert ^ current.p_on[1]);
.................... 		output_bit(CTRL_2,config.ch[2].invert ^ current.p_on[2]);
.................... 		output_bit(CTRL_3,config.ch[3].invert ^ current.p_on[3]);
.................... 		output_bit(CTRL_4,config.ch[4].invert ^ current.p_on[4]);
.................... 
.................... 		modbus_process();
.................... #endif
.................... 
.................... #if 0
.................... 		if ( current.adc_sample_ch != 0xff ) {
.................... 			/* read ADC (voltage) and add our offset */
.................... //			current.adc[current.adc_sample_ch]=mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch];
.................... 			current.adc[current.adc_sample_ch]=mean_filter_n(current.adc_sample_ch,mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch]);
.................... 	
.................... 			/* read the next channel (current) as soon as possible */
.................... 			current.adc_sample_ch++;
.................... //			current.adc[current.adc_sample_ch]=mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch];
.................... 			current.adc[current.adc_sample_ch]=mean_filter_n(current.adc_sample_ch,mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch]);
.................... 
.................... 			/* wait until timer interrupt gives another sample flag */
.................... 			current.adc_sample_ch=0xff;
.................... 		}
.................... #endif
.................... 
.................... #if 0
.................... 		if ( current.decide_now ) {
.................... 			current.decide_now=0;
.................... 
.................... 			for ( i=0 ; i<5 ; i++ ) {
.................... 				if ( current.override_timeout[i] > 0 ) {
.................... 					current.override_timeout[i]--;
.................... 					continue;
.................... 				}
.................... 
.................... 				if ( config.ch[i].adc_channel < 15 && current.adc[config.ch[i].adc_channel] > config.ch[i].on_above_adc ) {
.................... 					if ( current.on_delay[i] > 0 ) {
.................... 						current.on_delay[i]--;
.................... 					} else {
.................... 						current.p_on[i]=1;
.................... 					}
.................... 				} else {
.................... 					current.on_delay[i]=config.ch[i].on_above_delay;
.................... 				}
.................... 			
.................... 
.................... 				if ( config.ch[i].adc_channel < 15 && current.adc[config.ch[i].adc_channel] < config.ch[i].off_below_adc ) {
.................... 					if ( current.off_delay[i] > 0 ) {
.................... 						current.off_delay[i]--;
.................... 					} else {
.................... 						current.p_on[i]=0;
.................... 					}
.................... 				} else {
.................... 					current.off_delay[i]=config.ch[i].off_below_delay;
.................... 				}
.................... 			}
.................... 		}
.................... #endif
.................... 
.................... 
.................... 
.................... 			if ( config.uart_sc_sbd && uart_kbhit() ) {
14B4:  MOVLB  0
14B6:  MOVF   x87,F
14B8:  BZ    14FA
14BA:  BRA    11E2
14BC:  MOVF   01,F
14BE:  BZ    14FA
.................... 				fprintf(STREAM_WORLD,"# RockBLOCK says: '%c'\r\n",uart_getc());	
*
14CA:  MOVFF  01,61F
14CE:  MOVLW  1E
14D0:  MOVWF  FF6
14D2:  MOVLW  05
14D4:  MOVWF  FF7
14D6:  MOVLW  13
14D8:  MOVLB  6
14DA:  MOVWF  x20
14DC:  MOVLB  0
14DE:  RCALL  0F3E
14E0:  MOVLB  6
14E2:  MOVF   x1F,W
14E4:  BTFSS  FA4.4
14E6:  BRA    14E4
14E8:  MOVWF  F79
14EA:  MOVLW  33
14EC:  MOVWF  FF6
14EE:  MOVLW  05
14F0:  MOVWF  FF7
14F2:  MOVLW  03
14F4:  MOVWF  x20
14F6:  MOVLB  0
14F8:  RCALL  0F3E
.................... 			}
.................... 			
.................... 
.................... 
.................... #if 1
.................... 		if ( current.restart_now ) {
14FA:  MOVF   xD9,F
14FC:  BTFSC  FD8.2
14FE:  BRA    16BE
.................... 			timers.led_on_green=200;
1500:  MOVLW  C8
1502:  MOVWF  xDB
.................... 			fprintf(STREAM_WORLD,"# you said '%c'\r\n",current.restart_now);
1504:  MOVLW  38
1506:  MOVWF  FF6
1508:  MOVLW  05
150A:  MOVWF  FF7
150C:  MOVLW  0C
150E:  MOVLB  6
1510:  MOVWF  x20
1512:  MOVLB  0
1514:  RCALL  0F3E
1516:  MOVF   xD9,W
1518:  BTFSS  FA4.4
151A:  BRA    1518
151C:  MOVWF  F79
151E:  MOVLW  46
1520:  MOVWF  FF6
1522:  MOVLW  05
1524:  MOVWF  FF7
1526:  MOVLW  03
1528:  MOVLB  6
152A:  MOVWF  x20
152C:  MOVLB  0
152E:  RCALL  0F3E
.................... 			if ( config.uart_sc_sbd ) {
1530:  MOVF   x87,F
1532:  BZ    153A
.................... 				uart_putc(current.restart_now);
1534:  MOVFF  D9,61F
1538:  BRA    11F6
.................... 			}
.................... 
.................... 			current.restart_now=0;
153A:  CLRF   xD9
.................... 
.................... 
.................... #if 1
.................... 			/* read a block of bytes from device */
.................... 			i2c_start();
153C:  BSF    FC5.0
153E:  BTFSC  FC5.0
1540:  BRA    153E
.................... 			delay_us(15);
1542:  CLRWDT
1544:  MOVLW  09
1546:  MOVWF  00
1548:  DECFSZ 00,F
154A:  BRA    1548
154C:  NOP   
.................... 			i2c_write(0x36);
154E:  MOVLW  36
1550:  MOVLB  6
1552:  MOVWF  x24
1554:  MOVLB  0
1556:  CALL   059A
.................... 			i2c_write(0); /* register address 0 */
155A:  MOVLB  6
155C:  CLRF   x24
155E:  MOVLB  0
1560:  CALL   059A
.................... 			i2c_start();
1564:  BSF    FC5.1
1566:  BTFSC  FC5.1
1568:  BRA    1566
.................... 			delay_us(15);
156A:  CLRWDT
156C:  MOVLW  09
156E:  MOVWF  00
1570:  DECFSZ 00,F
1572:  BRA    1570
1574:  NOP   
.................... 			i2c_write(0x36 | 1); /* read */
1576:  MOVLW  37
1578:  MOVLB  6
157A:  MOVWF  x24
157C:  MOVLB  0
157E:  CALL   059A
.................... 			
.................... 			for ( i=0 ; i<16 ; i++ ) {
1582:  MOVLB  6
1584:  CLRF   x1B
1586:  MOVF   x1B,W
1588:  SUBLW  0F
158A:  BNC   160E
.................... 				j=i2c_read(1);
158C:  MOVLW  01
158E:  MOVWF  00
1590:  MOVLB  0
1592:  RCALL  115A
1594:  MOVFF  01,61C
.................... 
.................... 				fprintf(STREAM_WORLD,"# byte addr[0x%02x]=0x%02x (%u)\r\n",
.................... 					i,
.................... 					j,
.................... 					j
.................... 				);
1598:  MOVLW  4A
159A:  MOVWF  FF6
159C:  MOVLW  05
159E:  MOVWF  FF7
15A0:  MOVLW  0E
15A2:  MOVLB  6
15A4:  MOVWF  x20
15A6:  MOVLB  0
15A8:  RCALL  0F3E
15AA:  MOVFF  61B,61F
15AE:  MOVLW  57
15B0:  MOVLB  6
15B2:  MOVWF  x20
15B4:  MOVLB  0
15B6:  RCALL  1114
15B8:  MOVLW  5C
15BA:  MOVWF  FF6
15BC:  MOVLW  05
15BE:  MOVWF  FF7
15C0:  MOVLW  04
15C2:  MOVLB  6
15C4:  MOVWF  x20
15C6:  MOVLB  0
15C8:  RCALL  0F3E
15CA:  MOVFF  61C,61F
15CE:  MOVLW  57
15D0:  MOVLB  6
15D2:  MOVWF  x20
15D4:  MOVLB  0
15D6:  RCALL  1114
15D8:  MOVLW  20
15DA:  BTFSS  FA4.4
15DC:  BRA    15DA
15DE:  MOVWF  F79
15E0:  MOVLW  28
15E2:  BTFSS  FA4.4
15E4:  BRA    15E2
15E6:  MOVWF  F79
15E8:  MOVFF  61C,61F
15EC:  MOVLW  1B
15EE:  MOVLB  6
15F0:  MOVWF  x20
15F2:  MOVLB  0
15F4:  RCALL  1048
15F6:  MOVLW  68
15F8:  MOVWF  FF6
15FA:  MOVLW  05
15FC:  MOVWF  FF7
15FE:  MOVLW  03
1600:  MOVLB  6
1602:  MOVWF  x20
1604:  MOVLB  0
1606:  RCALL  0F3E
1608:  MOVLB  6
160A:  INCF   x1B,F
160C:  BRA    1586
.................... 			}
.................... 			i2c_read(0);
160E:  CLRF   00
1610:  MOVLB  0
1612:  RCALL  115A
.................... #endif
.................... 
.................... #if 1
.................... 			/* 16 bit registers, but byte addressed */
.................... 			for ( i=4 ; i<8 ; i ++ ) {
1614:  MOVLW  04
1616:  MOVLB  6
1618:  MOVWF  x1B
161A:  MOVF   x1B,W
161C:  SUBLW  07
161E:  BNC   16B8
.................... 				l=i2c_register_read16(0x36,i);
1620:  MOVLW  36
1622:  MOVWF  x1F
1624:  MOVFF  61B,620
1628:  MOVLB  0
162A:  BRA    1208
162C:  MOVFF  02,61E
1630:  MOVFF  01,61D
.................... 				fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%04lx (%lu)\r\n",i,l,l);
1634:  MOVLW  6C
1636:  MOVWF  FF6
1638:  MOVLW  05
163A:  MOVWF  FF7
163C:  MOVLW  0D
163E:  MOVLB  6
1640:  MOVWF  x20
1642:  MOVLB  0
1644:  RCALL  0F3E
1646:  MOVFF  61B,61F
164A:  MOVLW  57
164C:  MOVLB  6
164E:  MOVWF  x20
1650:  MOVLB  0
1652:  RCALL  1114
1654:  MOVLW  7D
1656:  MOVWF  FF6
1658:  MOVLW  05
165A:  MOVWF  FF7
165C:  MOVLW  04
165E:  MOVLB  6
1660:  MOVWF  x20
1662:  MOVLB  0
1664:  RCALL  0F3E
1666:  MOVFF  61E,61F
166A:  MOVLW  57
166C:  MOVLB  6
166E:  MOVWF  x20
1670:  MOVLB  0
1672:  RCALL  1114
1674:  MOVFF  61D,61F
1678:  MOVLW  57
167A:  MOVLB  6
167C:  MOVWF  x20
167E:  MOVLB  0
1680:  RCALL  1114
1682:  MOVLW  20
1684:  BTFSS  FA4.4
1686:  BRA    1684
1688:  MOVWF  F79
168A:  MOVLW  28
168C:  BTFSS  FA4.4
168E:  BRA    168C
1690:  MOVWF  F79
1692:  MOVLW  10
1694:  MOVWF  FE9
1696:  MOVFF  61E,620
169A:  MOVFF  61D,61F
169E:  RCALL  0F68
16A0:  MOVLW  8B
16A2:  MOVWF  FF6
16A4:  MOVLW  05
16A6:  MOVWF  FF7
16A8:  MOVLW  03
16AA:  MOVLB  6
16AC:  MOVWF  x20
16AE:  MOVLB  0
16B0:  RCALL  0F3E
16B2:  MOVLB  6
16B4:  INCF   x1B,F
16B6:  BRA    161A
.................... 			}
.................... #endif
.................... 
.................... 			output_toggle(CTRL_0);
16B8:  BCF    F92.0
16BA:  BTG    F89.0
16BC:  MOVLB  0
.................... 
.................... 		}
.................... #endif
16BE:  MOVLB  6
16C0:  BRA    14B2
.................... 
.................... 		
.................... 	}
.................... }
16C2:  BRA    16C2

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 3469   NOPUT NOBROWNOUT BORV27 ZPBORM NOWDT WDT8192
   Word  3: 0900   CANB MSSPMSK7
   Word  4: 0010   NOSTVREN BBSIZ2K DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E000   NOWRTC NOWRTB NOWRTD
   Word  7: 4000   NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
