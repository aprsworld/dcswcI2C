CCS PCH C Compiler, Version 5.090, 49113               13-Jan-22 15:41

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswcI2C\dcswcI2C.lst

               ROM used:   5584 bytes (17%)
                           Largest free fragment is 27180
               RAM used:   1573 (43%) at main() level
                           1608 (44%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 30

0000:  GOTO   1258
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   03BA
0060:  BTFSS  FA0.1
0062:  GOTO   006C
0066:  BTFSC  FA1.1
0068:  GOTO   02F2
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0428
0078:  BTFSS  FA3.5
007A:  GOTO   0084
007E:  BTFSC  FA4.5
0080:  GOTO   039A
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "dcswcI2C.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
0488:  DATA 23,20
048A:  DATA 64,63
048C:  DATA 73,77
048E:  DATA 63,49
0490:  DATA 32,43
0492:  DATA 20,28
0494:  DATA 25,63
0496:  DATA 25,6C
0498:  DATA 75,29
049A:  DATA 20,73
049C:  DATA 74,61
049E:  DATA 72,74
04A0:  DATA 20,75
04A2:  DATA 70,20
04A4:  DATA 28,64
04A6:  DATA 73,33
04A8:  DATA 30,20
04AA:  DATA 62,6F
04AC:  DATA 6F,74
04AE:  DATA 6C,6F
04B0:  DATA 61,64
04B2:  DATA 65,72
04B4:  DATA 20,73
04B6:  DATA 75,70
04B8:  DATA 70,6F
04BA:  DATA 72,74
04BC:  DATA 29,20
04BE:  DATA 28,77
04C0:  DATA 6F,72
04C2:  DATA 6C,64
04C4:  DATA 44,61
04C6:  DATA 74,61
04C8:  DATA 20,73
04CA:  DATA 74,72
04CC:  DATA 65,61
04CE:  DATA 6D,29
04D0:  DATA 20,28
04D2:  DATA 6D,6F
04D4:  DATA 64,62
04D6:  DATA 75,73
04D8:  DATA 20,61
04DA:  DATA 64,64
04DC:  DATA 72,65
04DE:  DATA 73,73
04E0:  DATA 3D,25
04E2:  DATA 75,29
04E4:  DATA 20,25
04E6:  DATA 73,0D
04E8:  DATA 0A,00
04EA:  DATA 31,33
04EC:  DATA 2D,4A
04EE:  DATA 61,6E
04F0:  DATA 2D,32
04F2:  DATA 32,00
04F4:  DATA 23,20
04F6:  DATA 74,65
04F8:  DATA 73,74
04FA:  DATA 69,6E
04FC:  DATA 67,20
04FE:  DATA 61,64
0500:  DATA 64,72
0502:  DATA 65,73
0504:  DATA 73,20
0506:  DATA 30,78
0508:  DATA 25,30
050A:  DATA 32,78
050C:  DATA 20,2E
050E:  DATA 2E,2E
0510:  DATA 00,00
0512:  DATA 20,67
0514:  DATA 6F,74
0516:  DATA 20,61
0518:  DATA 63,6B
051A:  DATA 21,0D
051C:  DATA 0A,00
051E:  DATA 23,20
0520:  DATA 52,6F
0522:  DATA 63,6B
0524:  DATA 42,4C
0526:  DATA 4F,43
0528:  DATA 4B,20
052A:  DATA 73,61
052C:  DATA 79,73
052E:  DATA 3A,20
0530:  DATA 27,25
0532:  DATA 63,27
0534:  DATA 0D,0A
0536:  DATA 00,00
0538:  DATA 23,20
053A:  DATA 79,6F
053C:  DATA 75,20
053E:  DATA 73,61
0540:  DATA 69,64
0542:  DATA 20,27
0544:  DATA 25,63
0546:  DATA 27,0D
0548:  DATA 0A,00
054A:  DATA 23,20
054C:  DATA 72,65
054E:  DATA 67,20
0550:  DATA 61,64
0552:  DATA 64,72
0554:  DATA 5B,30
0556:  DATA 78,25
0558:  DATA 30,32
055A:  DATA 78,5D
055C:  DATA 3D,30
055E:  DATA 78,25
0560:  DATA 30,34
0562:  DATA 6C,78
0564:  DATA 20,28
0566:  DATA 25,6C
0568:  DATA 75,29
056A:  DATA 0D,0A
056C:  DATA 00,00
*
0CB0:  MOVLB  6
0CB2:  MOVF   x31,W
0CB4:  MULWF  x33
0CB6:  MOVFF  FF3,01
0CBA:  MOVFF  FF4,00
0CBE:  MULWF  x34
0CC0:  MOVF   FF3,W
0CC2:  ADDWF  00,F
0CC4:  MOVF   x32,W
0CC6:  MULWF  x33
0CC8:  MOVF   FF3,W
0CCA:  ADDWFC 00,W
0CCC:  MOVWF  02
0CCE:  MOVLB  0
0CD0:  RETURN 0
0CD2:  BTFSC  FD8.1
0CD4:  BRA    0CDE
0CD6:  MOVLW  06
0CD8:  MOVWF  FEA
0CDA:  MOVLW  40
0CDC:  MOVWF  FE9
0CDE:  CLRF   00
0CE0:  CLRF   01
0CE2:  CLRF   02
0CE4:  CLRF   03
0CE6:  MOVLB  6
0CE8:  CLRF   x40
0CEA:  CLRF   x41
0CEC:  CLRF   x42
0CEE:  CLRF   x43
0CF0:  MOVF   x3F,W
0CF2:  IORWF  x3E,W
0CF4:  IORWF  x3D,W
0CF6:  IORWF  x3C,W
0CF8:  BZ    0D52
0CFA:  MOVLW  20
0CFC:  MOVWF  x44
0CFE:  BCF    FD8.0
0D00:  RLCF   x38,F
0D02:  RLCF   x39,F
0D04:  RLCF   x3A,F
0D06:  RLCF   x3B,F
0D08:  RLCF   x40,F
0D0A:  RLCF   x41,F
0D0C:  RLCF   x42,F
0D0E:  RLCF   x43,F
0D10:  MOVF   x3F,W
0D12:  SUBWF  x43,W
0D14:  BNZ   0D26
0D16:  MOVF   x3E,W
0D18:  SUBWF  x42,W
0D1A:  BNZ   0D26
0D1C:  MOVF   x3D,W
0D1E:  SUBWF  x41,W
0D20:  BNZ   0D26
0D22:  MOVF   x3C,W
0D24:  SUBWF  x40,W
0D26:  BNC   0D46
0D28:  MOVF   x3C,W
0D2A:  SUBWF  x40,F
0D2C:  MOVF   x3D,W
0D2E:  BTFSS  FD8.0
0D30:  INCFSZ x3D,W
0D32:  SUBWF  x41,F
0D34:  MOVF   x3E,W
0D36:  BTFSS  FD8.0
0D38:  INCFSZ x3E,W
0D3A:  SUBWF  x42,F
0D3C:  MOVF   x3F,W
0D3E:  BTFSS  FD8.0
0D40:  INCFSZ x3F,W
0D42:  SUBWF  x43,F
0D44:  BSF    FD8.0
0D46:  RLCF   00,F
0D48:  RLCF   01,F
0D4A:  RLCF   02,F
0D4C:  RLCF   03,F
0D4E:  DECFSZ x44,F
0D50:  BRA    0CFE
0D52:  MOVFF  640,FEF
0D56:  MOVFF  641,FEC
0D5A:  MOVFF  642,FEC
0D5E:  MOVFF  643,FEC
0D62:  MOVLB  0
0D64:  GOTO   0EF4 (RETURN)
*
0F1C:  TBLRD*+
0F1E:  MOVFF  FF6,623
0F22:  MOVFF  FF7,624
0F26:  MOVF   FF5,W
0F28:  BTFSS  FA4.4
0F2A:  BRA    0F28
0F2C:  MOVWF  F79
0F2E:  MOVFF  623,FF6
0F32:  MOVFF  624,FF7
0F36:  MOVLB  6
0F38:  DECFSZ x22,F
0F3A:  BRA    0F3E
0F3C:  BRA    0F42
0F3E:  MOVLB  0
0F40:  BRA    0F1C
0F42:  MOVLB  0
0F44:  RETURN 0
0F46:  MOVFF  FEA,629
0F4A:  MOVFF  FE9,628
0F4E:  MOVLB  6
0F50:  SWAPF  x22,W
0F52:  IORLW  F0
0F54:  MOVWF  x24
0F56:  ADDWF  x24,F
0F58:  ADDLW  E2
0F5A:  MOVWF  x25
0F5C:  ADDLW  32
0F5E:  MOVWF  x27
0F60:  MOVF   x22,W
0F62:  ANDLW  0F
0F64:  ADDWF  x25,F
0F66:  ADDWF  x25,F
0F68:  ADDWF  x27,F
0F6A:  ADDLW  E9
0F6C:  MOVWF  x26
0F6E:  ADDWF  x26,F
0F70:  ADDWF  x26,F
0F72:  SWAPF  x21,W
0F74:  ANDLW  0F
0F76:  ADDWF  x26,F
0F78:  ADDWF  x27,F
0F7A:  RLCF   x26,F
0F7C:  RLCF   x27,F
0F7E:  COMF   x27,F
0F80:  RLCF   x27,F
0F82:  MOVF   x21,W
0F84:  ANDLW  0F
0F86:  ADDWF  x27,F
0F88:  RLCF   x24,F
0F8A:  MOVLW  07
0F8C:  MOVWF  x23
0F8E:  MOVLW  0A
0F90:  DECF   x26,F
0F92:  ADDWF  x27,F
0F94:  BNC   0F90
0F96:  DECF   x25,F
0F98:  ADDWF  x26,F
0F9A:  BNC   0F96
0F9C:  DECF   x24,F
0F9E:  ADDWF  x25,F
0FA0:  BNC   0F9C
0FA2:  DECF   x23,F
0FA4:  ADDWF  x24,F
0FA6:  BNC   0FA2
0FA8:  MOVLW  06
0FAA:  MOVWF  FEA
0FAC:  MOVLW  23
0FAE:  MOVWF  FE9
0FB0:  MOVLW  07
0FB2:  ANDWF  x28,W
0FB4:  BCF    x28.6
0FB6:  ADDWF  FE9,F
0FB8:  MOVLW  00
0FBA:  ADDWFC FEA,F
0FBC:  MOVF   FE9,W
0FBE:  SUBLW  27
0FC0:  BNZ   0FCA
0FC2:  MOVF   FEA,W
0FC4:  SUBLW  06
0FC6:  BNZ   0FCA
0FC8:  BSF    x28.6
0FCA:  MOVF   FEF,W
0FCC:  MOVWF  00
0FCE:  BNZ   0FE0
0FD0:  BTFSC  x28.6
0FD2:  BRA    0FE0
0FD4:  BTFSC  x28.4
0FD6:  BRA    0FF0
0FD8:  BTFSC  x28.3
0FDA:  BRA    0FE0
0FDC:  MOVLW  20
0FDE:  BRA    0FE6
0FE0:  BSF    x28.3
0FE2:  BCF    x28.4
0FE4:  MOVLW  30
0FE6:  ADDWF  00,F
0FE8:  MOVF   00,W
0FEA:  BTFSS  FA4.4
0FEC:  BRA    0FEA
0FEE:  MOVWF  F79
0FF0:  MOVF   FEE,W
0FF2:  BTFSS  x28.6
0FF4:  BRA    0FBC
0FF6:  MOVLB  0
0FF8:  RETURN 0
0FFA:  MOVLB  6
0FFC:  MOVF   x24,W
0FFE:  CLRF   01
1000:  SUBWF  x23,W
1002:  BC    100A
1004:  MOVFF  623,00
1008:  BRA    1022
100A:  CLRF   00
100C:  MOVLW  08
100E:  MOVWF  x25
1010:  RLCF   x23,F
1012:  RLCF   00,F
1014:  MOVF   x24,W
1016:  SUBWF  00,W
1018:  BTFSC  FD8.0
101A:  MOVWF  00
101C:  RLCF   01,F
101E:  DECFSZ x25,F
1020:  BRA    1010
1022:  MOVLB  0
1024:  RETURN 0
1026:  MOVF   01,W
1028:  MOVFF  621,623
102C:  MOVLW  64
102E:  MOVLB  6
1030:  MOVWF  x24
1032:  MOVLB  0
1034:  RCALL  0FFA
1036:  MOVFF  00,621
103A:  MOVF   01,W
103C:  MOVLW  30
103E:  BNZ   1050
1040:  MOVLB  6
1042:  BTFSS  x22.1
1044:  BRA    1062
1046:  BTFSC  x22.3
1048:  BRA    1062
104A:  BTFSC  x22.4
104C:  MOVLW  20
104E:  BRA    1058
1050:  MOVLB  6
1052:  BCF    x22.3
1054:  BCF    x22.4
1056:  BSF    x22.0
1058:  ADDWF  01,F
105A:  MOVF   01,W
105C:  BTFSS  FA4.4
105E:  BRA    105C
1060:  MOVWF  F79
1062:  MOVFF  621,623
1066:  MOVLW  0A
1068:  MOVWF  x24
106A:  MOVLB  0
106C:  RCALL  0FFA
106E:  MOVFF  00,621
1072:  MOVF   01,W
1074:  MOVLW  30
1076:  BNZ   1088
1078:  MOVLB  6
107A:  BTFSC  x22.3
107C:  BRA    1094
107E:  BTFSS  x22.0
1080:  BRA    1094
1082:  BTFSC  x22.4
1084:  MOVLW  20
1086:  MOVLB  0
1088:  ADDWF  01,F
108A:  MOVF   01,W
108C:  BTFSS  FA4.4
108E:  BRA    108C
1090:  MOVWF  F79
1092:  MOVLB  6
1094:  MOVLW  30
1096:  ADDWF  x21,F
1098:  MOVF   x21,W
109A:  BTFSS  FA4.4
109C:  BRA    109A
109E:  MOVWF  F79
10A0:  MOVLB  0
10A2:  GOTO   13FC (RETURN)
10A6:  TBLRD*+
10A8:  MOVF   FF5,F
10AA:  BZ    10C6
10AC:  MOVFF  FF6,621
10B0:  MOVFF  FF7,622
10B4:  MOVF   FF5,W
10B6:  BTFSS  FA4.4
10B8:  BRA    10B6
10BA:  MOVWF  F79
10BC:  MOVFF  621,FF6
10C0:  MOVFF  622,FF7
10C4:  BRA    10A6
10C6:  RETURN 0
*
10F4:  MOVLB  6
10F6:  BTFSC  x22.7
10F8:  BRA    111A
10FA:  MOVLW  0F
10FC:  MOVWF  00
10FE:  SWAPF  x21,W
1100:  ANDWF  00,F
1102:  MOVLW  0A
1104:  SUBWF  00,W
1106:  BC    110E
1108:  MOVLW  30
110A:  ADDWF  00,F
110C:  BRA    1112
110E:  MOVF   x22,W
1110:  ADDWF  00,F
1112:  MOVF   00,W
1114:  BTFSS  FA4.4
1116:  BRA    1114
1118:  MOVWF  F79
111A:  MOVLW  0F
111C:  ANDWF  x21,F
111E:  MOVLW  0A
1120:  SUBWF  x21,W
1122:  BC    1128
1124:  MOVLW  30
1126:  BRA    112C
1128:  BCF    x22.7
112A:  MOVF   x22,W
112C:  ADDWF  x21,F
112E:  MOVF   x21,W
1130:  BTFSS  FA4.4
1132:  BRA    1130
1134:  MOVWF  F79
1136:  MOVLB  0
1138:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... 
.................... #if 1
.................... /* no boot loader */
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BORV30
.................... #fuses WDT32768
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... 
.................... #else
.................... 
.................... /* DS30 boot loader version 1.5.1 - engine 2.2.2 */
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */
.................... /* max mem address - 0x243, max mem address - 0x240 */
.................... #build(reset=0x7dbc:0x7dbf)
.................... /* max mem address - 0x23f, max mem address - see memory organization in datasheet */
.................... //#org 0x7dc0,0x7fff {}
.................... #org 0x7dc0,0x7fff {}
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
0640:  MOVLW  06
0642:  MOVWF  FEA
0644:  MOVLW  22
0646:  MOVWF  FE9
0648:  MOVF   FEF,W
064A:  BZ    066E
064C:  MOVLW  02
064E:  MOVWF  01
0650:  MOVLW  BF
0652:  MOVWF  00
0654:  CLRWDT
0656:  DECFSZ 00,F
0658:  BRA    0654
065A:  DECFSZ 01,F
065C:  BRA    0650
065E:  MOVLW  96
0660:  MOVWF  00
0662:  DECFSZ 00,F
0664:  BRA    0662
0666:  BRA    0668
0668:  CLRWDT
066A:  DECFSZ FEF,F
066C:  BRA    064C
066E:  GOTO   07CC (RETURN)
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x000
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... /* UART1 - RS-485 connection modbus */
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=9600,xmit=PIN_C6,rcv=PIN_C7,errors)	
*
03EA:  BTFSS  F9E.5
03EC:  BRA    03EA
03EE:  MOVFF  FAB,20
03F2:  MOVFF  FAE,01
03F6:  BTFSS  20.1
03F8:  BRA    03FE
03FA:  BCF    FAB.4
03FC:  BSF    FAB.4
03FE:  RETURN 0
.................... 
.................... 
.................... #byte TXSTA=GETENV("SFR:txsta1")
.................... #bit  TRMT=TXSTA.1
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... #byte PORTB=GETENV("SFR:portb")
.................... #byte INTCON2=GETENV("SFR:intcon2")
.................... #bit RBPU=INTCON2.7
.................... 
.................... /* UART2 - FTDI cable */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600,errors)	
*
0382:  BTFSS  FA4.5
0384:  BRA    0382
0386:  MOVFF  FA6,20
038A:  MOVFF  F7A,01
038E:  BTFSS  20.1
0390:  BRA    0396
0392:  BCF    FA6.4
0394:  BSF    FA6.4
0396:  GOTO   039C (RETURN)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
0578:  BCF    FC6.7
057A:  BCF    F9E.3
057C:  MOVFF  626,FC9
0580:  MOVLW  02
0582:  BTFSC  FC6.7
0584:  BRA    0590
0586:  BTFSS  F9E.3
0588:  BRA    0586
058A:  MOVLW  00
058C:  BTFSC  FC5.6
058E:  MOVLW  01
0590:  MOVWF  01
0592:  RETURN 0
*
113A:  BCF    FC6.6
113C:  BSF    FC5.3
113E:  BTFSC  FC5.3
1140:  BRA    113E
1142:  BTFSC  00.0
1144:  BCF    FC5.5
1146:  BTFSS  00.0
1148:  BSF    FC5.5
114A:  BSF    FC5.4
114C:  BTFSC  FC5.4
114E:  BRA    114C
1150:  MOVFF  FC9,01
1154:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... /* Modbus defines */
.................... #define MODBUS_MODE_RTU     0
.................... #define MODBUS_MODE_TCP_RTU 1
.................... 
.................... #define SERIAL_PREFIX_DEFAULT 'Z'
.................... #define SERIAL_NUMBER_DEFAULT 2221
.................... 
.................... 
.................... #define DCSW_FPF2700_ACS714     0
.................... #define DCSW_LATCHING_CONTACTOR 1
.................... #define DCSW_SMALL48            2
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 startup;
.................... 
.................... 	int16 off_below_adc;
.................... 	int16 off_below_delay;
.................... 	int16 on_above_adc;
.................... 	int16 on_above_delay;
.................... 	int16 override_timeout;
.................... 	int16 switch_type;
.................... 
.................... 	signed int8 i_mon_offset; /* applied in addition to config.adc_offset */
.................... 	int8 adc_channel; /* which ADC channel (0 to 15) for LVD and HVD */
.................... 	int8 invert;
.................... } struct_output_channel;
.................... 
.................... typedef struct {
.................... 	int8 revision;
.................... 	int8 modbus_address;
.................... 	int8 modbus_mode;
.................... 
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 
.................... 	struct_output_channel ch[5];
.................... 	signed int8 adc_offset[16];
.................... 
.................... 	int8 uart_sc_sbd;
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int16 modbus_our_packets;
.................... 	int16 modbus_other_packets;
.................... 	int16 modbus_last_error;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 	int8 p_on[5];
.................... 	int16 adc[16];
.................... 	
.................... 	int16 on_delay[5];
.................... 	int16 off_delay[5];
.................... 	int16 override_timeout[5];
.................... 
.................... 
.................... 	int8 decide_now;
.................... 	int8 restart_now;
.................... 	int8 adc_sample_ch;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	int8 led_on_green;
.................... 	int8 led_on_red;
.................... } struct_time_keep;
.................... 
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "i2c_access_dcswcI2C.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
11E8:  BSF    FC5.0
11EA:  BTFSC  FC5.0
11EC:  BRA    11EA
.................... 	delay_us(15);
11EE:  CLRWDT
11F0:  MOVLW  09
11F2:  MOVWF  00
11F4:  DECFSZ 00,F
11F6:  BRA    11F4
11F8:  NOP   
.................... 	i2c_write(i2c_address);
11FA:  MOVFF  621,626
11FE:  CALL   0578
.................... 	i2c_write(regaddr);
1202:  MOVFF  622,626
1206:  CALL   0578
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
120A:  BSF    FC5.1
120C:  BTFSC  FC5.1
120E:  BRA    120C
.................... 	delay_us(15);
1210:  CLRWDT
1212:  MOVLW  09
1214:  MOVWF  00
1216:  DECFSZ 00,F
1218:  BRA    1216
121A:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
121C:  MOVLB  6
121E:  MOVF   x21,W
1220:  IORLW  01
1222:  MOVWF  x25
1224:  MOVWF  x26
1226:  MOVLB  0
1228:  CALL   0578
.................... 	msb=i2c_read(1);
122C:  MOVLW  01
122E:  MOVWF  00
1230:  RCALL  113A
1232:  MOVFF  01,623
.................... 	lsb=i2c_read(0);                                
1236:  CLRF   00
1238:  RCALL  113A
123A:  MOVFF  01,624
.................... 	i2c_stop();
123E:  BSF    FC5.2
1240:  BTFSC  FC5.2
1242:  BRA    1240
.................... 
.................... 	return make16(msb,lsb);
1244:  MOVFF  623,03
1248:  MOVLB  6
124A:  MOVFF  624,01
124E:  MOVFF  03,02
1252:  MOVLB  0
1254:  GOTO   153C (RETURN)
.................... }
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle         
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "uart_sc16is740_dcswcI2C.c"
.................... /* register map for SCI16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
1156:  BSF    FC5.0
1158:  BTFSC  FC5.0
115A:  BRA    1158
.................... 	delay_us(15);
115C:  CLRWDT
115E:  MOVLW  09
1160:  MOVWF  00
1162:  DECFSZ 00,F
1164:  BRA    1162
1166:  NOP   
.................... 	i2c_write(UART_ADDR);
1168:  MOVLW  9A
116A:  MOVLB  6
116C:  MOVWF  x26
116E:  MOVLB  0
1170:  CALL   0578
.................... 	i2c_write(regaddr<<3);
1174:  MOVLB  6
1176:  RLCF   x21,W
1178:  MOVWF  x23
117A:  RLCF   x23,F
117C:  RLCF   x23,F
117E:  MOVLW  F8
1180:  ANDWF  x23,F
1182:  MOVFF  623,626
1186:  MOVLB  0
1188:  CALL   0578
.................... 	i2c_start();
118C:  BSF    FC5.1
118E:  BTFSC  FC5.1
1190:  BRA    118E
.................... 	delay_us(15);
1192:  CLRWDT
1194:  MOVLW  09
1196:  MOVWF  00
1198:  DECFSZ 00,F
119A:  BRA    1198
119C:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
119E:  MOVLW  9B
11A0:  MOVLB  6
11A2:  MOVWF  x26
11A4:  MOVLB  0
11A6:  CALL   0578
.................... 	data=i2c_read(0);
11AA:  CLRF   00
11AC:  RCALL  113A
11AE:  MOVFF  01,622
.................... 	i2c_stop();
11B2:  BSF    FC5.2
11B4:  BTFSC  FC5.2
11B6:  BRA    11B4
.................... 
.................... 	return data;
11B8:  MOVLB  6
11BA:  MOVFF  622,01
11BE:  MOVLB  0
11C0:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
0594:  BSF    FC5.0
0596:  BTFSC  FC5.0
0598:  BRA    0596
.................... 	delay_us(15);                                                 
059A:  CLRWDT
059C:  MOVLW  09
059E:  MOVWF  00
05A0:  DECFSZ 00,F
05A2:  BRA    05A0
05A4:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
05A6:  MOVLW  9A
05A8:  MOVLB  6
05AA:  MOVWF  x26
05AC:  MOVLB  0
05AE:  RCALL  0578
.................... 	i2c_write(regaddr<< 3);  // write cycle         
05B0:  MOVLB  6
05B2:  RLCF   x23,W
05B4:  MOVWF  x25
05B6:  RLCF   x25,F
05B8:  RLCF   x25,F
05BA:  MOVLW  F8
05BC:  ANDWF  x25,F
05BE:  MOVFF  625,626
05C2:  MOVLB  0
05C4:  RCALL  0578
.................... 	i2c_write(data);
05C6:  MOVFF  624,626
05CA:  RCALL  0578
.................... 	i2c_stop();
05CC:  BSF    FC5.2
05CE:  BTFSC  FC5.2
05D0:  BRA    05CE
05D2:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
11D6:  MOVLB  6
11D8:  CLRF   x23
11DA:  MOVFF  621,624
11DE:  MOVLB  0
11E0:  CALL   0594
11E4:  GOTO   1524 (RETURN)
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
11C2:  MOVLW  05
11C4:  MOVLB  6
11C6:  MOVWF  x21
11C8:  MOVLB  0
11CA:  RCALL  1156
11CC:  MOVF   01,W
11CE:  ANDLW  01
11D0:  MOVWF  01
11D2:  GOTO   14A2 (RETURN)
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
*
14A6:  MOVLB  6
14A8:  CLRF   x21
14AA:  MOVLB  0
14AC:  RCALL  1156
14AE:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
05D4:  MOVLW  03
05D6:  MOVLB  6
05D8:  MOVWF  x23
05DA:  MOVLW  80
05DC:  MOVWF  x24
05DE:  MOVLB  0
05E0:  RCALL  0594
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
05E2:  MOVLB  6
05E4:  CLRF   x23
05E6:  MOVFF  622,624
05EA:  MOVLB  0
05EC:  RCALL  0594
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
05EE:  MOVLW  01
05F0:  MOVLB  6
05F2:  MOVWF  x23
05F4:  CLRF   x24
05F6:  MOVLB  0
05F8:  RCALL  0594
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
05FA:  MOVLW  03
05FC:  MOVLB  6
05FE:  MOVWF  x23
0600:  MOVLW  BF
0602:  MOVWF  x24
0604:  MOVLB  0
0606:  RCALL  0594
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
0608:  MOVLW  02
060A:  MOVLB  6
060C:  MOVWF  x23
060E:  MOVLW  10
0610:  MOVWF  x24
0612:  MOVLB  0
0614:  RCALL  0594
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0616:  MOVLW  03
0618:  MOVLB  6
061A:  MOVWF  x23
061C:  MOVWF  x24
061E:  MOVLB  0
0620:  RCALL  0594
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
0622:  MOVLW  01
0624:  MOVLB  6
0626:  MOVWF  x23
0628:  CLRF   x24
062A:  MOVLB  0
062C:  RCALL  0594
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
062E:  MOVLW  02
0630:  MOVLB  6
0632:  MOVWF  x23
0634:  MOVLW  07
0636:  MOVWF  x24
0638:  MOVLB  0
063A:  RCALL  0594
063C:  GOTO   07C2 (RETURN)
.................... }
.................... 
.................... 
.................... #include "mcp3208_dcswcI2C.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
*
056E:  BCF    F93.4
0570:  BSF    F8A.4
.................... 	output_high(CS_ADC0);
0572:  BCF    F93.0
0574:  BSF    F8A.0
0576:  RETURN 0
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
*
0BDA:  BCF    F93.3
0BDC:  BCF    F8A.3
.................... 	output_high(MCP3208_DIN);
0BDE:  BCF    F93.1
0BE0:  BSF    F8A.1
.................... 
.................... 
.................... 	if ( ch<8 ) {
0BE2:  MOVLB  6
0BE4:  MOVF   x23,W
0BE6:  SUBLW  07
0BE8:  BNC   0BF0
.................... 		output_low(CS_ADC0);
0BEA:  BCF    F93.0
0BEC:  BCF    F8A.0
.................... 	} else {
0BEE:  BRA    0BF8
.................... 		output_low(CS_ADC1);
0BF0:  BCF    F93.4
0BF2:  BCF    F8A.4
.................... 		ch-=8;
0BF4:  MOVLW  08
0BF6:  SUBWF  x23,F
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
0BF8:  MOVF   x23,F
0BFA:  BNZ   0C02
.................... 		c=0b00011;
0BFC:  MOVLW  03
0BFE:  MOVWF  x27
0C00:  BRA    0C4C
.................... 	else if ( 1 == ch ) 
0C02:  DECFSZ x23,W
0C04:  BRA    0C0C
.................... 		c=0b10011;
0C06:  MOVLW  13
0C08:  MOVWF  x27
0C0A:  BRA    0C4C
.................... 	else if ( 2 == ch ) 
0C0C:  MOVF   x23,W
0C0E:  SUBLW  02
0C10:  BNZ   0C18
.................... 		c=0b01011;
0C12:  MOVLW  0B
0C14:  MOVWF  x27
0C16:  BRA    0C4C
.................... 	else if ( 3 == ch ) 
0C18:  MOVF   x23,W
0C1A:  SUBLW  03
0C1C:  BNZ   0C24
.................... 		c=0b11011;
0C1E:  MOVLW  1B
0C20:  MOVWF  x27
0C22:  BRA    0C4C
.................... 	else if ( 4 == ch )
0C24:  MOVF   x23,W
0C26:  SUBLW  04
0C28:  BNZ   0C30
.................... 		c=0b00111;
0C2A:  MOVLW  07
0C2C:  MOVWF  x27
0C2E:  BRA    0C4C
.................... 	else if ( 5 == ch ) 
0C30:  MOVF   x23,W
0C32:  SUBLW  05
0C34:  BNZ   0C3C
.................... 		c=0b10111;
0C36:  MOVLW  17
0C38:  MOVWF  x27
0C3A:  BRA    0C4C
.................... 	else if ( 6 == ch )
0C3C:  MOVF   x23,W
0C3E:  SUBLW  06
0C40:  BNZ   0C48
.................... 		c=0b01111;
0C42:  MOVLW  0F
0C44:  MOVWF  x27
0C46:  BRA    0C4C
.................... 	else
.................... 		c=0b11111;
0C48:  MOVLW  1F
0C4A:  MOVWF  x27
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0C4C:  CLRF   x26
0C4E:  MOVF   x26,W
0C50:  SUBLW  04
0C52:  BNC   0C70
.................... 		output_low(MCP3208_CLK);
0C54:  BCF    F93.3
0C56:  BCF    F8A.3
.................... 		output_bit(MCP3208_DIN,c&1);
0C58:  BTFSC  x27.0
0C5A:  BRA    0C60
0C5C:  BCF    F8A.1
0C5E:  BRA    0C62
0C60:  BSF    F8A.1
0C62:  BCF    F93.1
.................... 		c=c>>1;
0C64:  BCF    FD8.0
0C66:  RRCF   x27,F
.................... 		output_high(MCP3208_CLK);
0C68:  BCF    F93.3
0C6A:  BSF    F8A.3
0C6C:  INCF   x26,F
0C6E:  BRA    0C4E
.................... 	}
.................... 
.................... 
.................... 	value=0;
0C70:  CLRF   x25
0C72:  CLRF   x24
.................... 	for ( i=0 ; i<14 ; i++ ) {
0C74:  CLRF   x26
0C76:  MOVF   x26,W
0C78:  SUBLW  0D
0C7A:  BNC   0C98
.................... 		output_low(MCP3208_CLK);
0C7C:  BCF    F93.3
0C7E:  BCF    F8A.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
0C80:  BSF    F93.2
0C82:  BTFSC  F81.2
0C84:  BRA    0C8A
0C86:  BCF    FD8.0
0C88:  BRA    0C8C
0C8A:  BSF    FD8.0
0C8C:  RLCF   x24,F
0C8E:  RLCF   x25,F
.................... 		output_high(MCP3208_CLK);
0C90:  BCF    F93.3
0C92:  BSF    F8A.3
0C94:  INCF   x26,F
0C96:  BRA    0C76
.................... 	}
.................... 
.................... 	bit_clear(value,13);
0C98:  BCF    x25.5
.................... 	bit_clear(value,12);
0C9A:  BCF    x25.4
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
0C9C:  MOVLB  0
0C9E:  RCALL  056E
.................... 
.................... 	return value;
0CA0:  MOVLB  6
0CA2:  MOVFF  624,01
0CA6:  MOVFF  625,02
0CAA:  MOVLB  0
0CAC:  GOTO   1362 (RETURN)
.................... }
.................... 
.................... #include "interrupt_dcswcI2C.c"
.................... 
.................... #int_timer3
.................... void isr_10ms(void) {
.................... 	static int16 uptimeTicks=0;
.................... 	static int16 ticks=0;
.................... 	static int8 adc_ch=0;
.................... 
.................... 	/* preset so we trigger again in 10 milliseconds */
.................... 	set_timer3(45536);
*
02F2:  MOVLW  B1
02F4:  MOVWF  FB3
02F6:  MOVLW  E0
02F8:  MOVWF  FB2
.................... 
.................... 	/* scan adc channels */
.................... 	current.adc_sample_ch = adc_ch;
02FA:  MOVFF  E1,DA
.................... 	/* each adc read gives us two channels */
.................... 	adc_ch+=2;
02FE:  MOVLW  02
0300:  ADDWF  xE1,F
.................... 
.................... 	if ( adc_ch >= 16 ) 
0302:  MOVF   xE1,W
0304:  SUBLW  0F
0306:  BC    030A
.................... 		adc_ch=0;
0308:  CLRF   xE1
.................... 
.................... 	/* LVD / HVD flag */
.................... 	current.decide_now=1;
030A:  MOVLW  01
030C:  MOVWF  xD8
.................... 
.................... 
.................... 	/* ticks(?) since last query */
.................... 	if ( current.interval_milliseconds < 65525 ) {
030E:  MOVF   x93,W
0310:  SUBLW  FF
0312:  BNC   0326
0314:  BNZ   031C
0316:  MOVF   x92,W
0318:  SUBLW  F4
031A:  BNC   0326
.................... 		current.interval_milliseconds+=10;
031C:  MOVLW  0A
031E:  ADDWF  x92,F
0320:  MOVLW  00
0322:  ADDWFC x93,F
.................... 	} else {
0324:  BRA    032A
.................... 		current.interval_milliseconds=65535;
0326:  SETF   x93
0328:  SETF   x92
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
032A:  INCF   xDF,F
032C:  BTFSC  FD8.2
032E:  INCF   xE0,F
.................... 	if ( ticks >= 100 ) {
0330:  MOVF   xE0,F
0332:  BNZ   033A
0334:  MOVF   xDF,W
0336:  SUBLW  63
0338:  BC    033E
.................... 		ticks=0;
033A:  CLRF   xE0
033C:  CLRF   xDF
.................... 	}
.................... 	
.................... 
.................... 	/* uptime counter */
.................... 	uptimeTicks++;
033E:  INCF   xDD,F
0340:  BTFSC  FD8.2
0342:  INCF   xDE,F
.................... 	if ( 6000 == uptimeTicks ) {
0344:  MOVF   xDD,W
0346:  SUBLW  70
0348:  BNZ   0364
034A:  MOVF   xDE,W
034C:  SUBLW  17
034E:  BNZ   0364
.................... 		uptimeTicks=0;
0350:  CLRF   xDE
0352:  CLRF   xDD
.................... 		if ( current.uptime_minutes < 65535 ) 
0354:  INCFSZ x90,W
0356:  BRA    035E
0358:  INCFSZ x91,W
035A:  BRA    035E
035C:  BRA    0364
.................... 			current.uptime_minutes++;
035E:  INCF   x90,F
0360:  BTFSC  FD8.2
0362:  INCF   x91,F
.................... 	}
.................... 
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
0364:  MOVF   xDB,F
0366:  BNZ   036E
.................... 		output_low(LED_GREEN);
0368:  BCF    F93.5
036A:  BCF    F8A.5
.................... 	} else {
036C:  BRA    0374
.................... 		output_high(LED_GREEN);
036E:  BCF    F93.5
0370:  BSF    F8A.5
.................... 		timers.led_on_green--;
0372:  DECF   xDB,F
.................... 	}
.................... 
.................... 	if ( 0==timers.led_on_red ) {
0374:  MOVF   xDC,F
0376:  BNZ   037A
.................... //		output_low(LED_RED);
.................... 	} else {
0378:  BRA    037C
.................... //		output_high(LED_RED);
.................... 		timers.led_on_red--;
037A:  DECF   xDC,F
.................... 	}
.................... }
.................... 
037C:  BCF    FA1.1
037E:  GOTO   0084
.................... #int_rda2
.................... /* any character on FTDI serial port (UART2) will case a reset */
.................... void ftdi_isr(void) {
.................... 	current.restart_now=fgetc(STREAM_WORLD);
*
039A:  BRA    0382
039C:  MOVFF  01,D9
.................... //	current.restart_now=1;
.................... }
.................... 
.................... #include "param_dcswcI2C.c"
03A0:  BCF    FA4.5
03A2:  GOTO   0084
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
083C:  MOVF   x2E,W
083E:  XORWF  x2F,W
0840:  MOVWF  01
*
088A:  MOVF   x2E,W
088C:  XORWF  x2F,W
088E:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
07D0:  MOVLB  6
07D2:  CLRF   x2A
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
07D4:  MOVFF  629,62C
07D8:  MOVF   x28,W
07DA:  BTFSC  FD8.2
07DC:  DECF   x29,F
07DE:  DECF   x28,F
07E0:  MOVWF  x2B
07E2:  MOVF   x2B,F
07E4:  BNZ   07EA
07E6:  MOVF   x2C,F
07E8:  BZ    084E
.................... 		*data = read_eeprom( address++ );
07EA:  MOVFF  627,03
07EE:  MOVF   x26,W
07F0:  MOVWF  FE9
07F2:  MOVFF  03,FEA
07F6:  MOVF   x25,W
07F8:  MOVWF  03
07FA:  MOVF   x24,W
07FC:  INCF   x24,F
07FE:  BTFSC  FD8.2
0800:  INCF   x25,F
0802:  MOVWF  x2D
0804:  MOVFF  03,62E
0808:  MOVFF  FF2,62F
080C:  BCF    FF2.7
080E:  MOVFF  62E,F75
0812:  MOVFF  62D,F74
0816:  BCF    F7F.6
0818:  BCF    F7F.7
081A:  BSF    F7F.0
081C:  MOVF   F73,W
081E:  BTFSC  x2F.7
0820:  BSF    FF2.7
0822:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0824:  MOVFF  627,03
0828:  MOVF   x26,W
082A:  MOVWF  FE9
082C:  MOVFF  03,FEA
0830:  MOVFF  FEF,62B
0834:  MOVFF  62A,62E
0838:  MOVFF  62B,62F
*
0842:  MOVFF  01,62A
.................... 		data++;
0846:  INCF   x26,F
0848:  BTFSC  FD8.2
084A:  INCF   x27,F
084C:  BRA    07D4
.................... 	}
.................... 	return crc;
084E:  MOVFF  62A,01
0852:  MOVLB  0
0854:  GOTO   0B80 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
0858:  MOVLB  6
085A:  CLRF   x2C
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
085C:  MOVFF  62B,62E
0860:  MOVF   x2A,W
0862:  BTFSC  FD8.2
0864:  DECF   x2B,F
0866:  DECF   x2A,F
0868:  MOVWF  x2D
086A:  MOVF   x2D,F
086C:  BNZ   0872
086E:  MOVF   x2E,F
0870:  BZ    08EE
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0872:  MOVFF  629,03
0876:  MOVF   x28,W
0878:  MOVWF  FE9
087A:  MOVFF  03,FEA
087E:  MOVFF  FEF,62D
0882:  MOVFF  62C,62E
0886:  MOVFF  62D,62F
*
0890:  MOVFF  01,62C
.................... 		write_eeprom( address++, *data++ );
0894:  MOVF   x27,W
0896:  MOVWF  03
0898:  MOVF   x26,W
089A:  INCF   x26,F
089C:  BTFSC  FD8.2
089E:  INCF   x27,F
08A0:  MOVWF  x2D
08A2:  MOVFF  03,62E
08A6:  MOVF   x29,W
08A8:  MOVWF  03
08AA:  MOVF   x28,W
08AC:  INCF   x28,F
08AE:  BTFSC  FD8.2
08B0:  INCF   x29,F
08B2:  MOVWF  FE9
08B4:  MOVFF  03,FEA
08B8:  MOVFF  FEF,62F
08BC:  MOVF   FF2,W
08BE:  MOVWF  00
08C0:  BCF    FF2.7
08C2:  MOVFF  62E,F75
08C6:  MOVFF  62D,F74
08CA:  MOVFF  62F,F73
08CE:  BCF    F7F.6
08D0:  BCF    F7F.7
08D2:  BSF    F7F.2
08D4:  MOVLB  F
08D6:  MOVLW  55
08D8:  MOVWF  F7E
08DA:  MOVLW  AA
08DC:  MOVWF  F7E
08DE:  BSF    F7F.1
08E0:  BTFSC  F7F.1
08E2:  BRA    08E0
08E4:  BCF    F7F.2
08E6:  MOVF   00,W
08E8:  IORWF  FF2,F
08EA:  MOVLB  6
08EC:  BRA    085C
.................... 	}
.................... 
.................... 	return crc;
08EE:  MOVFF  62C,01
08F2:  MOVLB  0
08F4:  GOTO   0914 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
08F8:  MOVLB  6
08FA:  MOVLW  21
08FC:  MOVWF  x24
08FE:  CLRF   x27
0900:  MOVLW  02
0902:  MOVWF  x26
0904:  CLRF   x29
0906:  MOVFF  624,628
090A:  CLRF   x2B
090C:  MOVLW  67
090E:  MOVWF  x2A
0910:  MOVLB  0
0912:  BRA    0858
0914:  MOVFF  01,623
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
0918:  MOVF   FF2,W
091A:  MOVWF  00
091C:  BCF    FF2.7
091E:  CLRF   F75
0920:  CLRF   F74
0922:  MOVFF  623,F73
0926:  BCF    F7F.6
0928:  BCF    F7F.7
092A:  BSF    F7F.2
092C:  MOVLB  F
092E:  MOVLW  55
0930:  MOVWF  F7E
0932:  MOVLW  AA
0934:  MOVWF  F7E
0936:  BSF    F7F.1
0938:  BTFSC  F7F.1
093A:  BRA    0938
093C:  BCF    F7F.2
093E:  MOVF   00,W
0940:  IORWF  FF2,F
0942:  MOVLB  0
0944:  GOTO   0B62 (RETURN)
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0948:  MOVLW  96
094A:  MOVWF  xDB
.................... 
.................... 	config.revision='a';
094C:  MOVLW  61
094E:  MOVWF  21
.................... 
.................... 	config.modbus_address=37;
0950:  MOVLW  25
0952:  MOVWF  22
.................... 	config.modbus_mode=MODBUS_MODE_RTU;
0954:  CLRF   23
.................... 
.................... 	config.serial_prefix=SERIAL_PREFIX_DEFAULT;
0956:  MOVLW  5A
0958:  MOVWF  24
.................... 	config.serial_number=SERIAL_NUMBER_DEFAULT;
095A:  MOVLW  08
095C:  MOVWF  26
095E:  MOVLW  AD
0960:  MOVWF  25
.................... 
.................... 	/* initialize the channel configurations */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0962:  MOVLB  6
0964:  CLRF   x22
0966:  MOVF   x22,W
0968:  SUBLW  04
096A:  BTFSS  FD8.0
096C:  BRA    0B42
.................... 		config.ch[i].startup=0;
096E:  MOVF   x22,W
0970:  MULLW  10
0972:  MOVF   FF3,W
0974:  CLRF   03
0976:  ADDLW  27
0978:  MOVWF  FE9
097A:  MOVLW  00
097C:  ADDWFC 03,W
097E:  MOVWF  FEA
0980:  CLRF   FEF
.................... 
.................... 		config.ch[i].adc_channel=i*2;
0982:  MOVF   x22,W
0984:  MULLW  10
0986:  MOVF   FF3,W
0988:  CLRF   03
098A:  ADDLW  06
098C:  MOVWF  x23
098E:  MOVLW  00
0990:  ADDWFC 03,W
0992:  MOVWF  x24
0994:  MOVLW  0E
0996:  ADDWF  x23,W
0998:  MOVWF  01
099A:  MOVLW  00
099C:  ADDWFC x24,W
099E:  MOVWF  03
09A0:  MOVF   01,W
09A2:  ADDLW  21
09A4:  MOVWF  FE9
09A6:  MOVLW  00
09A8:  ADDWFC 03,W
09AA:  MOVWF  FEA
09AC:  BCF    FD8.0
09AE:  RLCF   x22,W
09B0:  MOVWF  FEF
.................... 		config.ch[i].off_below_adc=500;
09B2:  MOVF   x22,W
09B4:  MULLW  10
09B6:  MOVF   FF3,W
09B8:  CLRF   03
09BA:  ADDLW  06
09BC:  MOVWF  x23
09BE:  MOVLW  00
09C0:  ADDWFC 03,W
09C2:  MOVWF  x24
09C4:  MOVLW  01
09C6:  ADDWF  x23,W
09C8:  MOVWF  01
09CA:  MOVLW  00
09CC:  ADDWFC x24,W
09CE:  MOVWF  03
09D0:  MOVF   01,W
09D2:  ADDLW  21
09D4:  MOVWF  FE9
09D6:  MOVLW  00
09D8:  ADDWFC 03,W
09DA:  MOVWF  FEA
09DC:  MOVLW  01
09DE:  MOVWF  FEC
09E0:  MOVF   FED,F
09E2:  MOVLW  F4
09E4:  MOVWF  FEF
.................... 		config.ch[i].off_below_delay=500;
09E6:  MOVF   x22,W
09E8:  MULLW  10
09EA:  MOVF   FF3,W
09EC:  CLRF   03
09EE:  ADDLW  06
09F0:  MOVWF  x23
09F2:  MOVLW  00
09F4:  ADDWFC 03,W
09F6:  MOVWF  x24
09F8:  MOVLW  03
09FA:  ADDWF  x23,W
09FC:  MOVWF  01
09FE:  MOVLW  00
0A00:  ADDWFC x24,W
0A02:  MOVWF  03
0A04:  MOVF   01,W
0A06:  ADDLW  21
0A08:  MOVWF  FE9
0A0A:  MOVLW  00
0A0C:  ADDWFC 03,W
0A0E:  MOVWF  FEA
0A10:  MOVLW  01
0A12:  MOVWF  FEC
0A14:  MOVF   FED,F
0A16:  MOVLW  F4
0A18:  MOVWF  FEF
.................... 		config.ch[i].on_above_adc=700;
0A1A:  MOVF   x22,W
0A1C:  MULLW  10
0A1E:  MOVF   FF3,W
0A20:  CLRF   03
0A22:  ADDLW  06
0A24:  MOVWF  x23
0A26:  MOVLW  00
0A28:  ADDWFC 03,W
0A2A:  MOVWF  x24
0A2C:  MOVLW  05
0A2E:  ADDWF  x23,W
0A30:  MOVWF  01
0A32:  MOVLW  00
0A34:  ADDWFC x24,W
0A36:  MOVWF  03
0A38:  MOVF   01,W
0A3A:  ADDLW  21
0A3C:  MOVWF  FE9
0A3E:  MOVLW  00
0A40:  ADDWFC 03,W
0A42:  MOVWF  FEA
0A44:  MOVLW  02
0A46:  MOVWF  FEC
0A48:  MOVF   FED,F
0A4A:  MOVLW  BC
0A4C:  MOVWF  FEF
.................... 		config.ch[i].on_above_delay=1000;
0A4E:  MOVF   x22,W
0A50:  MULLW  10
0A52:  MOVF   FF3,W
0A54:  CLRF   03
0A56:  ADDLW  06
0A58:  MOVWF  x23
0A5A:  MOVLW  00
0A5C:  ADDWFC 03,W
0A5E:  MOVWF  x24
0A60:  MOVLW  07
0A62:  ADDWF  x23,W
0A64:  MOVWF  01
0A66:  MOVLW  00
0A68:  ADDWFC x24,W
0A6A:  MOVWF  03
0A6C:  MOVF   01,W
0A6E:  ADDLW  21
0A70:  MOVWF  FE9
0A72:  MOVLW  00
0A74:  ADDWFC 03,W
0A76:  MOVWF  FEA
0A78:  MOVLW  03
0A7A:  MOVWF  FEC
0A7C:  MOVF   FED,F
0A7E:  MOVLW  E8
0A80:  MOVWF  FEF
.................... 
.................... 		config.ch[i].override_timeout=300;
0A82:  MOVF   x22,W
0A84:  MULLW  10
0A86:  MOVF   FF3,W
0A88:  CLRF   03
0A8A:  ADDLW  06
0A8C:  MOVWF  x23
0A8E:  MOVLW  00
0A90:  ADDWFC 03,W
0A92:  MOVWF  x24
0A94:  MOVLW  09
0A96:  ADDWF  x23,W
0A98:  MOVWF  01
0A9A:  MOVLW  00
0A9C:  ADDWFC x24,W
0A9E:  MOVWF  03
0AA0:  MOVF   01,W
0AA2:  ADDLW  21
0AA4:  MOVWF  FE9
0AA6:  MOVLW  00
0AA8:  ADDWFC 03,W
0AAA:  MOVWF  FEA
0AAC:  MOVLW  01
0AAE:  MOVWF  FEC
0AB0:  MOVF   FED,F
0AB2:  MOVLW  2C
0AB4:  MOVWF  FEF
.................... 
.................... 		config.ch[i].switch_type=DCSW_FPF2700_ACS714;
0AB6:  MOVF   x22,W
0AB8:  MULLW  10
0ABA:  MOVF   FF3,W
0ABC:  CLRF   03
0ABE:  ADDLW  06
0AC0:  MOVWF  x23
0AC2:  MOVLW  00
0AC4:  ADDWFC 03,W
0AC6:  MOVWF  x24
0AC8:  MOVLW  0B
0ACA:  ADDWF  x23,W
0ACC:  MOVWF  01
0ACE:  MOVLW  00
0AD0:  ADDWFC x24,W
0AD2:  MOVWF  03
0AD4:  MOVF   01,W
0AD6:  ADDLW  21
0AD8:  MOVWF  FE9
0ADA:  MOVLW  00
0ADC:  ADDWFC 03,W
0ADE:  MOVWF  FEA
0AE0:  CLRF   FEC
0AE2:  MOVF   FED,F
0AE4:  CLRF   FEF
.................... 		config.ch[i].i_mon_offset=0;
0AE6:  MOVF   x22,W
0AE8:  MULLW  10
0AEA:  MOVF   FF3,W
0AEC:  CLRF   03
0AEE:  ADDLW  06
0AF0:  MOVWF  x23
0AF2:  MOVLW  00
0AF4:  ADDWFC 03,W
0AF6:  MOVWF  x24
0AF8:  MOVLW  0D
0AFA:  ADDWF  x23,W
0AFC:  MOVWF  01
0AFE:  MOVLW  00
0B00:  ADDWFC x24,W
0B02:  MOVWF  03
0B04:  MOVF   01,W
0B06:  ADDLW  21
0B08:  MOVWF  FE9
0B0A:  MOVLW  00
0B0C:  ADDWFC 03,W
0B0E:  MOVWF  FEA
0B10:  CLRF   FEF
.................... 		config.ch[i].invert=0;
0B12:  MOVF   x22,W
0B14:  MULLW  10
0B16:  MOVF   FF3,W
0B18:  CLRF   03
0B1A:  ADDLW  06
0B1C:  MOVWF  x23
0B1E:  MOVLW  00
0B20:  ADDWFC 03,W
0B22:  MOVWF  x24
0B24:  MOVLW  0F
0B26:  ADDWF  x23,W
0B28:  MOVWF  01
0B2A:  MOVLW  00
0B2C:  ADDWFC x24,W
0B2E:  MOVWF  03
0B30:  MOVF   01,W
0B32:  ADDLW  21
0B34:  MOVWF  FE9
0B36:  MOVLW  00
0B38:  ADDWFC 03,W
0B3A:  MOVWF  FEA
0B3C:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* spanish fork */
.................... 	/*
.................... 		ch0 (A) - 12 volt bus
.................... 			off at 12.0 (adc=819 input=0) volts 60 second delay
.................... 
.................... 		ch1 (B) - 24 volt bus
.................... 			off at 24.0 (adc=1638 input=1) volts 60 second delay
.................... 
.................... 		ch2 (C) - Wind MPPT to 24 volt controller (unused)
.................... 			off at 24.0 (adc=1638 input=1) volts 60 second delay
.................... 		
.................... 		ch3 (D) - 48 volt LVD bus
.................... 			off at 48.0 (adc=3277 input=2) volts 60 second delay
.................... 
.................... 		ch4 (E) - wind MPPT to 48 volt controller (unused)
.................... 			off at 48.0 (adc=3277 input=3) volts 60 second delay
.................... 	*/
.................... 
.................... 	config.serial_prefix='A';
.................... 	config.serial_number=3387;
.................... 	config.modbus_address=50;
.................... 
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=0;
.................... 	config.ch[0].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[0].off_below_adc=819;
.................... 	config.ch[0].off_below_delay=6000;
.................... 	config.ch[0].on_above_adc=839;
.................... 	config.ch[0].on_above_delay=6000;
.................... 
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=2;
.................... 	config.ch[1].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[1].off_below_adc=1638;
.................... 	config.ch[1].off_below_delay=6000;
.................... 	config.ch[1].on_above_adc=1658;
.................... 	config.ch[1].on_above_delay=6000;
.................... 
.................... 	config.ch[2].startup=0;
.................... 	config.ch[2].adc_channel=2;
.................... 	config.ch[2].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[2].off_below_adc=1638;
.................... 	config.ch[2].off_below_delay=6000;
.................... 	config.ch[2].on_above_adc=1658;
.................... 	config.ch[2].on_above_delay=6000;
.................... 
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=4;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].off_below_adc=3277;
.................... 	config.ch[3].off_below_delay=6000;
.................... 	config.ch[3].on_above_adc=3297;
.................... 	config.ch[3].on_above_delay=6000;
.................... 
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=4;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].off_below_adc=3277;
.................... 	config.ch[4].off_below_delay=6000;
.................... 	config.ch[4].on_above_adc=3297;
.................... 	config.ch[4].on_above_delay=6000;
.................... 
.................... #endif
.................... 
.................... #if 0
.................... 	/* porcupine dome LVD */
.................... 	/*
.................... 	ch4 (top) - classic for kestrel
.................... 		off at 47.0 (adc=3209) volts with 60 second delay
.................... 	ch3 - DAS panel
.................... 		off at 47.5 (adc=3243) volts with 60 second delay
.................... 	ch2 - CAM panel
.................... 		off at 48.5 (adc=3311) volts with 60 second delay
.................... 	ch1 - inverter (satellite)
.................... 		off at 50.0 (adc=3413) volts with 300 second delay
.................... 	ch0 - heater for anemometer
.................... 		off at 54.0 (adc=3685) volts with 10 second delay
.................... 	*/
.................... 
.................... 	config.serial_prefix='A';
.................... 	config.serial_number=3420;
.................... 	config.modbus_address=50;
.................... 
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=0;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].off_below_adc=3209;
.................... 	config.ch[4].off_below_delay=6000;
.................... 	config.ch[4].on_above_adc=3229;
.................... 	config.ch[4].on_above_delay=6000;
.................... 
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=0;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].off_below_adc=3243;
.................... 	config.ch[3].off_below_delay=6000;
.................... 	config.ch[3].on_above_adc=3263;
.................... 	config.ch[3].on_above_delay=6000;
.................... 
.................... 	config.ch[2].startup=0;
.................... 	config.ch[2].adc_channel=0;
.................... 	config.ch[2].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[2].off_below_adc=3311;
.................... 	config.ch[2].off_below_delay=6000;
.................... 	config.ch[2].on_above_adc=3331;
.................... 	config.ch[2].on_above_delay=6000;
.................... 
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=0;
.................... 	config.ch[1].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[1].off_below_adc=3413;
.................... 	config.ch[1].off_below_delay=30000;
.................... 	config.ch[1].on_above_adc=3433;
.................... 	config.ch[1].on_above_delay=30000;
.................... 
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=0;
.................... 	config.ch[0].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[0].off_below_adc=3685;
.................... 	config.ch[0].off_below_delay=1000;
.................... 	config.ch[0].on_above_adc=3705;
.................... 	config.ch[0].on_above_delay=1000;
.................... 
.................... #endif
.................... 
.................... 
.................... #if 0
0B3E:  INCF   x22,F
0B40:  BRA    0966
.................... 	/* porcupine dome turbine stop controller */
.................... 	config.modbus_address=51;
.................... 
.................... 	/* 3 phase SSR for ? */
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=16;
.................... 	config.ch[0].switch_type=DCSW_FPF2700_ACS714;
.................... 	config.ch[0].invert=1;
.................... 
.................... 	/* 3 phase SSR for ? */
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=16;
.................... 	config.ch[1].switch_type=DCSW_FPF2700_ACS714;
.................... 	config.ch[1].invert=1;
.................... 
.................... 	/* unused */
.................... 
.................... 	/* 2 x latching contactor (to disconnect / stop) for ? */
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=16;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].invert=0;
.................... 
.................... 	/* 2 x latching contactor (to disconnect / stop) for ? */
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=16;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].invert=0;
.................... #endif
.................... 
.................... 	for ( i=0 ; i<16 ; i++ ) {
0B42:  CLRF   x22
0B44:  MOVF   x22,W
0B46:  SUBLW  0F
0B48:  BNC   0B5E
.................... 		config.adc_offset[i]=0;
0B4A:  CLRF   03
0B4C:  MOVF   x22,W
0B4E:  ADDLW  77
0B50:  MOVWF  FE9
0B52:  MOVLW  00
0B54:  ADDWFC 03,W
0B56:  MOVWF  FEA
0B58:  CLRF   FEF
0B5A:  INCF   x22,F
0B5C:  BRA    0B44
.................... 	}
.................... 
.................... 
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0B5E:  MOVLB  0
0B60:  BRA    08F8
0B62:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
0B64:  MOVLB  6
0B66:  MOVLW  21
0B68:  MOVWF  x22
0B6A:  CLRF   x25
0B6C:  MOVLW  02
0B6E:  MOVWF  x24
0B70:  CLRF   x27
0B72:  MOVFF  622,626
0B76:  CLRF   x29
0B78:  MOVLW  67
0B7A:  MOVWF  x28
0B7C:  MOVLB  0
0B7E:  BRA    07D0
0B80:  MOVFF  01,621
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) {
0B84:  MOVFF  FF2,622
0B88:  BCF    FF2.7
0B8A:  CLRF   F75
0B8C:  CLRF   F74
0B8E:  BCF    F7F.6
0B90:  BCF    F7F.7
0B92:  BSF    F7F.0
0B94:  MOVF   F73,W
0B96:  MOVLB  6
0B98:  BTFSC  x22.7
0B9A:  BSF    FF2.7
0B9C:  SUBWF  x21,W
0B9E:  BNZ   0BAC
0BA0:  MOVF   21,W
0BA2:  SUBLW  60
0BA4:  BC    0BAC
0BA6:  MOVF   21,W
0BA8:  SUBLW  7A
0BAA:  BC    0BB2
.................... 		write_default_param_file();
0BAC:  MOVLB  0
0BAE:  RCALL  0948
0BB0:  MOVLB  6
.................... 	}
0BB2:  MOVLB  0
0BB4:  GOTO   1320 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... #include "modbus_slave_dcswcI2C.c"
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us
.................... 
.................... 
.................... //#use rs232(baud=9600, UART1, parity=N, stream=MODBUS_SERIAL)
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... 
.................... void rcv_off(void) {
.................... 	output_high(RS485_DE);
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE);
.................... 	disable_interrupts(INT_RDA);
.................... }
.................... 
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
0BB8:  BTFSS  F9E.5
0BBA:  BRA    0BC0
.................... 		fgetc(MODBUS_SERIAL);
0BBC:  RCALL  03EA
0BBE:  BRA    0BB8
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0BC0:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0BC2:  BCF    F94.5
0BC4:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0BC6:  BSF    F9D.5
0BC8:  GOTO   0BCE (RETURN)
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init() {
.................... //	output_low(MODBUS_SERIAL_ENABLE_PIN);
.................... 
.................... 	RCV_ON();
0BCC:  BRA    0BB8
.................... 
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT);
0BCE:  MOVLW  C4
0BD0:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL);
0BD2:  MOVLW  C0
0BD4:  IORWF  FF2,F
0BD6:  GOTO   1332 (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable) {
.................... 	disable_interrupts(INT_TIMER0);
*
03A6:  BCF    FF2.5
.................... 	if (enable) {
03A8:  MOVLB  6
03AA:  MOVF   x46,F
03AC:  BZ    03B6
.................... 		set_timer0(0);
03AE:  CLRF   FD7
03B0:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0);
03B2:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0);
03B4:  BSF    FF2.5
.................... 	}
03B6:  MOVLB  0
03B8:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer0
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
03BA:  MOVF   xE3,W
03BC:  SUBLW  02
03BE:  BNZ   03D4
03C0:  MOVF   xE4,F
03C2:  BNZ   03D4
03C4:  MOVF   xE5,F
03C6:  BNZ   03D4
03C8:  BTFSC  xE2.0
03CA:  BRA    03D4
....................    {
....................       modbus_rx.len-=2;
03CC:  MOVLW  02
03CE:  SUBWF  xE7,F
....................       modbus_serial_new=TRUE;
03D0:  BSF    xE2.0
....................    }
03D2:  BRA    03D6
....................    else
....................       modbus_serial_new=FALSE;
03D4:  BCF    xE2.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
03D6:  SETF   xE5
03D8:  SETF   xE4
....................    modbus_serial_state=MODBUS_GETADDY;
03DA:  CLRF   xE3
....................    modbus_enable_timeout(FALSE);
03DC:  MOVLB  6
03DE:  CLRF   x46
03E0:  MOVLB  0
03E2:  RCALL  03A6
03E4:  BCF    FF2.2
03E6:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   unsigned int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
0400:  MOVF   xE5,W
0402:  MOVLB  6
0404:  XORWF  x46,W
0406:  MOVWF  x47
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0408:  CLRF   03
040A:  MOVF   x47,W
040C:  MOVLB  0
040E:  RCALL  00D2
0410:  MOVWF  01
0412:  MOVF   xE4,W
0414:  XORWF  01,W
0416:  MOVWF  xE5
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0418:  CLRF   03
041A:  MOVLB  6
041C:  MOVF   x47,W
041E:  MOVLB  0
0420:  RCALL  01E2
0422:  MOVWF  xE4
0424:  GOTO   0478 (RETURN)
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c) {
.................... 	
.................... 	fputc(c, MODBUS_SERIAL);
.................... 	modbus_calc_crc(c);
.................... 	/* one stop bit delay */
.................... 	delay_us(104);
.................... 
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #int_rda
.................... void incomming_modbus_serial() {
.................... 	int8 c;
.................... 
.................... 	c=fgetc(MODBUS_SERIAL);
0428:  RCALL  03EA
042A:  MOVFF  01,645
.................... 	if (!modbus_serial_new) {
042E:  BTFSC  xE2.0
0430:  BRA    0482
.................... 		if(modbus_serial_state == MODBUS_GETADDY) {
0432:  MOVF   xE3,F
0434:  BNZ   0446
.................... 			modbus_serial_crc.d = 0xFFFF;
0436:  SETF   xE5
0438:  SETF   xE4
.................... 			modbus_rx.address = c;
043A:  MOVFF  645,E6
.................... 			modbus_serial_state++;
043E:  INCF   xE3,F
.................... 			modbus_rx.len = 0;
0440:  CLRF   xE7
.................... 			modbus_rx.error=0;
0442:  CLRF   xE9
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) {
0444:  BRA    0472
0446:  DECFSZ xE3,W
0448:  BRA    0452
.................... 			modbus_rx.func = c;
044A:  MOVFF  645,E8
.................... 			modbus_serial_state++;
044E:  INCF   xE3,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) {
0450:  BRA    0472
0452:  MOVF   xE3,W
0454:  SUBLW  02
0456:  BNZ   0472
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {
0458:  INCFSZ xE7,W
045A:  BRA    0460
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;
045C:  MOVLW  FE
045E:  MOVWF  xE7
.................... 			}
.................... 			modbus_rx.data[modbus_rx.len]=c;
0460:  MOVLW  EA
0462:  ADDWF  xE7,W
0464:  MOVWF  FE9
0466:  CLRF   FEA
0468:  BTFSC  FD8.0
046A:  INCF   FEA,F
046C:  MOVFF  645,FEF
.................... 			modbus_rx.len++;
0470:  INCF   xE7,F
.................... 		}
.................... 
.................... 		modbus_calc_crc(c);
0472:  MOVFF  645,646
0476:  BRA    0400
.................... 		modbus_enable_timeout(TRUE);
0478:  MOVLW  01
047A:  MOVLB  6
047C:  MOVWF  x46
047E:  MOVLB  0
0480:  RCALL  03A6
.................... 	}
0482:  BCF    F9E.5
0484:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func) {
.................... 	modbus_serial_crc.d=0xFFFF;
.................... 	modbus_serial_new=FALSE;
.................... 
.................... 	rcv_off();
....................   
.................... 	// delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
.................... 	/* 3.5 character delay */
.................... 	delay_us(365);
.................... 
.................... 	modbus_serial_putc(to);
.................... 	modbus_serial_putc(func);
.................... }
.................... 
.................... void modbus_serial_send_stop() {
.................... 	int8 crc_low, crc_high;
.................... 
.................... 	crc_high=modbus_serial_crc.b[1];
.................... 	crc_low=modbus_serial_crc.b[0];
.................... 
.................... 	modbus_serial_putc(crc_high);
.................... 	modbus_serial_putc(crc_low);
.................... 
.................... 	/* wait for data to actually be sent */
.................... 	while ( ! TRMT );
....................     
.................... 	// delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
.................... 	delay_us(365);
.................... 	
.................... 	rcv_on();
.................... 
.................... 	modbus_serial_crc.d=0xFFFF;
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
....................       return FALSE;
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
....................       modbus_rx.len = 1;
....................    }
....................    modbus_serial_new=FALSE;
....................    return TRUE;
.................... }
.................... 
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... 
.................... #include "modbus_handler_dcswcI2C.c"
.................... #define MAX_COIL_REGISTER   4
.................... 
.................... #define MAX_STATUS_REGISTER 27
.................... #define MIN_CONFIG_REGISTER 1000
.................... #define MAX_CONFIG_REGISTER 1088
.................... 
.................... 
.................... void reset_modbus_stats(void) {
.................... 	current.modbus_our_packets=0;
.................... 	current.modbus_other_packets=0;
.................... 	current.modbus_last_error=0;
.................... }
.................... 
.................... 
.................... int16 map_modbus(int16 addr) {
.................... 	int16 l;
.................... 	int8 ch;
.................... 
.................... 	/* channel config registers */
.................... 	if ( addr >= 1008 && addr <= 1088 ) {
.................... 		/* subtract offset */
.................... 		addr = (addr-1008);
.................... 		/* mod 16 (block size) for channel */
.................... 		ch = ((int8) addr)>>4;
.................... 		/* low nibble is the address */
.................... 		addr = ((int8) addr) & 0x0f;
.................... 
.................... 		switch ( addr ) {
.................... 			case 0: return config.ch[ch].startup;
.................... 			case 1: return config.ch[ch].off_below_adc;
.................... 			case 2: return config.ch[ch].off_below_delay;
.................... 			case 3: return config.ch[ch].on_above_adc;
.................... 			case 4: return config.ch[ch].on_above_delay;
.................... 			case 5: return config.ch[ch].override_timeout;
.................... 			case 6: return config.ch[ch].switch_type;
.................... 			case 7: return config.ch[ch].i_mon_offset;
.................... 			case 8: return config.ch[ch].adc_channel;
.................... 			case 9: return config.ch[ch].invert;
.................... 		}
.................... 
.................... 		/* if reserved space then return all bits set */
.................... 		return 0xffff;		
.................... 	}
.................... 
.................... 	switch ( addr ) {
.................... 		case  0: return current.p_on[0];
.................... 		case  1: return current.p_on[1];
.................... 		case  2: return current.p_on[2];
.................... 		case  3: return current.p_on[3];
.................... 		case  4: return current.p_on[4];
.................... 
.................... 		case  5: // 0 
.................... 		case  6: // 1
.................... 		case  7: // 2
.................... 		case  8: // 3
.................... 		case  9: // 4
.................... 		case 10: // 5
.................... 		case 11: // 6
.................... 		case 12: // 7
.................... 		case 13: // 8
.................... 		case 14: // 9
.................... 		case 15: // 10
.................... 		case 16: // 11
.................... 		case 17: // 12
.................... 		case 18: // 13
.................... 		case 19: // 14
.................... 		case 20: // 15
.................... 				return current.adc[(int8) addr - 5];
.................... 
.................... 
.................... 		/* meta status */
.................... 		case 21: return current.sequence_number++;
.................... 		case 22: /* milliseconds since last query */
.................... 			l=current.interval_milliseconds;
.................... 			current.interval_milliseconds=0;
.................... 			return l; 
.................... 		case 23: return current.uptime_minutes; /* uptime  */
.................... 		/* modbus statistics */
.................... 		case 24: return current.modbus_our_packets;
.................... 		case 25: return current.modbus_other_packets;
.................... 		case 26: return current.modbus_last_error;
.................... 		/* 27 triggers a modbus statistics reset */
.................... 		case 27: reset_modbus_stats(); return 0;
.................... 
.................... 		/* configuration */
.................... 		case 1000: return config.serial_prefix;
.................... 		case 1001: return config.serial_number;
.................... 		case 1002: return 'D';
.................... 		case 1003: return 'C';
.................... 		case 1004: return 'S';
.................... 		case 1005: return 2;
.................... 		case 1006: return config.modbus_address;
.................... 		case 1007: return config.modbus_mode;
.................... 
.................... 		/* channel config blocks are handled above */
.................... 		/* case 1008 ... case 1088 */
.................... 
.................... 
.................... 
.................... 		/* we should have range checked, and never gotten here */
.................... 		default: return 65535;
.................... 	}
.................... 
.................... }
.................... 
.................... int8 modbus_valid_read_registers(int16 start, int16 end) {
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 )
.................... 		return 1;
.................... 	
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */
.................... 	if ( end <= MAX_STATUS_REGISTER+1)
.................... 		return 1;
.................... 
.................... 	return 0;
.................... }
.................... 
.................... void modbus_read_register_response(int8 function, int8 address, int16 start_address, int16 register_count ) {
.................... 	int16 i;
.................... 	int16 l;
.................... 
.................... //	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 	modbus_serial_send_start(address, function);
.................... 	modbus_serial_putc(register_count*2);
.................... 
.................... 
.................... 	for( i=0 ; i<register_count ; i++ ) {
.................... 		l=map_modbus(start_address+i);
.................... 		modbus_serial_putc(make8(l,1));
....................   		modbus_serial_putc(make8(l,0));
.................... 	}
.................... 
.................... 	modbus_serial_send_stop();
.................... }
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception modbus_write_register(int16 address, int16 value) {
.................... 	int8 ch;
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( current.factory_unlocked ) {
.................... 		if ( 1000 == address ) {
.................... 			config.serial_prefix=value;
.................... 			return 0;
.................... 		} else if ( 1001 == address ) {
.................... 			config.serial_number=value;
.................... 			return 0;
.................... 		}
.................... 	}
.................... 	if ( address >= 1008 && address <= 1088 ) {
.................... 		/* subtract offset */
.................... 		address = (address-1008);
.................... 		/* mod 16 (block size) for channel */
.................... 		ch = ((int8) address)>>4;
.................... 		/* low nibble is the address */
.................... 		address = ((int8) address) & 0x0f;
.................... 
.................... 		switch ( address ) {
.................... 			/* 1008, 1024, 1040, 1056, 1072 */
.................... 			case 0: 
.................... 				if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].startup=(int8) value;
.................... 				break;
.................... 
.................... 			/* 1009, 1025, 1041, 1057, 1073 */
.................... 			case 1: 
.................... 				if ( value > 4096 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].off_below_adc=value;
.................... 				break;
.................... 
.................... 			/* 1010, 1026, 1042, 1058, 1074 */
.................... 			case 2: 
.................... 				config.ch[ch].off_below_delay=value;
.................... 				break;
.................... 
.................... 			/* 1011, 1027, 1043, 1059, 1075 */
.................... 			case 3: 
.................... 				if ( value > 4096 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].on_above_adc=value;
.................... 				break;
.................... 
.................... 			/* 1012, 1028, 1044, 1060, 1076 */
.................... 			case 4: 
.................... 				config.ch[ch].on_above_delay=value;
.................... 				break;
.................... 
.................... 			/* 1013, 1029, 1045, 1061, 1077 */
.................... 			case 5: 
.................... 				config.ch[ch].override_timeout=value;
.................... 				break;
.................... 
.................... 			/* 1014, 1030, 1046, 1062, 1078 */
.................... 			case 6: 
.................... 				config.ch[ch].switch_type=value;
.................... 				break;
.................... 
.................... 			/* 1015, 1031, 1047, 1063, 1079 */
.................... 			case 7: 
.................... 				if ( value > 255 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].i_mon_offset=(signed int8) value;
.................... 				break;
.................... 
.................... 			/* 1016, 1032, 1048, 1064, 1080 */
.................... 			case 8: 
.................... 				if ( value > 16 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].adc_channel=(int8) value;
.................... 				break;
.................... 
.................... 			/* 1017, 1033, 1049, 1065, 1081 */
.................... 			case 9: 
.................... 				if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].invert=(int8) value;
.................... 				break;
.................... 		}
.................... 
.................... 		/* no exception */
.................... 		return 0;		
.................... 	}
.................... 
.................... 
.................... 	/* publicly writeable addresses */
.................... 	switch ( address ) {
.................... 		case 0:
.................... 		case 1:
.................... 		case 2:
.................... 		case 3:
.................... 		case 4:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			current.p_on[(int8) address]=value;
.................... 			/* set counter that will be decremented in decision loop */
.................... 			current.override_timeout[(int8) address]=config.ch[(int8) address].override_timeout;
.................... 			break;
.................... 
.................... 		case 1006:
.................... 			/* Modbus address {0 to 127} */
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE;
.................... 			config.modbus_address=value;
.................... 			break;
.................... 		case 1007:
.................... 			/* Modbus mode {0,1} */
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.modbus_mode=value;
.................... 			break;
.................... 
.................... 
.................... #if 0
.................... 		/* inital state of the outputs */
.................... 		case 1008:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[0]=value;
.................... 			break;
.................... 		case 1009:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[1]=value;
.................... 			break;
.................... 		case 1010:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[2]=value;
.................... 			break;
.................... 		case 1011:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[3]=value;
.................... 			break;
.................... 		case 1012:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[4]=value;
.................... 			break;
.................... #endif
.................... 
.................... 
.................... 		/* control */
.................... 		case 1997:
.................... 			/* reset now, won't acknowledge */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			reset_cpu();
.................... 			break;
.................... 		case 1998:
.................... 			/* write default config to EEPROM */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			write_default_param_file();
.................... 			break;
.................... 		case 1999:
.................... 			/* write config to EEPROM */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			write_param_file();
.................... 			break;
.................... 		case 19999:
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */
.................... 			if ( 1802 != value ) {
.................... 				current.factory_unlocked=0;
.................... 				return ILLEGAL_DATA_VALUE;
.................... 			}
.................... 			current.factory_unlocked=1;
.................... 			/* green LED for 2 seconds */
.................... 			timers.led_on_green=200;
.................... 			timers.led_on_red=0;
.................... 			break;
.................... 		default:
.................... 			return ILLEGAL_DATA_ADDRESS;
.................... 
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
.................... }
.................... 
.................... void modbus_process(void) {
.................... 	int16 start_addr;
.................... 	int16 num_registers;
.................... 	exception result;
.................... 	int8 i;
.................... 
.................... 
.................... 	/* check for message */
.................... 	if ( modbus_kbhit() ) {
.................... 		/* check if it is addressed to us */
.................... 		if ( modbus_rx.address==config.modbus_address ) {
.................... 			/* Modbus statistics */
.................... 			if ( current.modbus_our_packets < 65535 )
.................... 				current.modbus_our_packets++;
.................... 	
.................... 			/* green LED for 200 milliseconds */
.................... 			timers.led_on_green=20;
.................... 			timers.led_on_red=0;
.................... 
.................... 			switch(modbus_rx.func) {
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]);
.................... 	
.................... 					/* make sure our address is within range */
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					} else {
.................... 						modbus_read_register_response(modbus_rx.func,config.modbus_address,start_addr,num_registers);
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_SINGLE_COIL: /* 5 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 
.................... 					if ( start_addr <= MAX_COIL_REGISTER && modbus_rx.data[2]==0xFF && modbus_rx.data[3]==0x00 ) {
.................... 						/* turn on */
.................... 						modbus_write_register(start_addr, 1);
.................... 					} else if ( start_addr <= MAX_COIL_REGISTER && modbus_rx.data[2]==0x00 && modbus_rx.data[3]==0x00 ) {
.................... 						/* turn off */
.................... 						modbus_write_register(start_addr, 0);
.................... 					} else if ( start_addr > MAX_COIL_REGISTER ) {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					} else {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_VALUE);
.................... 						current.modbus_last_error=ILLEGAL_DATA_VALUE;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 
.................... 					/* try the write */
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3]));
.................... 
.................... 					if ( result ) {
.................... 						/* exception */
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result);
.................... 						current.modbus_last_error=result;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					}  else {
.................... 						/* no exception, send ack */
.................... 						modbus_write_single_register_rsp(config.modbus_address,
.................... 							start_addr,
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3])
.................... 						);
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]);
.................... 
.................... 					/* attempt to write each register. Stop if exception */
.................... 					for ( i=0 ; i<num_registers ; i++ ) {
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2]));
.................... 
.................... 						if ( result ) {
.................... 							/* exception */
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result);
.................... 							current.modbus_last_error=result;
.................... 	
.................... 							/* red LED for 1 second */
.................... 							timers.led_on_red=100;
.................... 							timers.led_on_green=0;
.................... 			
.................... 							break;
.................... 						}
.................... 					}
.................... 		
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */
.................... 					if ( 0 == result ) {
.................... 						/* no exception, send ack */
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers);
.................... 					}
.................... 
.................... 					break;  
.................... 				default:
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION);
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION;
.................... 
.................... 					/* red led for 1 second */
.................... 					timers.led_on_red=100;
.................... 					timers.led_on_green=0;
.................... 			}
.................... 		} else {
.................... 			/* MODBUS packet for somebody else */
.................... 			if ( current.modbus_other_packets < 65535 )
.................... 				current.modbus_other_packets++;
.................... 
.................... 			/* yellow LED 200 milliseconds */
.................... 			timers.led_on_green=20;
.................... 			timers.led_on_red=20;
.................... 		}
.................... 	}
.................... }
.................... 
.................... 
.................... #include "filter_dcswcI2C.c"
.................... #define MEAN_FILTER_WIDTH    16
.................... #define MEAN_FILTER_CHANNELS 16
.................... 
.................... int16 mean_filter_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	static int8 num_elements[MEAN_FILTER_CHANNELS];
.................... 	int32 mean;
.................... 	int32 sum;
.................... 	int8 i;
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index[ch]] = latest_element;
*
0D68:  MOVLB  6
0D6A:  CLRF   x32
0D6C:  MOVFF  625,631
0D70:  CLRF   x34
0D72:  MOVLW  20
0D74:  MOVWF  x33
0D76:  MOVLB  0
0D78:  RCALL  0CB0
0D7A:  MOVFF  02,632
0D7E:  MOVFF  01,631
0D82:  CLRF   03
0D84:  MOVLB  6
0D86:  MOVF   x25,W
0D88:  ADDLW  E9
0D8A:  MOVWF  FE9
0D8C:  MOVLW  03
0D8E:  ADDWFC 03,W
0D90:  MOVWF  FEA
0D92:  CLRF   03
0D94:  MOVFF  FEF,02
0D98:  BCF    FD8.0
0D9A:  RLCF   02,F
0D9C:  RLCF   03,F
0D9E:  MOVF   02,W
0DA0:  ADDWF  01,W
0DA2:  MOVWF  01
0DA4:  MOVF   x32,W
0DA6:  ADDWFC 03,F
0DA8:  MOVF   01,W
0DAA:  ADDLW  E9
0DAC:  MOVWF  FE9
0DAE:  MOVLW  01
0DB0:  ADDWFC 03,W
0DB2:  MOVWF  FEA
0DB4:  MOVFF  627,FEC
0DB8:  MOVF   FED,F
0DBA:  MOVFF  626,FEF
.................... 	inbuf_index[ch]++;
0DBE:  CLRF   03
0DC0:  MOVF   x25,W
0DC2:  ADDLW  E9
0DC4:  MOVWF  FE9
0DC6:  MOVLW  03
0DC8:  ADDWFC 03,W
0DCA:  MOVWF  FEA
0DCC:  INCF   FEF,F
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
0DCE:  CLRF   03
0DD0:  MOVF   x25,W
0DD2:  ADDLW  E9
0DD4:  MOVWF  FE9
0DD6:  MOVLW  03
0DD8:  ADDWFC 03,W
0DDA:  MOVWF  FEA
0DDC:  MOVF   FEF,W
0DDE:  SUBLW  0F
0DE0:  BC    0DF2
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
0DE2:  CLRF   03
0DE4:  MOVF   x25,W
0DE6:  ADDLW  E9
0DE8:  MOVWF  FE9
0DEA:  MOVLW  03
0DEC:  ADDWFC 03,W
0DEE:  MOVWF  FEA
0DF0:  CLRF   FEF
.................... 
.................... 	if(num_elements[ch] < MEAN_FILTER_WIDTH)
0DF2:  CLRF   03
0DF4:  MOVF   x25,W
0DF6:  ADDLW  F9
0DF8:  MOVWF  FE9
0DFA:  MOVLW  03
0DFC:  ADDWFC 03,W
0DFE:  MOVWF  FEA
0E00:  MOVF   FEF,W
0E02:  SUBLW  0F
0E04:  BNC   0E16
.................... 	   num_elements[ch]++;
0E06:  CLRF   03
0E08:  MOVF   x25,W
0E0A:  ADDLW  F9
0E0C:  MOVWF  FE9
0E0E:  MOVLW  03
0E10:  ADDWFC 03,W
0E12:  MOVWF  FEA
0E14:  INCF   FEF,F
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
0E16:  CLRF   x2F
0E18:  CLRF   x2E
0E1A:  CLRF   x2D
0E1C:  CLRF   x2C
.................... 	for(i = 0; i < num_elements[ch]; i++)
0E1E:  CLRF   x30
0E20:  CLRF   03
0E22:  MOVF   x25,W
0E24:  ADDLW  F9
0E26:  MOVWF  FE9
0E28:  MOVLW  03
0E2A:  ADDWFC 03,W
0E2C:  MOVWF  FEA
0E2E:  MOVF   FEF,W
0E30:  SUBWF  x30,W
0E32:  BC    0E88
.................... 		sum += input_buffer[ch][i];
0E34:  CLRF   x32
0E36:  MOVFF  625,631
0E3A:  CLRF   x34
0E3C:  MOVLW  20
0E3E:  MOVWF  x33
0E40:  MOVLB  0
0E42:  RCALL  0CB0
0E44:  MOVFF  02,632
0E48:  MOVFF  01,631
0E4C:  CLRF   03
0E4E:  MOVLB  6
0E50:  MOVFF  630,02
0E54:  BCF    FD8.0
0E56:  RLCF   02,F
0E58:  RLCF   03,F
0E5A:  MOVF   02,W
0E5C:  ADDWF  01,W
0E5E:  MOVWF  01
0E60:  MOVF   x32,W
0E62:  ADDWFC 03,F
0E64:  MOVF   01,W
0E66:  ADDLW  E9
0E68:  MOVWF  FE9
0E6A:  MOVLW  01
0E6C:  ADDWFC 03,W
0E6E:  MOVWF  FEA
0E70:  MOVFF  FEC,03
0E74:  MOVF   FED,F
0E76:  MOVF   FEF,W
0E78:  ADDWF  x2C,F
0E7A:  MOVF   03,W
0E7C:  ADDWFC x2D,F
0E7E:  MOVLW  00
0E80:  ADDWFC x2E,F
0E82:  ADDWFC x2F,F
0E84:  INCF   x30,F
0E86:  BRA    0E20
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... 	mean = (sum + (int32)(num_elements[ch] >> 1)) / num_elements[ch];
0E88:  CLRF   03
0E8A:  MOVF   x25,W
0E8C:  ADDLW  F9
0E8E:  MOVWF  FE9
0E90:  MOVLW  03
0E92:  ADDWFC 03,W
0E94:  MOVWF  FEA
0E96:  MOVFF  FEF,631
0E9A:  BCF    FD8.0
0E9C:  RRCF   x31,W
0E9E:  MOVWF  00
0EA0:  CLRF   01
0EA2:  CLRF   02
0EA4:  CLRF   03
0EA6:  MOVF   00,W
0EA8:  ADDWF  x2C,W
0EAA:  MOVWF  x31
0EAC:  MOVF   01,W
0EAE:  ADDWFC x2D,W
0EB0:  MOVWF  x32
0EB2:  MOVF   02,W
0EB4:  ADDWFC x2E,W
0EB6:  MOVWF  x33
0EB8:  MOVF   03,W
0EBA:  ADDWFC x2F,W
0EBC:  MOVWF  x34
0EBE:  CLRF   03
0EC0:  MOVF   x25,W
0EC2:  ADDLW  F9
0EC4:  MOVWF  FE9
0EC6:  MOVLW  03
0EC8:  ADDWFC 03,W
0ECA:  MOVWF  FEA
0ECC:  MOVFF  FEF,63C
0ED0:  MOVFF  FEA,637
0ED4:  MOVFF  FE9,636
0ED8:  BCF    FD8.1
0EDA:  MOVFF  634,63B
0EDE:  MOVFF  633,63A
0EE2:  MOVFF  632,639
0EE6:  MOVFF  631,638
0EEA:  CLRF   x3F
0EEC:  CLRF   x3E
0EEE:  CLRF   x3D
0EF0:  MOVLB  0
0EF2:  BRA    0CD2
0EF4:  MOVFF  637,FEA
0EF8:  MOVFF  636,FE9
0EFC:  MOVFF  03,62B
0F00:  MOVFF  02,62A
0F04:  MOVFF  01,629
0F08:  MOVFF  00,628
.................... 
.................... 	return((int16)mean);
0F0C:  MOVLB  6
0F0E:  MOVFF  628,01
0F12:  MOVFF  629,02
0F16:  MOVLB  0
0F18:  GOTO   139A (RETURN)
.................... }
.................... 
.................... /* 
.................... special case of mean filter. For a 16 element filter, max value of 4096, and equal
.................... number of samples for each channel. Filter result doesn't become valid until at least
.................... 16 samples have been added
.................... */
.................... int16 mean_filter16_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	int16 sum;
.................... 	int16 min, max;
.................... 	int8 i;
.................... 
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index] = latest_element;
.................... 	inbuf_index[ch]++;
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	min=65535;
.................... 	max=0;
.................... 	sum = 0;
.................... 	for( i = 0; i < MEAN_FILTER_WIDTH ; i++ ) {
.................... 		sum += input_buffer[ch][i];
.................... 
.................... 		if ( input_buffer[ch][i] > max )
.................... 			max=input_buffer[ch][i];
.................... 		if ( input_buffer[ch][i] < min )
.................... 			min=input_buffer[ch][i];
.................... 	}
.................... 
.................... 	/* throw out the highest and lowest values */
.................... 	sum -= max;
.................... 	sum -= min;
.................... 
.................... 	return ( (sum+7) / 14 );
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... //	return ( (sum+8) >> 4 );
.................... }
.................... 
.................... 
.................... 
.................... void init() {
.................... 	int8 i;
.................... 
.................... 	setup_oscillator(OSC_8MHZ || OSC_INTRC); 
*
0672:  MOVLW  60
0674:  MOVWF  FD3
0676:  CLRF   F9B
0678:  CLRF   F64
.................... //	setup_adc(ADC_CLOCK_INTERNAL);
.................... 	setup_adc_ports(NO_ANALOGS);
067A:  MOVLB  F
067C:  MOVF   x5C,W
067E:  ANDLW  80
0680:  MOVWF  x5C
0682:  MOVLW  00
0684:  MOVWF  x5D
0686:  BCF    FC1.3
0688:  BCF    FC1.4
068A:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
068C:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
068E:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
0690:  MOVLW  1F
0692:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
0694:  MOVLW  F0
0696:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
0698:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
069A:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
069C:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
069E:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
06A0:  BCF    F94.5
06A2:  BCF    F8B.5
.................... 
.................... 	/* data structure initialization */
.................... 	timers.led_on_green=0;
06A4:  MOVLB  0
06A6:  CLRF   xDB
.................... 	timers.led_on_red=0;
06A8:  CLRF   xDC
.................... 
.................... 	current.modbus_our_packets=0;
06AA:  CLRF   x89
06AC:  CLRF   x88
.................... 	current.modbus_other_packets=0;
06AE:  CLRF   x8B
06B0:  CLRF   x8A
.................... 	current.modbus_last_error=0;
06B2:  CLRF   x8D
06B4:  CLRF   x8C
.................... 	current.sequence_number=0;
06B6:  CLRF   x8F
06B8:  CLRF   x8E
.................... 	current.uptime_minutes=0;
06BA:  CLRF   x91
06BC:  CLRF   x90
.................... 	current.interval_milliseconds=0;
06BE:  CLRF   x93
06C0:  CLRF   x92
.................... 	current.factory_unlocked=0;
06C2:  CLRF   x94
.................... 	current.restart_now=0;
06C4:  CLRF   xD9
.................... 
.................... 	for ( i=0 ; i<5 ; i++ ) {
06C6:  MOVLB  6
06C8:  CLRF   x21
06CA:  MOVF   x21,W
06CC:  SUBLW  04
06CE:  BNC   07A2
.................... 		current.on_delay[i]=config.ch[i].on_above_delay;
06D0:  BCF    FD8.0
06D2:  RLCF   x21,W
06D4:  CLRF   03
06D6:  ADDLW  BA
06D8:  MOVWF  01
06DA:  MOVLW  00
06DC:  ADDWFC 03,F
06DE:  MOVFF  01,622
06E2:  MOVFF  03,623
06E6:  MOVF   x21,W
06E8:  MULLW  10
06EA:  MOVF   FF3,W
06EC:  CLRF   03
06EE:  ADDLW  06
06F0:  MOVWF  x24
06F2:  MOVLW  00
06F4:  ADDWFC 03,W
06F6:  MOVWF  x25
06F8:  MOVLW  07
06FA:  ADDWF  x24,W
06FC:  MOVWF  01
06FE:  MOVLW  00
0700:  ADDWFC x25,W
0702:  MOVWF  03
0704:  MOVF   01,W
0706:  ADDLW  21
0708:  MOVWF  FE9
070A:  MOVLW  00
070C:  ADDWFC 03,W
070E:  MOVWF  FEA
0710:  MOVFF  FEC,03
0714:  MOVF   FED,F
0716:  MOVFF  FEF,624
071A:  MOVFF  623,FEA
071E:  MOVFF  622,FE9
0722:  MOVFF  03,FEC
0726:  MOVF   FED,F
0728:  MOVFF  624,FEF
.................... 		current.off_delay[i]=config.ch[i].off_below_delay;
072C:  BCF    FD8.0
072E:  RLCF   x21,W
0730:  CLRF   03
0732:  ADDLW  C4
0734:  MOVWF  01
0736:  MOVLW  00
0738:  ADDWFC 03,F
073A:  MOVFF  01,622
073E:  MOVFF  03,623
0742:  MOVF   x21,W
0744:  MULLW  10
0746:  MOVF   FF3,W
0748:  CLRF   03
074A:  ADDLW  06
074C:  MOVWF  x24
074E:  MOVLW  00
0750:  ADDWFC 03,W
0752:  MOVWF  x25
0754:  MOVLW  03
0756:  ADDWF  x24,W
0758:  MOVWF  01
075A:  MOVLW  00
075C:  ADDWFC x25,W
075E:  MOVWF  03
0760:  MOVF   01,W
0762:  ADDLW  21
0764:  MOVWF  FE9
0766:  MOVLW  00
0768:  ADDWFC 03,W
076A:  MOVWF  FEA
076C:  MOVFF  FEC,03
0770:  MOVF   FED,F
0772:  MOVFF  FEF,624
0776:  MOVFF  623,FEA
077A:  MOVFF  622,FE9
077E:  MOVFF  03,FEC
0782:  MOVF   FED,F
0784:  MOVFF  624,FEF
.................... 		current.override_timeout[i]=0;
0788:  BCF    FD8.0
078A:  RLCF   x21,W
078C:  CLRF   03
078E:  ADDLW  CE
0790:  MOVWF  FE9
0792:  MOVLW  00
0794:  ADDWFC 03,W
0796:  MOVWF  FEA
0798:  CLRF   FEC
079A:  MOVF   FED,F
079C:  CLRF   FEF
079E:  INCF   x21,F
07A0:  BRA    06CA
.................... 	}
.................... 
.................... 
.................... 
.................... 	/* interrupts */
.................... 	/* timer0 - Modbus slave timeout timer */
.................... 	/* configured in modbus_slave_sdc.c */
.................... 
.................... 	/* timer1 - unused */
.................... 
.................... 	/* timer2 - unused */
.................... 
.................... 	/* timer3 - general housekeeping Prescaler=1:1; TMR1 Preset=45536; Freq=100.00Hz; Period=10.00 ms */
.................... 	setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);
07A2:  CLRF   FB0
07A4:  MOVLW  07
07A6:  MOVWF  FB1
.................... 	set_timer3(45536);
07A8:  MOVLW  B1
07AA:  MOVWF  FB3
07AC:  MOVLW  E0
07AE:  MOVWF  FB2
.................... 	enable_interrupts(INT_TIMER3);
07B0:  BSF    FA0.1
.................... 
.................... 	/* timer4 - unused */
.................... 
.................... 	/* FTDI serial cable receive character */
.................... 	enable_interrupts(INT_RDA2);
07B2:  BSF    FA3.5
.................... 
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
07B4:  MOVLB  0
07B6:  RCALL  056E
.................... 
.................... 
.................... 	/* initialize SCI UART @ 19200 */
.................... 	uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
07B8:  MOVLW  06
07BA:  MOVLB  6
07BC:  MOVWF  x22
07BE:  MOVLB  0
07C0:  BRA    05D4
.................... 
.................... 
.................... 	delay_ms(14);
07C2:  MOVLW  0E
07C4:  MOVLB  6
07C6:  MOVWF  x22
07C8:  MOVLB  0
07CA:  BRA    0640
07CC:  GOTO   131E (RETURN)
.................... 
.................... }
.................... 
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start();
*
10C8:  BSF    FC5.0
10CA:  BTFSC  FC5.0
10CC:  BRA    10CA
.................... 	status = i2c_write(address);  // Status = 0 if got an ACK
10CE:  MOVFF  621,626
10D2:  CALL   0578
10D6:  MOVFF  01,622
.................... 	i2c_stop();
10DA:  BSF    FC5.2
10DC:  BTFSC  FC5.2
10DE:  BRA    10DC
.................... 
.................... 	if ( 0 == status )
10E0:  MOVLB  6
10E2:  MOVF   x22,F
10E4:  BNZ   10EC
.................... 		return TRUE;
10E6:  MOVLW  01
10E8:  MOVWF  01
10EA:  BRA    10F0
.................... 
....................    return FALSE;
10EC:  MOVLW  00
10EE:  MOVWF  01
10F0:  MOVLB  0
10F2:  RETURN 0
.................... }
.................... 
.................... void main(void) {
*
1258:  CLRF   FF8
125A:  BCF    FD0.7
125C:  BSF    07.7
125E:  MOVLW  62
1260:  MOVWF  FD3
1262:  CLRF   F9B
1264:  CLRF   F64
1266:  CLRF   20
1268:  BCF    FA7.3
126A:  MOVLW  0C
126C:  MOVWF  FAF
126E:  MOVLW  A2
1270:  MOVWF  FAC
1272:  MOVLW  90
1274:  MOVWF  FAB
1276:  BSF    FB9.3
1278:  MOVLW  22
127A:  MOVWF  F7B
127C:  MOVLW  00
127E:  MOVWF  F7C
1280:  MOVLW  A6
1282:  MOVWF  FBA
1284:  MOVLW  90
1286:  MOVWF  FA6
1288:  BSF    F94.3
128A:  BSF    F94.4
128C:  MOVLW  04
128E:  MOVWF  FC8
1290:  MOVLW  28
1292:  MOVWF  FC6
1294:  BCF    FC7.7
1296:  BCF    FC7.6
1298:  BCF    xE2.0
129A:  CLRF   xE3
129C:  MOVLB  6
129E:  CLRF   x1A
12A0:  CLRF   x19
12A2:  MOVLB  F
12A4:  MOVF   x5C,W
12A6:  ANDLW  80
12A8:  MOVWF  x5C
12AA:  MOVLW  00
12AC:  MOVWF  x5D
12AE:  BCF    FC1.3
12B0:  BCF    FC1.4
12B2:  BCF    FC1.5
12B4:  CLRF   x5E
12B6:  CLRF   x5F
12B8:  BRA    12D4
12BA:  DATA 02,00
12BC:  DATA 1A,00
12BE:  DATA 00,C1
12C0:  DATA 40,21
12C2:  DATA 00,FF
12C4:  DATA 41,E9
12C6:  DATA 00,FF
12C8:  DATA C0,00
12CA:  DATA FF,C0
12CC:  DATA 00,FF
12CE:  DATA C0,00
12D0:  DATA 34,C0
12D2:  DATA 00,00
12D4:  MOVLW  00
12D6:  MOVWF  FF8
12D8:  MOVLW  12
12DA:  MOVWF  FF7
12DC:  MOVLW  BA
12DE:  MOVWF  FF6
12E0:  TBLRD*+
12E2:  MOVF   FF5,W
12E4:  MOVWF  00
12E6:  XORLW  00
12E8:  BZ    1310
12EA:  TBLRD*+
12EC:  MOVF   FF5,W
12EE:  MOVWF  01
12F0:  BTFSC  FE8.7
12F2:  BRA    12FE
12F4:  ANDLW  3F
12F6:  MOVWF  FEA
12F8:  TBLRD*+
12FA:  MOVFF  FF5,FE9
12FE:  BTFSC  01.6
1300:  TBLRD*+
1302:  BTFSS  01.6
1304:  TBLRD*+
1306:  MOVFF  FF5,FEE
130A:  DCFSNZ 00,F
130C:  BRA    12E0
130E:  BRA    1302
1310:  CLRF   FF8
1312:  MOVLB  6
1314:  CLRF   x20
1316:  CLRF   x1F
.................... 	int8 i,j;
.................... 	int16 l;
.................... 	int16 n=0;
.................... 
.................... 	init();
1318:  MOVLB  0
131A:  GOTO   0672
.................... 	read_param_file();
131E:  BRA    0B64
.................... 
.................... 	if ( config.modbus_address > 127 ) {
1320:  MOVF   22,W
1322:  SUBLW  7F
1324:  BC    132A
.................... 		write_default_param_file();
1326:  CALL   0948
.................... 	}
.................... 
.................... 	/* start out Modbus slave */
.................... 	setup_uart(TRUE);
132A:  BSF    FAB.7
132C:  BSF    FAB.4
132E:  BSF    FAC.5
.................... 	/* modbus_init turns on global interrupts */
.................... 	modbus_init();
1330:  BRA    0BCC
.................... 	/* modbus initializes @ 9600 */
.................... 
.................... 	/* prime filters */
.................... 	for ( i=0 ; i<20 ; i++ ) {
1332:  MOVLB  6
1334:  CLRF   x1B
1336:  MOVF   x1B,W
1338:  SUBLW  13
133A:  BNC   13B6
.................... 		for ( j=0 ; j<16 ; j++ ) {
133C:  CLRF   x1C
133E:  MOVF   x1C,W
1340:  SUBLW  0F
1342:  BNC   13B2
.................... 			current.adc[j]=mean_filter_n(j,mcp3208_read(j) + config.adc_offset[j]);
1344:  BCF    FD8.0
1346:  RLCF   x1C,W
1348:  CLRF   03
134A:  ADDLW  9A
134C:  MOVWF  01
134E:  MOVLW  00
1350:  ADDWFC 03,F
1352:  MOVFF  01,621
1356:  MOVFF  03,622
135A:  MOVFF  61C,623
135E:  MOVLB  0
1360:  BRA    0BDA
1362:  MOVFF  02,624
1366:  MOVFF  01,623
136A:  CLRF   03
136C:  MOVLB  6
136E:  MOVF   x1C,W
1370:  ADDLW  77
1372:  MOVWF  FE9
1374:  MOVLW  00
1376:  ADDWFC 03,W
1378:  MOVWF  FEA
137A:  MOVF   FEF,W
137C:  CLRF   03
137E:  MOVWF  00
1380:  BTFSC  FE8.7
1382:  DECF   03,F
1384:  ADDWF  x23,F
1386:  MOVF   03,W
1388:  ADDWFC x24,F
138A:  MOVFF  61C,625
138E:  MOVFF  624,627
1392:  MOVFF  623,626
1396:  MOVLB  0
1398:  BRA    0D68
139A:  MOVFF  622,FEA
139E:  MOVFF  621,FE9
13A2:  MOVFF  02,FEC
13A6:  MOVF   FED,F
13A8:  MOVFF  01,FEF
13AC:  MOVLB  6
13AE:  INCF   x1C,F
13B0:  BRA    133E
.................... 		}
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... #if 1
13B2:  INCF   x1B,F
13B4:  BRA    1336
.................... 	fprintf(STREAM_WORLD,"# dcswcI2C (%c%lu) start up (ds30 bootloader support) (worldData stream) (modbus address=%u) %s\r\n",
.................... 		config.serial_prefix,
.................... 		config.serial_number,
.................... 		config.modbus_address,
.................... 		__DATE__
.................... 	);
13B6:  MOVLW  88
13B8:  MOVWF  FF6
13BA:  MOVLW  04
13BC:  MOVWF  FF7
13BE:  MOVLW  0C
13C0:  MOVWF  x22
13C2:  MOVLB  0
13C4:  RCALL  0F1C
13C6:  MOVF   24,W
13C8:  BTFSS  FA4.4
13CA:  BRA    13C8
13CC:  MOVWF  F79
13CE:  MOVLW  10
13D0:  MOVWF  FE9
13D2:  MOVFF  26,622
13D6:  MOVFF  25,621
13DA:  RCALL  0F46
13DC:  MOVLW  99
13DE:  MOVWF  FF6
13E0:  MOVLW  04
13E2:  MOVWF  FF7
13E4:  MOVLW  48
13E6:  MOVLB  6
13E8:  MOVWF  x22
13EA:  MOVLB  0
13EC:  RCALL  0F1C
13EE:  MOVFF  22,621
13F2:  MOVLW  1B
13F4:  MOVLB  6
13F6:  MOVWF  x22
13F8:  MOVLB  0
13FA:  BRA    1026
13FC:  MOVLW  29
13FE:  BTFSS  FA4.4
1400:  BRA    13FE
1402:  MOVWF  F79
1404:  MOVLW  20
1406:  BTFSS  FA4.4
1408:  BRA    1406
140A:  MOVWF  F79
140C:  MOVLW  EA
140E:  MOVWF  FF6
1410:  MOVLW  04
1412:  MOVWF  FF7
1414:  RCALL  10A6
1416:  MOVLW  0D
1418:  BTFSS  FA4.4
141A:  BRA    1418
141C:  MOVWF  F79
141E:  MOVLW  0A
1420:  BTFSS  FA4.4
1422:  BRA    1420
1424:  MOVWF  F79
.................... #endif	
.................... 
.................... 
.................... #if 1
.................... 	/* scan I2C bus */
.................... 	for (i=0x10 ; i<0xF0 ; i+=2) {
1426:  MOVLW  10
1428:  MOVLB  6
142A:  MOVWF  x1B
142C:  MOVF   x1B,W
142E:  SUBLW  EF
1430:  BNC   1482
.................... 		if ( get_ack_status(i) ) {
1432:  MOVFF  61B,621
1436:  MOVLB  0
1438:  RCALL  10C8
143A:  MOVF   01,F
143C:  BZ    147A
.................... 			fprintf(STREAM_WORLD,"# testing address 0x%02x ...",i);
143E:  MOVLW  F4
1440:  MOVWF  FF6
1442:  MOVLW  04
1444:  MOVWF  FF7
1446:  MOVLW  14
1448:  MOVLB  6
144A:  MOVWF  x22
144C:  MOVLB  0
144E:  RCALL  0F1C
1450:  MOVFF  61B,621
1454:  MOVLW  57
1456:  MOVLB  6
1458:  MOVWF  x22
145A:  MOVLB  0
145C:  RCALL  10F4
145E:  MOVLW  0C
1460:  MOVWF  FF6
1462:  MOVLW  05
1464:  MOVWF  FF7
1466:  MOVLW  04
1468:  MOVLB  6
146A:  MOVWF  x22
146C:  MOVLB  0
146E:  RCALL  0F1C
.................... 			fprintf(STREAM_WORLD," got ack!\r\n");
1470:  MOVLW  12
1472:  MOVWF  FF6
1474:  MOVLW  05
1476:  MOVWF  FF7
1478:  RCALL  10A6
....................     	} else {
.................... //			fprintf(STREAM_FTDI," nothing\r\n");
.................... 		}
147A:  MOVLW  02
147C:  MOVLB  6
147E:  ADDWF  x1B,F
1480:  BRA    142C
....................    	}
.................... #endif
.................... 
.................... 
.................... 	config.uart_sc_sbd=get_ack_status(0x9a);
1482:  MOVLW  9A
1484:  MOVWF  x21
1486:  MOVLB  0
1488:  RCALL  10C8
148A:  MOVFF  01,87
.................... 
.................... 	timers.led_on_red=timers.led_on_green=0;
148E:  CLRF   xDB
1490:  MOVFF  DB,DC
.................... 
.................... #if 0
.................... 	/* set ports to their startup state */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		current.p_on[i]=config.ch[i].startup;
.................... 	}
.................... #endif
.................... 
.................... 	i=0;
1494:  MOVLB  6
1496:  CLRF   x1B
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
1498:  CLRWDT
.................... 
.................... #if 0
.................... 		/* set the output bits to reflect their requested state */
.................... 		output_bit(CTRL_0,config.ch[0].invert ^ current.p_on[0]);
.................... 		output_bit(CTRL_1,config.ch[1].invert ^ current.p_on[1]);
.................... 		output_bit(CTRL_2,config.ch[2].invert ^ current.p_on[2]);
.................... 		output_bit(CTRL_3,config.ch[3].invert ^ current.p_on[3]);
.................... 		output_bit(CTRL_4,config.ch[4].invert ^ current.p_on[4]);
.................... 
.................... 		modbus_process();
.................... #endif
.................... 
.................... #if 0
.................... 		if ( current.adc_sample_ch != 0xff ) {
.................... 			/* read ADC (voltage) and add our offset */
.................... //			current.adc[current.adc_sample_ch]=mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch];
.................... 			current.adc[current.adc_sample_ch]=mean_filter_n(current.adc_sample_ch,mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch]);
.................... 	
.................... 			/* read the next channel (current) as soon as possible */
.................... 			current.adc_sample_ch++;
.................... //			current.adc[current.adc_sample_ch]=mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch];
.................... 			current.adc[current.adc_sample_ch]=mean_filter_n(current.adc_sample_ch,mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch]);
.................... 
.................... 			/* wait until timer interrupt gives another sample flag */
.................... 			current.adc_sample_ch=0xff;
.................... 		}
.................... #endif
.................... 
.................... #if 0
.................... 		if ( current.decide_now ) {
.................... 			current.decide_now=0;
.................... 
.................... 			for ( i=0 ; i<5 ; i++ ) {
.................... 				if ( current.override_timeout[i] > 0 ) {
.................... 					current.override_timeout[i]--;
.................... 					continue;
.................... 				}
.................... 
.................... 				if ( config.ch[i].adc_channel < 15 && current.adc[config.ch[i].adc_channel] > config.ch[i].on_above_adc ) {
.................... 					if ( current.on_delay[i] > 0 ) {
.................... 						current.on_delay[i]--;
.................... 					} else {
.................... 						current.p_on[i]=1;
.................... 					}
.................... 				} else {
.................... 					current.on_delay[i]=config.ch[i].on_above_delay;
.................... 				}
.................... 			
.................... 
.................... 				if ( config.ch[i].adc_channel < 15 && current.adc[config.ch[i].adc_channel] < config.ch[i].off_below_adc ) {
.................... 					if ( current.off_delay[i] > 0 ) {
.................... 						current.off_delay[i]--;
.................... 					} else {
.................... 						current.p_on[i]=0;
.................... 					}
.................... 				} else {
.................... 					current.off_delay[i]=config.ch[i].off_below_delay;
.................... 				}
.................... 			}
.................... 		}
.................... #endif
.................... 
.................... 
.................... 
.................... 			if ( config.uart_sc_sbd && uart_kbhit() ) {
149A:  MOVLB  0
149C:  MOVF   x87,F
149E:  BZ    14E0
14A0:  BRA    11C2
14A2:  MOVF   01,F
14A4:  BZ    14E0
.................... 				fprintf(STREAM_WORLD,"# RockBLOCK says: '%c'\r\n",uart_getc());	
*
14B0:  MOVFF  01,621
14B4:  MOVLW  1E
14B6:  MOVWF  FF6
14B8:  MOVLW  05
14BA:  MOVWF  FF7
14BC:  MOVLW  13
14BE:  MOVLB  6
14C0:  MOVWF  x22
14C2:  MOVLB  0
14C4:  RCALL  0F1C
14C6:  MOVLB  6
14C8:  MOVF   x21,W
14CA:  BTFSS  FA4.4
14CC:  BRA    14CA
14CE:  MOVWF  F79
14D0:  MOVLW  33
14D2:  MOVWF  FF6
14D4:  MOVLW  05
14D6:  MOVWF  FF7
14D8:  MOVLW  03
14DA:  MOVWF  x22
14DC:  MOVLB  0
14DE:  RCALL  0F1C
.................... 			}
.................... 			
.................... 
.................... 
.................... #if 1
.................... 		if ( current.restart_now ) {
14E0:  MOVF   xD9,F
14E2:  BTFSC  FD8.2
14E4:  BRA    15CE
.................... 			timers.led_on_green=200;
14E6:  MOVLW  C8
14E8:  MOVWF  xDB
.................... 
.................... 			output_high(CTRL_0);
14EA:  BCF    F92.0
14EC:  BSF    F89.0
.................... 
.................... 			fprintf(STREAM_WORLD,"# you said '%c'\r\n",current.restart_now);
14EE:  MOVLW  38
14F0:  MOVWF  FF6
14F2:  MOVLW  05
14F4:  MOVWF  FF7
14F6:  MOVLW  0C
14F8:  MOVLB  6
14FA:  MOVWF  x22
14FC:  MOVLB  0
14FE:  RCALL  0F1C
1500:  MOVF   xD9,W
1502:  BTFSS  FA4.4
1504:  BRA    1502
1506:  MOVWF  F79
1508:  MOVLW  46
150A:  MOVWF  FF6
150C:  MOVLW  05
150E:  MOVWF  FF7
1510:  MOVLW  03
1512:  MOVLB  6
1514:  MOVWF  x22
1516:  MOVLB  0
1518:  RCALL  0F1C
.................... 			if ( config.uart_sc_sbd ) {
151A:  MOVF   x87,F
151C:  BZ    1524
.................... 				uart_putc(current.restart_now);
151E:  MOVFF  D9,621
1522:  BRA    11D6
.................... 			}
.................... 
.................... 			current.restart_now=0;
1524:  CLRF   xD9
.................... 
.................... 
.................... #if 0
.................... 			/* read a block of bytes from device */
.................... 			i2c_start();
.................... 			delay_us(15);
.................... 			i2c_write(0x36);
.................... 			i2c_write(0); /* register address 0 */
.................... 			i2c_start();
.................... 			delay_us(15);
.................... 			i2c_write(0x36 | 1); /* read */
.................... 			
.................... 			for ( i=0 ; i<16 ; i++ ) {
.................... 				j=i2c_read(1);
.................... 
.................... 				fprintf(STREAM_WORLD,"# byte addr[0x%02x]=0x%02x (%u)\r\n",
.................... 					i,
.................... 					j,
.................... 					j
.................... 				);
.................... 			}
.................... 			i2c_read(0);
.................... #endif
.................... 
.................... #if 1
.................... 			/* 16 bit registers, but byte addressed */
.................... 			for ( i=0 ; i<18 ; i ++ ) {
1526:  MOVLB  6
1528:  CLRF   x1B
152A:  MOVF   x1B,W
152C:  SUBLW  11
152E:  BNC   15C8
.................... 				l=i2c_register_read16(0x36,i);
1530:  MOVLW  36
1532:  MOVWF  x21
1534:  MOVFF  61B,622
1538:  MOVLB  0
153A:  BRA    11E8
153C:  MOVFF  02,61E
1540:  MOVFF  01,61D
.................... 				fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%04lx (%lu)\r\n",i,l,l);
1544:  MOVLW  4A
1546:  MOVWF  FF6
1548:  MOVLW  05
154A:  MOVWF  FF7
154C:  MOVLW  0D
154E:  MOVLB  6
1550:  MOVWF  x22
1552:  MOVLB  0
1554:  RCALL  0F1C
1556:  MOVFF  61B,621
155A:  MOVLW  57
155C:  MOVLB  6
155E:  MOVWF  x22
1560:  MOVLB  0
1562:  RCALL  10F4
1564:  MOVLW  5B
1566:  MOVWF  FF6
1568:  MOVLW  05
156A:  MOVWF  FF7
156C:  MOVLW  04
156E:  MOVLB  6
1570:  MOVWF  x22
1572:  MOVLB  0
1574:  RCALL  0F1C
1576:  MOVFF  61E,621
157A:  MOVLW  57
157C:  MOVLB  6
157E:  MOVWF  x22
1580:  MOVLB  0
1582:  RCALL  10F4
1584:  MOVFF  61D,621
1588:  MOVLW  57
158A:  MOVLB  6
158C:  MOVWF  x22
158E:  MOVLB  0
1590:  RCALL  10F4
1592:  MOVLW  20
1594:  BTFSS  FA4.4
1596:  BRA    1594
1598:  MOVWF  F79
159A:  MOVLW  28
159C:  BTFSS  FA4.4
159E:  BRA    159C
15A0:  MOVWF  F79
15A2:  MOVLW  10
15A4:  MOVWF  FE9
15A6:  MOVFF  61E,622
15AA:  MOVFF  61D,621
15AE:  RCALL  0F46
15B0:  MOVLW  69
15B2:  MOVWF  FF6
15B4:  MOVLW  05
15B6:  MOVWF  FF7
15B8:  MOVLW  03
15BA:  MOVLB  6
15BC:  MOVWF  x22
15BE:  MOVLB  0
15C0:  RCALL  0F1C
.................... 			}
.................... #endif
.................... 
.................... #if 0
15C2:  MOVLB  6
15C4:  INCF   x1B,F
15C6:  BRA    152A
.................... 			fprintf(STREAM_WORLD,"# writing 0x%04lx to register 1\r\n",n);
.................... 			i2c_register_write16(0x36,1,n);
.................... 			n+=200;
.................... #endif
.................... 			output_low(CTRL_0);
15C8:  BCF    F92.0
15CA:  BCF    F89.0
15CC:  MOVLB  0
.................... 
.................... 		}
.................... #endif
15CE:  MOVLB  6
15D0:  BRA    1498
.................... 
.................... 
.................... 
.................... 		
.................... 	}
.................... }
15D2:  BRA    15D2

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 3469   NOPUT NOBROWNOUT BORV27 ZPBORM NOWDT WDT8192
   Word  3: 0900   CANB MSSPMSK7
   Word  4: 0010   NOSTVREN BBSIZ2K DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E000   NOWRTC NOWRTB NOWRTD
   Word  7: 4000   NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
