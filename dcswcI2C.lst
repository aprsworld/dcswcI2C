CCS PCH C Compiler, Version 5.090, 49113               11-Jan-22 15:15

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswcI2C\dcswcI2C.lst

               ROM used:   5266 bytes (16%)
                           Largest free fragment is 27498
               RAM used:   1569 (43%) at main() level
                           1604 (44%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 30

0000:  GOTO   11CA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   03BA
0060:  BTFSS  FA0.1
0062:  GOTO   006C
0066:  BTFSC  FA1.1
0068:  GOTO   02F2
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0428
0078:  BTFSS  FA3.5
007A:  GOTO   0084
007E:  BTFSC  FA4.5
0080:  GOTO   039A
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "dcswcI2C.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
0488:  DATA 23,20
048A:  DATA 64,63
048C:  DATA 73,77
048E:  DATA 63,49
0490:  DATA 32,43
0492:  DATA 20,28
0494:  DATA 25,63
0496:  DATA 25,6C
0498:  DATA 75,29
049A:  DATA 20,73
049C:  DATA 74,61
049E:  DATA 72,74
04A0:  DATA 20,75
04A2:  DATA 70,20
04A4:  DATA 28,64
04A6:  DATA 73,33
04A8:  DATA 30,20
04AA:  DATA 62,6F
04AC:  DATA 6F,74
04AE:  DATA 6C,6F
04B0:  DATA 61,64
04B2:  DATA 65,72
04B4:  DATA 20,73
04B6:  DATA 75,70
04B8:  DATA 70,6F
04BA:  DATA 72,74
04BC:  DATA 29,20
04BE:  DATA 28,77
04C0:  DATA 6F,72
04C2:  DATA 6C,64
04C4:  DATA 44,61
04C6:  DATA 74,61
04C8:  DATA 20,73
04CA:  DATA 74,72
04CC:  DATA 65,61
04CE:  DATA 6D,29
04D0:  DATA 20,28
04D2:  DATA 6D,6F
04D4:  DATA 64,62
04D6:  DATA 75,73
04D8:  DATA 20,61
04DA:  DATA 64,64
04DC:  DATA 72,65
04DE:  DATA 73,73
04E0:  DATA 3D,25
04E2:  DATA 75,29
04E4:  DATA 20,25
04E6:  DATA 73,0D
04E8:  DATA 0A,00
04EA:  DATA 31,31
04EC:  DATA 2D,4A
04EE:  DATA 61,6E
04F0:  DATA 2D,32
04F2:  DATA 32,00
04F4:  DATA 23,20
04F6:  DATA 74,65
04F8:  DATA 73,74
04FA:  DATA 69,6E
04FC:  DATA 67,20
04FE:  DATA 61,64
0500:  DATA 64,72
0502:  DATA 65,73
0504:  DATA 73,20
0506:  DATA 30,78
0508:  DATA 25,30
050A:  DATA 32,78
050C:  DATA 20,2E
050E:  DATA 2E,2E
0510:  DATA 00,00
0512:  DATA 20,67
0514:  DATA 6F,74
0516:  DATA 20,61
0518:  DATA 63,6B
051A:  DATA 21,0D
051C:  DATA 0A,00
051E:  DATA 23,20
0520:  DATA 52,6F
0522:  DATA 63,6B
0524:  DATA 42,4C
0526:  DATA 4F,43
0528:  DATA 4B,20
052A:  DATA 73,61
052C:  DATA 79,73
052E:  DATA 3A,20
0530:  DATA 27,25
0532:  DATA 63,27
0534:  DATA 0D,0A
0536:  DATA 00,00
0538:  DATA 23,20
053A:  DATA 79,6F
053C:  DATA 75,20
053E:  DATA 73,61
0540:  DATA 69,64
0542:  DATA 20,27
0544:  DATA 25,63
0546:  DATA 27,0D
0548:  DATA 0A,00
*
0C8C:  MOVLB  6
0C8E:  MOVF   x2D,W
0C90:  MULWF  x2F
0C92:  MOVFF  FF3,01
0C96:  MOVFF  FF4,00
0C9A:  MULWF  x30
0C9C:  MOVF   FF3,W
0C9E:  ADDWF  00,F
0CA0:  MOVF   x2E,W
0CA2:  MULWF  x2F
0CA4:  MOVF   FF3,W
0CA6:  ADDWFC 00,W
0CA8:  MOVWF  02
0CAA:  MOVLB  0
0CAC:  RETURN 0
0CAE:  BTFSC  FD8.1
0CB0:  BRA    0CBA
0CB2:  MOVLW  06
0CB4:  MOVWF  FEA
0CB6:  MOVLW  3C
0CB8:  MOVWF  FE9
0CBA:  CLRF   00
0CBC:  CLRF   01
0CBE:  CLRF   02
0CC0:  CLRF   03
0CC2:  MOVLB  6
0CC4:  CLRF   x3C
0CC6:  CLRF   x3D
0CC8:  CLRF   x3E
0CCA:  CLRF   x3F
0CCC:  MOVF   x3B,W
0CCE:  IORWF  x3A,W
0CD0:  IORWF  x39,W
0CD2:  IORWF  x38,W
0CD4:  BZ    0D2E
0CD6:  MOVLW  20
0CD8:  MOVWF  x40
0CDA:  BCF    FD8.0
0CDC:  RLCF   x34,F
0CDE:  RLCF   x35,F
0CE0:  RLCF   x36,F
0CE2:  RLCF   x37,F
0CE4:  RLCF   x3C,F
0CE6:  RLCF   x3D,F
0CE8:  RLCF   x3E,F
0CEA:  RLCF   x3F,F
0CEC:  MOVF   x3B,W
0CEE:  SUBWF  x3F,W
0CF0:  BNZ   0D02
0CF2:  MOVF   x3A,W
0CF4:  SUBWF  x3E,W
0CF6:  BNZ   0D02
0CF8:  MOVF   x39,W
0CFA:  SUBWF  x3D,W
0CFC:  BNZ   0D02
0CFE:  MOVF   x38,W
0D00:  SUBWF  x3C,W
0D02:  BNC   0D22
0D04:  MOVF   x38,W
0D06:  SUBWF  x3C,F
0D08:  MOVF   x39,W
0D0A:  BTFSS  FD8.0
0D0C:  INCFSZ x39,W
0D0E:  SUBWF  x3D,F
0D10:  MOVF   x3A,W
0D12:  BTFSS  FD8.0
0D14:  INCFSZ x3A,W
0D16:  SUBWF  x3E,F
0D18:  MOVF   x3B,W
0D1A:  BTFSS  FD8.0
0D1C:  INCFSZ x3B,W
0D1E:  SUBWF  x3F,F
0D20:  BSF    FD8.0
0D22:  RLCF   00,F
0D24:  RLCF   01,F
0D26:  RLCF   02,F
0D28:  RLCF   03,F
0D2A:  DECFSZ x40,F
0D2C:  BRA    0CDA
0D2E:  MOVFF  63C,FEF
0D32:  MOVFF  63D,FEC
0D36:  MOVFF  63E,FEC
0D3A:  MOVFF  63F,FEC
0D3E:  MOVLB  0
0D40:  GOTO   0ED0 (RETURN)
*
0EF8:  TBLRD*+
0EFA:  MOVFF  FF6,61F
0EFE:  MOVFF  FF7,620
0F02:  MOVF   FF5,W
0F04:  BTFSS  FA4.4
0F06:  BRA    0F04
0F08:  MOVWF  F79
0F0A:  MOVFF  61F,FF6
0F0E:  MOVFF  620,FF7
0F12:  MOVLB  6
0F14:  DECFSZ x1E,F
0F16:  BRA    0F1A
0F18:  BRA    0F1E
0F1A:  MOVLB  0
0F1C:  BRA    0EF8
0F1E:  MOVLB  0
0F20:  RETURN 0
0F22:  MOVFF  FEA,625
0F26:  MOVFF  FE9,624
0F2A:  MOVLB  6
0F2C:  SWAPF  x1E,W
0F2E:  IORLW  F0
0F30:  MOVWF  x20
0F32:  ADDWF  x20,F
0F34:  ADDLW  E2
0F36:  MOVWF  x21
0F38:  ADDLW  32
0F3A:  MOVWF  x23
0F3C:  MOVF   x1E,W
0F3E:  ANDLW  0F
0F40:  ADDWF  x21,F
0F42:  ADDWF  x21,F
0F44:  ADDWF  x23,F
0F46:  ADDLW  E9
0F48:  MOVWF  x22
0F4A:  ADDWF  x22,F
0F4C:  ADDWF  x22,F
0F4E:  SWAPF  x1D,W
0F50:  ANDLW  0F
0F52:  ADDWF  x22,F
0F54:  ADDWF  x23,F
0F56:  RLCF   x22,F
0F58:  RLCF   x23,F
0F5A:  COMF   x23,F
0F5C:  RLCF   x23,F
0F5E:  MOVF   x1D,W
0F60:  ANDLW  0F
0F62:  ADDWF  x23,F
0F64:  RLCF   x20,F
0F66:  MOVLW  07
0F68:  MOVWF  x1F
0F6A:  MOVLW  0A
0F6C:  DECF   x22,F
0F6E:  ADDWF  x23,F
0F70:  BNC   0F6C
0F72:  DECF   x21,F
0F74:  ADDWF  x22,F
0F76:  BNC   0F72
0F78:  DECF   x20,F
0F7A:  ADDWF  x21,F
0F7C:  BNC   0F78
0F7E:  DECF   x1F,F
0F80:  ADDWF  x20,F
0F82:  BNC   0F7E
0F84:  MOVLW  06
0F86:  MOVWF  FEA
0F88:  MOVLW  1F
0F8A:  MOVWF  FE9
0F8C:  MOVLW  07
0F8E:  ANDWF  x24,W
0F90:  BCF    x24.6
0F92:  ADDWF  FE9,F
0F94:  MOVLW  00
0F96:  ADDWFC FEA,F
0F98:  MOVF   FE9,W
0F9A:  SUBLW  23
0F9C:  BNZ   0FA6
0F9E:  MOVF   FEA,W
0FA0:  SUBLW  06
0FA2:  BNZ   0FA6
0FA4:  BSF    x24.6
0FA6:  MOVF   FEF,W
0FA8:  MOVWF  00
0FAA:  BNZ   0FBC
0FAC:  BTFSC  x24.6
0FAE:  BRA    0FBC
0FB0:  BTFSC  x24.4
0FB2:  BRA    0FCC
0FB4:  BTFSC  x24.3
0FB6:  BRA    0FBC
0FB8:  MOVLW  20
0FBA:  BRA    0FC2
0FBC:  BSF    x24.3
0FBE:  BCF    x24.4
0FC0:  MOVLW  30
0FC2:  ADDWF  00,F
0FC4:  MOVF   00,W
0FC6:  BTFSS  FA4.4
0FC8:  BRA    0FC6
0FCA:  MOVWF  F79
0FCC:  MOVF   FEE,W
0FCE:  BTFSS  x24.6
0FD0:  BRA    0F98
0FD2:  MOVLB  0
0FD4:  GOTO   1348 (RETURN)
0FD8:  MOVLB  6
0FDA:  MOVF   x20,W
0FDC:  CLRF   01
0FDE:  SUBWF  x1F,W
0FE0:  BC    0FE8
0FE2:  MOVFF  61F,00
0FE6:  BRA    1000
0FE8:  CLRF   00
0FEA:  MOVLW  08
0FEC:  MOVWF  x21
0FEE:  RLCF   x1F,F
0FF0:  RLCF   00,F
0FF2:  MOVF   x20,W
0FF4:  SUBWF  00,W
0FF6:  BTFSC  FD8.0
0FF8:  MOVWF  00
0FFA:  RLCF   01,F
0FFC:  DECFSZ x21,F
0FFE:  BRA    0FEE
1000:  MOVLB  0
1002:  RETURN 0
1004:  MOVF   01,W
1006:  MOVFF  61D,61F
100A:  MOVLW  64
100C:  MOVLB  6
100E:  MOVWF  x20
1010:  MOVLB  0
1012:  RCALL  0FD8
1014:  MOVFF  00,61D
1018:  MOVF   01,W
101A:  MOVLW  30
101C:  BNZ   102E
101E:  MOVLB  6
1020:  BTFSS  x1E.1
1022:  BRA    1040
1024:  BTFSC  x1E.3
1026:  BRA    1040
1028:  BTFSC  x1E.4
102A:  MOVLW  20
102C:  BRA    1036
102E:  MOVLB  6
1030:  BCF    x1E.3
1032:  BCF    x1E.4
1034:  BSF    x1E.0
1036:  ADDWF  01,F
1038:  MOVF   01,W
103A:  BTFSS  FA4.4
103C:  BRA    103A
103E:  MOVWF  F79
1040:  MOVFF  61D,61F
1044:  MOVLW  0A
1046:  MOVWF  x20
1048:  MOVLB  0
104A:  RCALL  0FD8
104C:  MOVFF  00,61D
1050:  MOVF   01,W
1052:  MOVLW  30
1054:  BNZ   1066
1056:  MOVLB  6
1058:  BTFSC  x1E.3
105A:  BRA    1072
105C:  BTFSS  x1E.0
105E:  BRA    1072
1060:  BTFSC  x1E.4
1062:  MOVLW  20
1064:  MOVLB  0
1066:  ADDWF  01,F
1068:  MOVF   01,W
106A:  BTFSS  FA4.4
106C:  BRA    106A
106E:  MOVWF  F79
1070:  MOVLB  6
1072:  MOVLW  30
1074:  ADDWF  x1D,F
1076:  MOVF   x1D,W
1078:  BTFSS  FA4.4
107A:  BRA    1078
107C:  MOVWF  F79
107E:  MOVLB  0
1080:  GOTO   1368 (RETURN)
1084:  TBLRD*+
1086:  MOVF   FF5,F
1088:  BZ    10A4
108A:  MOVFF  FF6,61D
108E:  MOVFF  FF7,61E
1092:  MOVF   FF5,W
1094:  BTFSS  FA4.4
1096:  BRA    1094
1098:  MOVWF  F79
109A:  MOVFF  61D,FF6
109E:  MOVFF  61E,FF7
10A2:  BRA    1084
10A4:  RETURN 0
*
10D2:  MOVLB  6
10D4:  BTFSC  x1E.7
10D6:  BRA    10F8
10D8:  MOVLW  0F
10DA:  MOVWF  00
10DC:  SWAPF  x1D,W
10DE:  ANDWF  00,F
10E0:  MOVLW  0A
10E2:  SUBWF  00,W
10E4:  BC    10EC
10E6:  MOVLW  30
10E8:  ADDWF  00,F
10EA:  BRA    10F0
10EC:  MOVF   x1E,W
10EE:  ADDWF  00,F
10F0:  MOVF   00,W
10F2:  BTFSS  FA4.4
10F4:  BRA    10F2
10F6:  MOVWF  F79
10F8:  MOVLW  0F
10FA:  ANDWF  x1D,F
10FC:  MOVLW  0A
10FE:  SUBWF  x1D,W
1100:  BC    1106
1102:  MOVLW  30
1104:  BRA    110A
1106:  BCF    x1E.7
1108:  MOVF   x1E,W
110A:  ADDWF  x1D,F
110C:  MOVF   x1D,W
110E:  BTFSS  FA4.4
1110:  BRA    110E
1112:  MOVWF  F79
1114:  MOVLB  0
1116:  GOTO   13CA (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... 
.................... #if 1
.................... /* no boot loader */
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BORV30
.................... #fuses WDT32768
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... 
.................... #else
.................... 
.................... /* DS30 boot loader version 1.5.1 - engine 2.2.2 */
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */
.................... /* max mem address - 0x243, max mem address - 0x240 */
.................... #build(reset=0x7dbc:0x7dbf)
.................... /* max mem address - 0x23f, max mem address - see memory organization in datasheet */
.................... //#org 0x7dc0,0x7fff {}
.................... #org 0x7dc0,0x7fff {}
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
061C:  MOVLW  06
061E:  MOVWF  FEA
0620:  MOVLW  1E
0622:  MOVWF  FE9
0624:  MOVF   FEF,W
0626:  BZ    064A
0628:  MOVLW  02
062A:  MOVWF  01
062C:  MOVLW  BF
062E:  MOVWF  00
0630:  CLRWDT
0632:  DECFSZ 00,F
0634:  BRA    0630
0636:  DECFSZ 01,F
0638:  BRA    062C
063A:  MOVLW  96
063C:  MOVWF  00
063E:  DECFSZ 00,F
0640:  BRA    063E
0642:  BRA    0644
0644:  CLRWDT
0646:  DECFSZ FEF,F
0648:  BRA    0628
064A:  GOTO   07A8 (RETURN)
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x000
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... /* UART1 - RS-485 connection modbus */
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=9600,xmit=PIN_C6,rcv=PIN_C7,errors)	
*
03EA:  BTFSS  F9E.5
03EC:  BRA    03EA
03EE:  MOVFF  FAB,20
03F2:  MOVFF  FAE,01
03F6:  BTFSS  20.1
03F8:  BRA    03FE
03FA:  BCF    FAB.4
03FC:  BSF    FAB.4
03FE:  RETURN 0
.................... 
.................... 
.................... #byte TXSTA=GETENV("SFR:txsta1")
.................... #bit  TRMT=TXSTA.1
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... #byte PORTB=GETENV("SFR:portb")
.................... #byte INTCON2=GETENV("SFR:intcon2")
.................... #bit RBPU=INTCON2.7
.................... 
.................... /* UART2 - FTDI cable */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600,errors)	
*
0382:  BTFSS  FA4.5
0384:  BRA    0382
0386:  MOVFF  FA6,20
038A:  MOVFF  F7A,01
038E:  BTFSS  20.1
0390:  BRA    0396
0392:  BCF    FA6.4
0394:  BSF    FA6.4
0396:  GOTO   039C (RETURN)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
0554:  BCF    FC6.7
0556:  BCF    F9E.3
0558:  MOVFF  622,FC9
055C:  MOVLW  02
055E:  BTFSC  FC6.7
0560:  BRA    056C
0562:  BTFSS  F9E.3
0564:  BRA    0562
0566:  MOVLW  00
0568:  BTFSC  FC5.6
056A:  MOVLW  01
056C:  MOVWF  01
056E:  RETURN 0
*
111A:  BCF    FC6.6
111C:  BSF    FC5.3
111E:  BTFSC  FC5.3
1120:  BRA    111E
1122:  BTFSC  00.0
1124:  BCF    FC5.5
1126:  BTFSS  00.0
1128:  BSF    FC5.5
112A:  BSF    FC5.4
112C:  BTFSC  FC5.4
112E:  BRA    112C
1130:  MOVFF  FC9,01
1134:  GOTO   1190 (RETURN)
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... /* Modbus defines */
.................... #define MODBUS_MODE_RTU     0
.................... #define MODBUS_MODE_TCP_RTU 1
.................... 
.................... #define SERIAL_PREFIX_DEFAULT 'Z'
.................... #define SERIAL_NUMBER_DEFAULT 2221
.................... 
.................... 
.................... #define DCSW_FPF2700_ACS714     0
.................... #define DCSW_LATCHING_CONTACTOR 1
.................... #define DCSW_SMALL48            2
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 startup;
.................... 
.................... 	int16 off_below_adc;
.................... 	int16 off_below_delay;
.................... 	int16 on_above_adc;
.................... 	int16 on_above_delay;
.................... 	int16 override_timeout;
.................... 	int16 switch_type;
.................... 
.................... 	signed int8 i_mon_offset; /* applied in addition to config.adc_offset */
.................... 	int8 adc_channel; /* which ADC channel (0 to 15) for LVD and HVD */
.................... 	int8 invert;
.................... } struct_output_channel;
.................... 
.................... typedef struct {
.................... 	int8 revision;
.................... 	int8 modbus_address;
.................... 	int8 modbus_mode;
.................... 
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 
.................... 	struct_output_channel ch[5];
.................... 	signed int8 adc_offset[16];
.................... 
.................... 	int8 uart_sc_sbd;
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int16 modbus_our_packets;
.................... 	int16 modbus_other_packets;
.................... 	int16 modbus_last_error;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 	int8 p_on[5];
.................... 	int16 adc[16];
.................... 	
.................... 	int16 on_delay[5];
.................... 	int16 off_delay[5];
.................... 	int16 override_timeout[5];
.................... 
.................... 
.................... 	int8 decide_now;
.................... 	int8 restart_now;
.................... 	int8 adc_sample_ch;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	int8 led_on_green;
.................... 	int8 led_on_red;
.................... } struct_time_keep;
.................... 
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "uart_sc16is740_dcswcI2C.c"
.................... /* register map for SCI16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
1138:  BSF    FC5.0
113A:  BTFSC  FC5.0
113C:  BRA    113A
.................... 	delay_us(15);
113E:  CLRWDT
1140:  MOVLW  09
1142:  MOVWF  00
1144:  DECFSZ 00,F
1146:  BRA    1144
1148:  NOP   
.................... 	i2c_write(UART_ADDR);
114A:  MOVLW  9A
114C:  MOVLB  6
114E:  MOVWF  x22
1150:  MOVLB  0
1152:  CALL   0554
.................... 	i2c_write(regaddr<<3);
1156:  MOVLB  6
1158:  RLCF   x1D,W
115A:  MOVWF  x1F
115C:  RLCF   x1F,F
115E:  RLCF   x1F,F
1160:  MOVLW  F8
1162:  ANDWF  x1F,F
1164:  MOVFF  61F,622
1168:  MOVLB  0
116A:  CALL   0554
.................... 	i2c_start();
116E:  BSF    FC5.1
1170:  BTFSC  FC5.1
1172:  BRA    1170
.................... 	delay_us(15);
1174:  CLRWDT
1176:  MOVLW  09
1178:  MOVWF  00
117A:  DECFSZ 00,F
117C:  BRA    117A
117E:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
1180:  MOVLW  9B
1182:  MOVLB  6
1184:  MOVWF  x22
1186:  MOVLB  0
1188:  CALL   0554
.................... 	data=i2c_read(0);
118C:  CLRF   00
118E:  BRA    111A
1190:  MOVFF  01,61E
.................... 	i2c_stop();
1194:  BSF    FC5.2
1196:  BTFSC  FC5.2
1198:  BRA    1196
.................... 
.................... 	return data;
119A:  MOVLB  6
119C:  MOVFF  61E,01
11A0:  MOVLB  0
11A2:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
0570:  BSF    FC5.0
0572:  BTFSC  FC5.0
0574:  BRA    0572
.................... 	delay_us(15);                                                 
0576:  CLRWDT
0578:  MOVLW  09
057A:  MOVWF  00
057C:  DECFSZ 00,F
057E:  BRA    057C
0580:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
0582:  MOVLW  9A
0584:  MOVLB  6
0586:  MOVWF  x22
0588:  MOVLB  0
058A:  RCALL  0554
.................... 	i2c_write(regaddr<< 3);  // write cycle         
058C:  MOVLB  6
058E:  RLCF   x1F,W
0590:  MOVWF  x21
0592:  RLCF   x21,F
0594:  RLCF   x21,F
0596:  MOVLW  F8
0598:  ANDWF  x21,F
059A:  MOVFF  621,622
059E:  MOVLB  0
05A0:  RCALL  0554
.................... 	i2c_write(data);
05A2:  MOVFF  620,622
05A6:  RCALL  0554
.................... 	i2c_stop();
05A8:  BSF    FC5.2
05AA:  BTFSC  FC5.2
05AC:  BRA    05AA
05AE:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
11B8:  MOVLB  6
11BA:  CLRF   x1F
11BC:  MOVFF  61D,620
11C0:  MOVLB  0
11C2:  CALL   0570
11C6:  GOTO   148A (RETURN)
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
11A4:  MOVLW  05
11A6:  MOVLB  6
11A8:  MOVWF  x1D
11AA:  MOVLB  0
11AC:  RCALL  1138
11AE:  MOVF   01,W
11B0:  ANDLW  01
11B2:  MOVWF  01
11B4:  GOTO   140E (RETURN)
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
*
1412:  MOVLB  6
1414:  CLRF   x1D
1416:  MOVLB  0
1418:  RCALL  1138
141A:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
05B0:  MOVLW  03
05B2:  MOVLB  6
05B4:  MOVWF  x1F
05B6:  MOVLW  80
05B8:  MOVWF  x20
05BA:  MOVLB  0
05BC:  RCALL  0570
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
05BE:  MOVLB  6
05C0:  CLRF   x1F
05C2:  MOVFF  61E,620
05C6:  MOVLB  0
05C8:  RCALL  0570
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
05CA:  MOVLW  01
05CC:  MOVLB  6
05CE:  MOVWF  x1F
05D0:  CLRF   x20
05D2:  MOVLB  0
05D4:  RCALL  0570
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
05D6:  MOVLW  03
05D8:  MOVLB  6
05DA:  MOVWF  x1F
05DC:  MOVLW  BF
05DE:  MOVWF  x20
05E0:  MOVLB  0
05E2:  RCALL  0570
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
05E4:  MOVLW  02
05E6:  MOVLB  6
05E8:  MOVWF  x1F
05EA:  MOVLW  10
05EC:  MOVWF  x20
05EE:  MOVLB  0
05F0:  RCALL  0570
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
05F2:  MOVLW  03
05F4:  MOVLB  6
05F6:  MOVWF  x1F
05F8:  MOVWF  x20
05FA:  MOVLB  0
05FC:  RCALL  0570
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
05FE:  MOVLW  01
0600:  MOVLB  6
0602:  MOVWF  x1F
0604:  CLRF   x20
0606:  MOVLB  0
0608:  RCALL  0570
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
060A:  MOVLW  02
060C:  MOVLB  6
060E:  MOVWF  x1F
0610:  MOVLW  07
0612:  MOVWF  x20
0614:  MOVLB  0
0616:  RCALL  0570
0618:  GOTO   079E (RETURN)
.................... }
.................... 
.................... 
.................... #include "mcp3208_dcswcI2C.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
*
054A:  BCF    F93.4
054C:  BSF    F8A.4
.................... 	output_high(CS_ADC0);
054E:  BCF    F93.0
0550:  BSF    F8A.0
0552:  RETURN 0
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
*
0BB6:  BCF    F93.3
0BB8:  BCF    F8A.3
.................... 	output_high(MCP3208_DIN);
0BBA:  BCF    F93.1
0BBC:  BSF    F8A.1
.................... 
.................... 
.................... 	if ( ch<8 ) {
0BBE:  MOVLB  6
0BC0:  MOVF   x1F,W
0BC2:  SUBLW  07
0BC4:  BNC   0BCC
.................... 		output_low(CS_ADC0);
0BC6:  BCF    F93.0
0BC8:  BCF    F8A.0
.................... 	} else {
0BCA:  BRA    0BD4
.................... 		output_low(CS_ADC1);
0BCC:  BCF    F93.4
0BCE:  BCF    F8A.4
.................... 		ch-=8;
0BD0:  MOVLW  08
0BD2:  SUBWF  x1F,F
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
0BD4:  MOVF   x1F,F
0BD6:  BNZ   0BDE
.................... 		c=0b00011;
0BD8:  MOVLW  03
0BDA:  MOVWF  x23
0BDC:  BRA    0C28
.................... 	else if ( 1 == ch ) 
0BDE:  DECFSZ x1F,W
0BE0:  BRA    0BE8
.................... 		c=0b10011;
0BE2:  MOVLW  13
0BE4:  MOVWF  x23
0BE6:  BRA    0C28
.................... 	else if ( 2 == ch ) 
0BE8:  MOVF   x1F,W
0BEA:  SUBLW  02
0BEC:  BNZ   0BF4
.................... 		c=0b01011;
0BEE:  MOVLW  0B
0BF0:  MOVWF  x23
0BF2:  BRA    0C28
.................... 	else if ( 3 == ch ) 
0BF4:  MOVF   x1F,W
0BF6:  SUBLW  03
0BF8:  BNZ   0C00
.................... 		c=0b11011;
0BFA:  MOVLW  1B
0BFC:  MOVWF  x23
0BFE:  BRA    0C28
.................... 	else if ( 4 == ch )
0C00:  MOVF   x1F,W
0C02:  SUBLW  04
0C04:  BNZ   0C0C
.................... 		c=0b00111;
0C06:  MOVLW  07
0C08:  MOVWF  x23
0C0A:  BRA    0C28
.................... 	else if ( 5 == ch ) 
0C0C:  MOVF   x1F,W
0C0E:  SUBLW  05
0C10:  BNZ   0C18
.................... 		c=0b10111;
0C12:  MOVLW  17
0C14:  MOVWF  x23
0C16:  BRA    0C28
.................... 	else if ( 6 == ch )
0C18:  MOVF   x1F,W
0C1A:  SUBLW  06
0C1C:  BNZ   0C24
.................... 		c=0b01111;
0C1E:  MOVLW  0F
0C20:  MOVWF  x23
0C22:  BRA    0C28
.................... 	else
.................... 		c=0b11111;
0C24:  MOVLW  1F
0C26:  MOVWF  x23
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0C28:  CLRF   x22
0C2A:  MOVF   x22,W
0C2C:  SUBLW  04
0C2E:  BNC   0C4C
.................... 		output_low(MCP3208_CLK);
0C30:  BCF    F93.3
0C32:  BCF    F8A.3
.................... 		output_bit(MCP3208_DIN,c&1);
0C34:  BTFSC  x23.0
0C36:  BRA    0C3C
0C38:  BCF    F8A.1
0C3A:  BRA    0C3E
0C3C:  BSF    F8A.1
0C3E:  BCF    F93.1
.................... 		c=c>>1;
0C40:  BCF    FD8.0
0C42:  RRCF   x23,F
.................... 		output_high(MCP3208_CLK);
0C44:  BCF    F93.3
0C46:  BSF    F8A.3
0C48:  INCF   x22,F
0C4A:  BRA    0C2A
.................... 	}
.................... 
.................... 
.................... 	value=0;
0C4C:  CLRF   x21
0C4E:  CLRF   x20
.................... 	for ( i=0 ; i<14 ; i++ ) {
0C50:  CLRF   x22
0C52:  MOVF   x22,W
0C54:  SUBLW  0D
0C56:  BNC   0C74
.................... 		output_low(MCP3208_CLK);
0C58:  BCF    F93.3
0C5A:  BCF    F8A.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
0C5C:  BSF    F93.2
0C5E:  BTFSC  F81.2
0C60:  BRA    0C66
0C62:  BCF    FD8.0
0C64:  BRA    0C68
0C66:  BSF    FD8.0
0C68:  RLCF   x20,F
0C6A:  RLCF   x21,F
.................... 		output_high(MCP3208_CLK);
0C6C:  BCF    F93.3
0C6E:  BSF    F8A.3
0C70:  INCF   x22,F
0C72:  BRA    0C52
.................... 	}
.................... 
.................... 	bit_clear(value,13);
0C74:  BCF    x21.5
.................... 	bit_clear(value,12);
0C76:  BCF    x21.4
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
0C78:  MOVLB  0
0C7A:  RCALL  054A
.................... 
.................... 	return value;
0C7C:  MOVLB  6
0C7E:  MOVFF  620,01
0C82:  MOVFF  621,02
0C86:  MOVLB  0
0C88:  GOTO   12CE (RETURN)
.................... }
.................... 
.................... #include "interrupt_dcswcI2C.c"
.................... 
.................... #int_timer3
.................... void isr_10ms(void) {
.................... 	static int16 uptimeTicks=0;
.................... 	static int16 ticks=0;
.................... 	static int8 adc_ch=0;
.................... 
.................... 	/* preset so we trigger again in 10 milliseconds */
.................... 	set_timer3(45536);
*
02F2:  MOVLW  B1
02F4:  MOVWF  FB3
02F6:  MOVLW  E0
02F8:  MOVWF  FB2
.................... 
.................... 	/* scan adc channels */
.................... 	current.adc_sample_ch = adc_ch;
02FA:  MOVFF  E1,DA
.................... 	/* each adc read gives us two channels */
.................... 	adc_ch+=2;
02FE:  MOVLW  02
0300:  ADDWF  xE1,F
.................... 
.................... 	if ( adc_ch >= 16 ) 
0302:  MOVF   xE1,W
0304:  SUBLW  0F
0306:  BC    030A
.................... 		adc_ch=0;
0308:  CLRF   xE1
.................... 
.................... 	/* LVD / HVD flag */
.................... 	current.decide_now=1;
030A:  MOVLW  01
030C:  MOVWF  xD8
.................... 
.................... 
.................... 	/* ticks(?) since last query */
.................... 	if ( current.interval_milliseconds < 65525 ) {
030E:  MOVF   x93,W
0310:  SUBLW  FF
0312:  BNC   0326
0314:  BNZ   031C
0316:  MOVF   x92,W
0318:  SUBLW  F4
031A:  BNC   0326
.................... 		current.interval_milliseconds+=10;
031C:  MOVLW  0A
031E:  ADDWF  x92,F
0320:  MOVLW  00
0322:  ADDWFC x93,F
.................... 	} else {
0324:  BRA    032A
.................... 		current.interval_milliseconds=65535;
0326:  SETF   x93
0328:  SETF   x92
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
032A:  INCF   xDF,F
032C:  BTFSC  FD8.2
032E:  INCF   xE0,F
.................... 	if ( ticks >= 100 ) {
0330:  MOVF   xE0,F
0332:  BNZ   033A
0334:  MOVF   xDF,W
0336:  SUBLW  63
0338:  BC    033E
.................... 		ticks=0;
033A:  CLRF   xE0
033C:  CLRF   xDF
.................... 	}
.................... 	
.................... 
.................... 	/* uptime counter */
.................... 	uptimeTicks++;
033E:  INCF   xDD,F
0340:  BTFSC  FD8.2
0342:  INCF   xDE,F
.................... 	if ( 6000 == uptimeTicks ) {
0344:  MOVF   xDD,W
0346:  SUBLW  70
0348:  BNZ   0364
034A:  MOVF   xDE,W
034C:  SUBLW  17
034E:  BNZ   0364
.................... 		uptimeTicks=0;
0350:  CLRF   xDE
0352:  CLRF   xDD
.................... 		if ( current.uptime_minutes < 65535 ) 
0354:  INCFSZ x90,W
0356:  BRA    035E
0358:  INCFSZ x91,W
035A:  BRA    035E
035C:  BRA    0364
.................... 			current.uptime_minutes++;
035E:  INCF   x90,F
0360:  BTFSC  FD8.2
0362:  INCF   x91,F
.................... 	}
.................... 
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
0364:  MOVF   xDB,F
0366:  BNZ   036E
.................... 		output_low(LED_GREEN);
0368:  BCF    F93.5
036A:  BCF    F8A.5
.................... 	} else {
036C:  BRA    0374
.................... 		output_high(LED_GREEN);
036E:  BCF    F93.5
0370:  BSF    F8A.5
.................... 		timers.led_on_green--;
0372:  DECF   xDB,F
.................... 	}
.................... 
.................... 	if ( 0==timers.led_on_red ) {
0374:  MOVF   xDC,F
0376:  BNZ   037A
.................... //		output_low(LED_RED);
.................... 	} else {
0378:  BRA    037C
.................... //		output_high(LED_RED);
.................... 		timers.led_on_red--;
037A:  DECF   xDC,F
.................... 	}
.................... }
.................... 
037C:  BCF    FA1.1
037E:  GOTO   0084
.................... #int_rda2
.................... /* any character on FTDI serial port (UART2) will case a reset */
.................... void ftdi_isr(void) {
.................... 	current.restart_now=fgetc(STREAM_WORLD);
*
039A:  BRA    0382
039C:  MOVFF  01,D9
.................... //	current.restart_now=1;
.................... }
.................... 
.................... #include "param_dcswcI2C.c"
03A0:  BCF    FA4.5
03A2:  GOTO   0084
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0818:  MOVF   x2A,W
081A:  XORWF  x2B,W
081C:  MOVWF  01
*
0866:  MOVF   x2A,W
0868:  XORWF  x2B,W
086A:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
07AC:  MOVLB  6
07AE:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
07B0:  MOVFF  625,628
07B4:  MOVF   x24,W
07B6:  BTFSC  FD8.2
07B8:  DECF   x25,F
07BA:  DECF   x24,F
07BC:  MOVWF  x27
07BE:  MOVF   x27,F
07C0:  BNZ   07C6
07C2:  MOVF   x28,F
07C4:  BZ    082A
.................... 		*data = read_eeprom( address++ );
07C6:  MOVFF  623,03
07CA:  MOVF   x22,W
07CC:  MOVWF  FE9
07CE:  MOVFF  03,FEA
07D2:  MOVF   x21,W
07D4:  MOVWF  03
07D6:  MOVF   x20,W
07D8:  INCF   x20,F
07DA:  BTFSC  FD8.2
07DC:  INCF   x21,F
07DE:  MOVWF  x29
07E0:  MOVFF  03,62A
07E4:  MOVFF  FF2,62B
07E8:  BCF    FF2.7
07EA:  MOVFF  62A,F75
07EE:  MOVFF  629,F74
07F2:  BCF    F7F.6
07F4:  BCF    F7F.7
07F6:  BSF    F7F.0
07F8:  MOVF   F73,W
07FA:  BTFSC  x2B.7
07FC:  BSF    FF2.7
07FE:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0800:  MOVFF  623,03
0804:  MOVF   x22,W
0806:  MOVWF  FE9
0808:  MOVFF  03,FEA
080C:  MOVFF  FEF,627
0810:  MOVFF  626,62A
0814:  MOVFF  627,62B
*
081E:  MOVFF  01,626
.................... 		data++;
0822:  INCF   x22,F
0824:  BTFSC  FD8.2
0826:  INCF   x23,F
0828:  BRA    07B0
.................... 	}
.................... 	return crc;
082A:  MOVFF  626,01
082E:  MOVLB  0
0830:  GOTO   0B5C (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
0834:  MOVLB  6
0836:  CLRF   x28
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0838:  MOVFF  627,62A
083C:  MOVF   x26,W
083E:  BTFSC  FD8.2
0840:  DECF   x27,F
0842:  DECF   x26,F
0844:  MOVWF  x29
0846:  MOVF   x29,F
0848:  BNZ   084E
084A:  MOVF   x2A,F
084C:  BZ    08CA
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
084E:  MOVFF  625,03
0852:  MOVF   x24,W
0854:  MOVWF  FE9
0856:  MOVFF  03,FEA
085A:  MOVFF  FEF,629
085E:  MOVFF  628,62A
0862:  MOVFF  629,62B
*
086C:  MOVFF  01,628
.................... 		write_eeprom( address++, *data++ );
0870:  MOVF   x23,W
0872:  MOVWF  03
0874:  MOVF   x22,W
0876:  INCF   x22,F
0878:  BTFSC  FD8.2
087A:  INCF   x23,F
087C:  MOVWF  x29
087E:  MOVFF  03,62A
0882:  MOVF   x25,W
0884:  MOVWF  03
0886:  MOVF   x24,W
0888:  INCF   x24,F
088A:  BTFSC  FD8.2
088C:  INCF   x25,F
088E:  MOVWF  FE9
0890:  MOVFF  03,FEA
0894:  MOVFF  FEF,62B
0898:  MOVF   FF2,W
089A:  MOVWF  00
089C:  BCF    FF2.7
089E:  MOVFF  62A,F75
08A2:  MOVFF  629,F74
08A6:  MOVFF  62B,F73
08AA:  BCF    F7F.6
08AC:  BCF    F7F.7
08AE:  BSF    F7F.2
08B0:  MOVLB  F
08B2:  MOVLW  55
08B4:  MOVWF  F7E
08B6:  MOVLW  AA
08B8:  MOVWF  F7E
08BA:  BSF    F7F.1
08BC:  BTFSC  F7F.1
08BE:  BRA    08BC
08C0:  BCF    F7F.2
08C2:  MOVF   00,W
08C4:  IORWF  FF2,F
08C6:  MOVLB  6
08C8:  BRA    0838
.................... 	}
.................... 
.................... 	return crc;
08CA:  MOVFF  628,01
08CE:  MOVLB  0
08D0:  GOTO   08F0 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
08D4:  MOVLB  6
08D6:  MOVLW  21
08D8:  MOVWF  x20
08DA:  CLRF   x23
08DC:  MOVLW  02
08DE:  MOVWF  x22
08E0:  CLRF   x25
08E2:  MOVFF  620,624
08E6:  CLRF   x27
08E8:  MOVLW  67
08EA:  MOVWF  x26
08EC:  MOVLB  0
08EE:  BRA    0834
08F0:  MOVFF  01,61F
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
08F4:  MOVF   FF2,W
08F6:  MOVWF  00
08F8:  BCF    FF2.7
08FA:  CLRF   F75
08FC:  CLRF   F74
08FE:  MOVFF  61F,F73
0902:  BCF    F7F.6
0904:  BCF    F7F.7
0906:  BSF    F7F.2
0908:  MOVLB  F
090A:  MOVLW  55
090C:  MOVWF  F7E
090E:  MOVLW  AA
0910:  MOVWF  F7E
0912:  BSF    F7F.1
0914:  BTFSC  F7F.1
0916:  BRA    0914
0918:  BCF    F7F.2
091A:  MOVF   00,W
091C:  IORWF  FF2,F
091E:  MOVLB  0
0920:  GOTO   0B3E (RETURN)
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0924:  MOVLW  96
0926:  MOVWF  xDB
.................... 
.................... 	config.revision='a';
0928:  MOVLW  61
092A:  MOVWF  21
.................... 
.................... 	config.modbus_address=37;
092C:  MOVLW  25
092E:  MOVWF  22
.................... 	config.modbus_mode=MODBUS_MODE_RTU;
0930:  CLRF   23
.................... 
.................... 	config.serial_prefix=SERIAL_PREFIX_DEFAULT;
0932:  MOVLW  5A
0934:  MOVWF  24
.................... 	config.serial_number=SERIAL_NUMBER_DEFAULT;
0936:  MOVLW  08
0938:  MOVWF  26
093A:  MOVLW  AD
093C:  MOVWF  25
.................... 
.................... 	/* initialize the channel configurations */
.................... 	for ( i=0 ; i<5 ; i++ ) {
093E:  MOVLB  6
0940:  CLRF   x1E
0942:  MOVF   x1E,W
0944:  SUBLW  04
0946:  BTFSS  FD8.0
0948:  BRA    0B1E
.................... 		config.ch[i].startup=0;
094A:  MOVF   x1E,W
094C:  MULLW  10
094E:  MOVF   FF3,W
0950:  CLRF   03
0952:  ADDLW  27
0954:  MOVWF  FE9
0956:  MOVLW  00
0958:  ADDWFC 03,W
095A:  MOVWF  FEA
095C:  CLRF   FEF
.................... 
.................... 		config.ch[i].adc_channel=i*2;
095E:  MOVF   x1E,W
0960:  MULLW  10
0962:  MOVF   FF3,W
0964:  CLRF   03
0966:  ADDLW  06
0968:  MOVWF  x1F
096A:  MOVLW  00
096C:  ADDWFC 03,W
096E:  MOVWF  x20
0970:  MOVLW  0E
0972:  ADDWF  x1F,W
0974:  MOVWF  01
0976:  MOVLW  00
0978:  ADDWFC x20,W
097A:  MOVWF  03
097C:  MOVF   01,W
097E:  ADDLW  21
0980:  MOVWF  FE9
0982:  MOVLW  00
0984:  ADDWFC 03,W
0986:  MOVWF  FEA
0988:  BCF    FD8.0
098A:  RLCF   x1E,W
098C:  MOVWF  FEF
.................... 		config.ch[i].off_below_adc=500;
098E:  MOVF   x1E,W
0990:  MULLW  10
0992:  MOVF   FF3,W
0994:  CLRF   03
0996:  ADDLW  06
0998:  MOVWF  x1F
099A:  MOVLW  00
099C:  ADDWFC 03,W
099E:  MOVWF  x20
09A0:  MOVLW  01
09A2:  ADDWF  x1F,W
09A4:  MOVWF  01
09A6:  MOVLW  00
09A8:  ADDWFC x20,W
09AA:  MOVWF  03
09AC:  MOVF   01,W
09AE:  ADDLW  21
09B0:  MOVWF  FE9
09B2:  MOVLW  00
09B4:  ADDWFC 03,W
09B6:  MOVWF  FEA
09B8:  MOVLW  01
09BA:  MOVWF  FEC
09BC:  MOVF   FED,F
09BE:  MOVLW  F4
09C0:  MOVWF  FEF
.................... 		config.ch[i].off_below_delay=500;
09C2:  MOVF   x1E,W
09C4:  MULLW  10
09C6:  MOVF   FF3,W
09C8:  CLRF   03
09CA:  ADDLW  06
09CC:  MOVWF  x1F
09CE:  MOVLW  00
09D0:  ADDWFC 03,W
09D2:  MOVWF  x20
09D4:  MOVLW  03
09D6:  ADDWF  x1F,W
09D8:  MOVWF  01
09DA:  MOVLW  00
09DC:  ADDWFC x20,W
09DE:  MOVWF  03
09E0:  MOVF   01,W
09E2:  ADDLW  21
09E4:  MOVWF  FE9
09E6:  MOVLW  00
09E8:  ADDWFC 03,W
09EA:  MOVWF  FEA
09EC:  MOVLW  01
09EE:  MOVWF  FEC
09F0:  MOVF   FED,F
09F2:  MOVLW  F4
09F4:  MOVWF  FEF
.................... 		config.ch[i].on_above_adc=700;
09F6:  MOVF   x1E,W
09F8:  MULLW  10
09FA:  MOVF   FF3,W
09FC:  CLRF   03
09FE:  ADDLW  06
0A00:  MOVWF  x1F
0A02:  MOVLW  00
0A04:  ADDWFC 03,W
0A06:  MOVWF  x20
0A08:  MOVLW  05
0A0A:  ADDWF  x1F,W
0A0C:  MOVWF  01
0A0E:  MOVLW  00
0A10:  ADDWFC x20,W
0A12:  MOVWF  03
0A14:  MOVF   01,W
0A16:  ADDLW  21
0A18:  MOVWF  FE9
0A1A:  MOVLW  00
0A1C:  ADDWFC 03,W
0A1E:  MOVWF  FEA
0A20:  MOVLW  02
0A22:  MOVWF  FEC
0A24:  MOVF   FED,F
0A26:  MOVLW  BC
0A28:  MOVWF  FEF
.................... 		config.ch[i].on_above_delay=1000;
0A2A:  MOVF   x1E,W
0A2C:  MULLW  10
0A2E:  MOVF   FF3,W
0A30:  CLRF   03
0A32:  ADDLW  06
0A34:  MOVWF  x1F
0A36:  MOVLW  00
0A38:  ADDWFC 03,W
0A3A:  MOVWF  x20
0A3C:  MOVLW  07
0A3E:  ADDWF  x1F,W
0A40:  MOVWF  01
0A42:  MOVLW  00
0A44:  ADDWFC x20,W
0A46:  MOVWF  03
0A48:  MOVF   01,W
0A4A:  ADDLW  21
0A4C:  MOVWF  FE9
0A4E:  MOVLW  00
0A50:  ADDWFC 03,W
0A52:  MOVWF  FEA
0A54:  MOVLW  03
0A56:  MOVWF  FEC
0A58:  MOVF   FED,F
0A5A:  MOVLW  E8
0A5C:  MOVWF  FEF
.................... 
.................... 		config.ch[i].override_timeout=300;
0A5E:  MOVF   x1E,W
0A60:  MULLW  10
0A62:  MOVF   FF3,W
0A64:  CLRF   03
0A66:  ADDLW  06
0A68:  MOVWF  x1F
0A6A:  MOVLW  00
0A6C:  ADDWFC 03,W
0A6E:  MOVWF  x20
0A70:  MOVLW  09
0A72:  ADDWF  x1F,W
0A74:  MOVWF  01
0A76:  MOVLW  00
0A78:  ADDWFC x20,W
0A7A:  MOVWF  03
0A7C:  MOVF   01,W
0A7E:  ADDLW  21
0A80:  MOVWF  FE9
0A82:  MOVLW  00
0A84:  ADDWFC 03,W
0A86:  MOVWF  FEA
0A88:  MOVLW  01
0A8A:  MOVWF  FEC
0A8C:  MOVF   FED,F
0A8E:  MOVLW  2C
0A90:  MOVWF  FEF
.................... 
.................... 		config.ch[i].switch_type=DCSW_FPF2700_ACS714;
0A92:  MOVF   x1E,W
0A94:  MULLW  10
0A96:  MOVF   FF3,W
0A98:  CLRF   03
0A9A:  ADDLW  06
0A9C:  MOVWF  x1F
0A9E:  MOVLW  00
0AA0:  ADDWFC 03,W
0AA2:  MOVWF  x20
0AA4:  MOVLW  0B
0AA6:  ADDWF  x1F,W
0AA8:  MOVWF  01
0AAA:  MOVLW  00
0AAC:  ADDWFC x20,W
0AAE:  MOVWF  03
0AB0:  MOVF   01,W
0AB2:  ADDLW  21
0AB4:  MOVWF  FE9
0AB6:  MOVLW  00
0AB8:  ADDWFC 03,W
0ABA:  MOVWF  FEA
0ABC:  CLRF   FEC
0ABE:  MOVF   FED,F
0AC0:  CLRF   FEF
.................... 		config.ch[i].i_mon_offset=0;
0AC2:  MOVF   x1E,W
0AC4:  MULLW  10
0AC6:  MOVF   FF3,W
0AC8:  CLRF   03
0ACA:  ADDLW  06
0ACC:  MOVWF  x1F
0ACE:  MOVLW  00
0AD0:  ADDWFC 03,W
0AD2:  MOVWF  x20
0AD4:  MOVLW  0D
0AD6:  ADDWF  x1F,W
0AD8:  MOVWF  01
0ADA:  MOVLW  00
0ADC:  ADDWFC x20,W
0ADE:  MOVWF  03
0AE0:  MOVF   01,W
0AE2:  ADDLW  21
0AE4:  MOVWF  FE9
0AE6:  MOVLW  00
0AE8:  ADDWFC 03,W
0AEA:  MOVWF  FEA
0AEC:  CLRF   FEF
.................... 		config.ch[i].invert=0;
0AEE:  MOVF   x1E,W
0AF0:  MULLW  10
0AF2:  MOVF   FF3,W
0AF4:  CLRF   03
0AF6:  ADDLW  06
0AF8:  MOVWF  x1F
0AFA:  MOVLW  00
0AFC:  ADDWFC 03,W
0AFE:  MOVWF  x20
0B00:  MOVLW  0F
0B02:  ADDWF  x1F,W
0B04:  MOVWF  01
0B06:  MOVLW  00
0B08:  ADDWFC x20,W
0B0A:  MOVWF  03
0B0C:  MOVF   01,W
0B0E:  ADDLW  21
0B10:  MOVWF  FE9
0B12:  MOVLW  00
0B14:  ADDWFC 03,W
0B16:  MOVWF  FEA
0B18:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* spanish fork */
.................... 	/*
.................... 		ch0 (A) - 12 volt bus
.................... 			off at 12.0 (adc=819 input=0) volts 60 second delay
.................... 
.................... 		ch1 (B) - 24 volt bus
.................... 			off at 24.0 (adc=1638 input=1) volts 60 second delay
.................... 
.................... 		ch2 (C) - Wind MPPT to 24 volt controller (unused)
.................... 			off at 24.0 (adc=1638 input=1) volts 60 second delay
.................... 		
.................... 		ch3 (D) - 48 volt LVD bus
.................... 			off at 48.0 (adc=3277 input=2) volts 60 second delay
.................... 
.................... 		ch4 (E) - wind MPPT to 48 volt controller (unused)
.................... 			off at 48.0 (adc=3277 input=3) volts 60 second delay
.................... 	*/
.................... 
.................... 	config.serial_prefix='A';
.................... 	config.serial_number=3387;
.................... 	config.modbus_address=50;
.................... 
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=0;
.................... 	config.ch[0].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[0].off_below_adc=819;
.................... 	config.ch[0].off_below_delay=6000;
.................... 	config.ch[0].on_above_adc=839;
.................... 	config.ch[0].on_above_delay=6000;
.................... 
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=2;
.................... 	config.ch[1].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[1].off_below_adc=1638;
.................... 	config.ch[1].off_below_delay=6000;
.................... 	config.ch[1].on_above_adc=1658;
.................... 	config.ch[1].on_above_delay=6000;
.................... 
.................... 	config.ch[2].startup=0;
.................... 	config.ch[2].adc_channel=2;
.................... 	config.ch[2].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[2].off_below_adc=1638;
.................... 	config.ch[2].off_below_delay=6000;
.................... 	config.ch[2].on_above_adc=1658;
.................... 	config.ch[2].on_above_delay=6000;
.................... 
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=4;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].off_below_adc=3277;
.................... 	config.ch[3].off_below_delay=6000;
.................... 	config.ch[3].on_above_adc=3297;
.................... 	config.ch[3].on_above_delay=6000;
.................... 
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=4;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].off_below_adc=3277;
.................... 	config.ch[4].off_below_delay=6000;
.................... 	config.ch[4].on_above_adc=3297;
.................... 	config.ch[4].on_above_delay=6000;
.................... 
.................... #endif
.................... 
.................... #if 0
.................... 	/* porcupine dome LVD */
.................... 	/*
.................... 	ch4 (top) - classic for kestrel
.................... 		off at 47.0 (adc=3209) volts with 60 second delay
.................... 	ch3 - DAS panel
.................... 		off at 47.5 (adc=3243) volts with 60 second delay
.................... 	ch2 - CAM panel
.................... 		off at 48.5 (adc=3311) volts with 60 second delay
.................... 	ch1 - inverter (satellite)
.................... 		off at 50.0 (adc=3413) volts with 300 second delay
.................... 	ch0 - heater for anemometer
.................... 		off at 54.0 (adc=3685) volts with 10 second delay
.................... 	*/
.................... 
.................... 	config.serial_prefix='A';
.................... 	config.serial_number=3420;
.................... 	config.modbus_address=50;
.................... 
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=0;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].off_below_adc=3209;
.................... 	config.ch[4].off_below_delay=6000;
.................... 	config.ch[4].on_above_adc=3229;
.................... 	config.ch[4].on_above_delay=6000;
.................... 
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=0;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].off_below_adc=3243;
.................... 	config.ch[3].off_below_delay=6000;
.................... 	config.ch[3].on_above_adc=3263;
.................... 	config.ch[3].on_above_delay=6000;
.................... 
.................... 	config.ch[2].startup=0;
.................... 	config.ch[2].adc_channel=0;
.................... 	config.ch[2].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[2].off_below_adc=3311;
.................... 	config.ch[2].off_below_delay=6000;
.................... 	config.ch[2].on_above_adc=3331;
.................... 	config.ch[2].on_above_delay=6000;
.................... 
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=0;
.................... 	config.ch[1].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[1].off_below_adc=3413;
.................... 	config.ch[1].off_below_delay=30000;
.................... 	config.ch[1].on_above_adc=3433;
.................... 	config.ch[1].on_above_delay=30000;
.................... 
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=0;
.................... 	config.ch[0].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[0].off_below_adc=3685;
.................... 	config.ch[0].off_below_delay=1000;
.................... 	config.ch[0].on_above_adc=3705;
.................... 	config.ch[0].on_above_delay=1000;
.................... 
.................... #endif
.................... 
.................... 
.................... #if 0
0B1A:  INCF   x1E,F
0B1C:  BRA    0942
.................... 	/* porcupine dome turbine stop controller */
.................... 	config.modbus_address=51;
.................... 
.................... 	/* 3 phase SSR for ? */
.................... 	config.ch[0].startup=0;
.................... 	config.ch[0].adc_channel=16;
.................... 	config.ch[0].switch_type=DCSW_FPF2700_ACS714;
.................... 	config.ch[0].invert=1;
.................... 
.................... 	/* 3 phase SSR for ? */
.................... 	config.ch[1].startup=0;
.................... 	config.ch[1].adc_channel=16;
.................... 	config.ch[1].switch_type=DCSW_FPF2700_ACS714;
.................... 	config.ch[1].invert=1;
.................... 
.................... 	/* unused */
.................... 
.................... 	/* 2 x latching contactor (to disconnect / stop) for ? */
.................... 	config.ch[3].startup=0;
.................... 	config.ch[3].adc_channel=16;
.................... 	config.ch[3].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[3].invert=0;
.................... 
.................... 	/* 2 x latching contactor (to disconnect / stop) for ? */
.................... 	config.ch[4].startup=0;
.................... 	config.ch[4].adc_channel=16;
.................... 	config.ch[4].switch_type=DCSW_LATCHING_CONTACTOR;
.................... 	config.ch[4].invert=0;
.................... #endif
.................... 
.................... 	for ( i=0 ; i<16 ; i++ ) {
0B1E:  CLRF   x1E
0B20:  MOVF   x1E,W
0B22:  SUBLW  0F
0B24:  BNC   0B3A
.................... 		config.adc_offset[i]=0;
0B26:  CLRF   03
0B28:  MOVF   x1E,W
0B2A:  ADDLW  77
0B2C:  MOVWF  FE9
0B2E:  MOVLW  00
0B30:  ADDWFC 03,W
0B32:  MOVWF  FEA
0B34:  CLRF   FEF
0B36:  INCF   x1E,F
0B38:  BRA    0B20
.................... 	}
.................... 
.................... 
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0B3A:  MOVLB  0
0B3C:  BRA    08D4
0B3E:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
0B40:  MOVLB  6
0B42:  MOVLW  21
0B44:  MOVWF  x1E
0B46:  CLRF   x21
0B48:  MOVLW  02
0B4A:  MOVWF  x20
0B4C:  CLRF   x23
0B4E:  MOVFF  61E,622
0B52:  CLRF   x25
0B54:  MOVLW  67
0B56:  MOVWF  x24
0B58:  MOVLB  0
0B5A:  BRA    07AC
0B5C:  MOVFF  01,61D
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) {
0B60:  MOVFF  FF2,61E
0B64:  BCF    FF2.7
0B66:  CLRF   F75
0B68:  CLRF   F74
0B6A:  BCF    F7F.6
0B6C:  BCF    F7F.7
0B6E:  BSF    F7F.0
0B70:  MOVF   F73,W
0B72:  MOVLB  6
0B74:  BTFSC  x1E.7
0B76:  BSF    FF2.7
0B78:  SUBWF  x1D,W
0B7A:  BNZ   0B88
0B7C:  MOVF   21,W
0B7E:  SUBLW  60
0B80:  BC    0B88
0B82:  MOVF   21,W
0B84:  SUBLW  7A
0B86:  BC    0B8E
.................... 		write_default_param_file();
0B88:  MOVLB  0
0B8A:  RCALL  0924
0B8C:  MOVLB  6
.................... 	}
0B8E:  MOVLB  0
0B90:  GOTO   128C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... #include "modbus_slave_dcswcI2C.c"
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us
.................... 
.................... 
.................... //#use rs232(baud=9600, UART1, parity=N, stream=MODBUS_SERIAL)
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... 
.................... void rcv_off(void) {
.................... 	output_high(RS485_DE);
.................... //	output_high(MODBUS_SERIAL_RX_ENABLE);
.................... 	disable_interrupts(INT_RDA);
.................... }
.................... 
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
0B94:  BTFSS  F9E.5
0B96:  BRA    0B9C
.................... 		fgetc(MODBUS_SERIAL);
0B98:  RCALL  03EA
0B9A:  BRA    0B94
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0B9C:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0B9E:  BCF    F94.5
0BA0:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0BA2:  BSF    F9D.5
0BA4:  GOTO   0BAA (RETURN)
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init() {
.................... //	output_low(MODBUS_SERIAL_ENABLE_PIN);
.................... 
.................... 	RCV_ON();
0BA8:  BRA    0B94
.................... 
.................... //	setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT);
0BAA:  MOVLW  C4
0BAC:  MOVWF  FD5
.................... 	enable_interrupts(GLOBAL);
0BAE:  MOVLW  C0
0BB0:  IORWF  FF2,F
0BB2:  GOTO   129E (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable) {
.................... 	disable_interrupts(INT_TIMER0);
*
03A6:  BCF    FF2.5
.................... 	if (enable) {
03A8:  MOVLB  6
03AA:  MOVF   x42,F
03AC:  BZ    03B6
.................... 		set_timer0(0);
03AE:  CLRF   FD7
03B0:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0);
03B2:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0);
03B4:  BSF    FF2.5
.................... 	}
03B6:  MOVLB  0
03B8:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer0
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
03BA:  MOVF   xE3,W
03BC:  SUBLW  02
03BE:  BNZ   03D4
03C0:  MOVF   xE4,F
03C2:  BNZ   03D4
03C4:  MOVF   xE5,F
03C6:  BNZ   03D4
03C8:  BTFSC  xE2.0
03CA:  BRA    03D4
....................    {
....................       modbus_rx.len-=2;
03CC:  MOVLW  02
03CE:  SUBWF  xE7,F
....................       modbus_serial_new=TRUE;
03D0:  BSF    xE2.0
....................    }
03D2:  BRA    03D6
....................    else
....................       modbus_serial_new=FALSE;
03D4:  BCF    xE2.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
03D6:  SETF   xE5
03D8:  SETF   xE4
....................    modbus_serial_state=MODBUS_GETADDY;
03DA:  CLRF   xE3
....................    modbus_enable_timeout(FALSE);
03DC:  MOVLB  6
03DE:  CLRF   x42
03E0:  MOVLB  0
03E2:  RCALL  03A6
03E4:  BCF    FF2.2
03E6:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   unsigned int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
0400:  MOVF   xE5,W
0402:  MOVLB  6
0404:  XORWF  x42,W
0406:  MOVWF  x43
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0408:  CLRF   03
040A:  MOVF   x43,W
040C:  MOVLB  0
040E:  RCALL  00D2
0410:  MOVWF  01
0412:  MOVF   xE4,W
0414:  XORWF  01,W
0416:  MOVWF  xE5
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0418:  CLRF   03
041A:  MOVLB  6
041C:  MOVF   x43,W
041E:  MOVLB  0
0420:  RCALL  01E2
0422:  MOVWF  xE4
0424:  GOTO   0478 (RETURN)
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c) {
.................... 	
.................... 	fputc(c, MODBUS_SERIAL);
.................... 	modbus_calc_crc(c);
.................... 	/* one stop bit delay */
.................... 	delay_us(104);
.................... 
.................... 	//delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #int_rda
.................... void incomming_modbus_serial() {
.................... 	int8 c;
.................... 
.................... 	c=fgetc(MODBUS_SERIAL);
0428:  RCALL  03EA
042A:  MOVFF  01,641
.................... 	if (!modbus_serial_new) {
042E:  BTFSC  xE2.0
0430:  BRA    0482
.................... 		if(modbus_serial_state == MODBUS_GETADDY) {
0432:  MOVF   xE3,F
0434:  BNZ   0446
.................... 			modbus_serial_crc.d = 0xFFFF;
0436:  SETF   xE5
0438:  SETF   xE4
.................... 			modbus_rx.address = c;
043A:  MOVFF  641,E6
.................... 			modbus_serial_state++;
043E:  INCF   xE3,F
.................... 			modbus_rx.len = 0;
0440:  CLRF   xE7
.................... 			modbus_rx.error=0;
0442:  CLRF   xE9
.................... 		} else if(modbus_serial_state == MODBUS_GETFUNC) {
0444:  BRA    0472
0446:  DECFSZ xE3,W
0448:  BRA    0452
.................... 			modbus_rx.func = c;
044A:  MOVFF  641,E8
.................... 			modbus_serial_state++;
044E:  INCF   xE3,F
.................... 		} else if(modbus_serial_state == MODBUS_GETDATA) {
0450:  BRA    0472
0452:  MOVF   xE3,W
0454:  SUBLW  02
0456:  BNZ   0472
.................... 			if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {
0458:  INCFSZ xE7,W
045A:  BRA    0460
.................... 				modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;
045C:  MOVLW  FE
045E:  MOVWF  xE7
.................... 			}
.................... 			modbus_rx.data[modbus_rx.len]=c;
0460:  MOVLW  EA
0462:  ADDWF  xE7,W
0464:  MOVWF  FE9
0466:  CLRF   FEA
0468:  BTFSC  FD8.0
046A:  INCF   FEA,F
046C:  MOVFF  641,FEF
.................... 			modbus_rx.len++;
0470:  INCF   xE7,F
.................... 		}
.................... 
.................... 		modbus_calc_crc(c);
0472:  MOVFF  641,642
0476:  BRA    0400
.................... 		modbus_enable_timeout(TRUE);
0478:  MOVLW  01
047A:  MOVLB  6
047C:  MOVWF  x42
047E:  MOVLB  0
0480:  RCALL  03A6
.................... 	}
0482:  BCF    F9E.5
0484:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func) {
.................... 	modbus_serial_crc.d=0xFFFF;
.................... 	modbus_serial_new=FALSE;
.................... 
.................... 	rcv_off();
....................   
.................... 	// delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
.................... 	/* 3.5 character delay */
.................... 	delay_us(365);
.................... 
.................... 	modbus_serial_putc(to);
.................... 	modbus_serial_putc(func);
.................... }
.................... 
.................... void modbus_serial_send_stop() {
.................... 	int8 crc_low, crc_high;
.................... 
.................... 	crc_high=modbus_serial_crc.b[1];
.................... 	crc_low=modbus_serial_crc.b[0];
.................... 
.................... 	modbus_serial_putc(crc_high);
.................... 	modbus_serial_putc(crc_low);
.................... 
.................... 	/* wait for data to actually be sent */
.................... 	while ( ! TRMT );
....................     
.................... 	// delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
.................... 	delay_us(365);
.................... 	
.................... 	rcv_on();
.................... 
.................... 	modbus_serial_crc.d=0xFFFF;
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
....................       return FALSE;
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
....................       modbus_rx.len = 1;
....................    }
....................    modbus_serial_new=FALSE;
....................    return TRUE;
.................... }
.................... 
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... 
.................... #include "modbus_handler_dcswcI2C.c"
.................... #define MAX_COIL_REGISTER   4
.................... 
.................... #define MAX_STATUS_REGISTER 27
.................... #define MIN_CONFIG_REGISTER 1000
.................... #define MAX_CONFIG_REGISTER 1088
.................... 
.................... 
.................... void reset_modbus_stats(void) {
.................... 	current.modbus_our_packets=0;
.................... 	current.modbus_other_packets=0;
.................... 	current.modbus_last_error=0;
.................... }
.................... 
.................... 
.................... int16 map_modbus(int16 addr) {
.................... 	int16 l;
.................... 	int8 ch;
.................... 
.................... 	/* channel config registers */
.................... 	if ( addr >= 1008 && addr <= 1088 ) {
.................... 		/* subtract offset */
.................... 		addr = (addr-1008);
.................... 		/* mod 16 (block size) for channel */
.................... 		ch = ((int8) addr)>>4;
.................... 		/* low nibble is the address */
.................... 		addr = ((int8) addr) & 0x0f;
.................... 
.................... 		switch ( addr ) {
.................... 			case 0: return config.ch[ch].startup;
.................... 			case 1: return config.ch[ch].off_below_adc;
.................... 			case 2: return config.ch[ch].off_below_delay;
.................... 			case 3: return config.ch[ch].on_above_adc;
.................... 			case 4: return config.ch[ch].on_above_delay;
.................... 			case 5: return config.ch[ch].override_timeout;
.................... 			case 6: return config.ch[ch].switch_type;
.................... 			case 7: return config.ch[ch].i_mon_offset;
.................... 			case 8: return config.ch[ch].adc_channel;
.................... 			case 9: return config.ch[ch].invert;
.................... 		}
.................... 
.................... 		/* if reserved space then return all bits set */
.................... 		return 0xffff;		
.................... 	}
.................... 
.................... 	switch ( addr ) {
.................... 		case  0: return current.p_on[0];
.................... 		case  1: return current.p_on[1];
.................... 		case  2: return current.p_on[2];
.................... 		case  3: return current.p_on[3];
.................... 		case  4: return current.p_on[4];
.................... 
.................... 		case  5: // 0 
.................... 		case  6: // 1
.................... 		case  7: // 2
.................... 		case  8: // 3
.................... 		case  9: // 4
.................... 		case 10: // 5
.................... 		case 11: // 6
.................... 		case 12: // 7
.................... 		case 13: // 8
.................... 		case 14: // 9
.................... 		case 15: // 10
.................... 		case 16: // 11
.................... 		case 17: // 12
.................... 		case 18: // 13
.................... 		case 19: // 14
.................... 		case 20: // 15
.................... 				return current.adc[(int8) addr - 5];
.................... 
.................... 
.................... 		/* meta status */
.................... 		case 21: return current.sequence_number++;
.................... 		case 22: /* milliseconds since last query */
.................... 			l=current.interval_milliseconds;
.................... 			current.interval_milliseconds=0;
.................... 			return l; 
.................... 		case 23: return current.uptime_minutes; /* uptime  */
.................... 		/* modbus statistics */
.................... 		case 24: return current.modbus_our_packets;
.................... 		case 25: return current.modbus_other_packets;
.................... 		case 26: return current.modbus_last_error;
.................... 		/* 27 triggers a modbus statistics reset */
.................... 		case 27: reset_modbus_stats(); return 0;
.................... 
.................... 		/* configuration */
.................... 		case 1000: return config.serial_prefix;
.................... 		case 1001: return config.serial_number;
.................... 		case 1002: return 'D';
.................... 		case 1003: return 'C';
.................... 		case 1004: return 'S';
.................... 		case 1005: return 2;
.................... 		case 1006: return config.modbus_address;
.................... 		case 1007: return config.modbus_mode;
.................... 
.................... 		/* channel config blocks are handled above */
.................... 		/* case 1008 ... case 1088 */
.................... 
.................... 
.................... 
.................... 		/* we should have range checked, and never gotten here */
.................... 		default: return 65535;
.................... 	}
.................... 
.................... }
.................... 
.................... int8 modbus_valid_read_registers(int16 start, int16 end) {
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 )
.................... 		return 1;
.................... 	
.................... 	/* end is always start + at least one ... so no need to test for range starting at 0 */
.................... 	if ( end <= MAX_STATUS_REGISTER+1)
.................... 		return 1;
.................... 
.................... 	return 0;
.................... }
.................... 
.................... void modbus_read_register_response(int8 function, int8 address, int16 start_address, int16 register_count ) {
.................... 	int16 i;
.................... 	int16 l;
.................... 
.................... //	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 	modbus_serial_send_start(address, function);
.................... 	modbus_serial_putc(register_count*2);
.................... 
.................... 
.................... 	for( i=0 ; i<register_count ; i++ ) {
.................... 		l=map_modbus(start_address+i);
.................... 		modbus_serial_putc(make8(l,1));
....................   		modbus_serial_putc(make8(l,0));
.................... 	}
.................... 
.................... 	modbus_serial_send_stop();
.................... }
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception modbus_write_register(int16 address, int16 value) {
.................... 	int8 ch;
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( current.factory_unlocked ) {
.................... 		if ( 1000 == address ) {
.................... 			config.serial_prefix=value;
.................... 			return 0;
.................... 		} else if ( 1001 == address ) {
.................... 			config.serial_number=value;
.................... 			return 0;
.................... 		}
.................... 	}
.................... 	if ( address >= 1008 && address <= 1088 ) {
.................... 		/* subtract offset */
.................... 		address = (address-1008);
.................... 		/* mod 16 (block size) for channel */
.................... 		ch = ((int8) address)>>4;
.................... 		/* low nibble is the address */
.................... 		address = ((int8) address) & 0x0f;
.................... 
.................... 		switch ( address ) {
.................... 			/* 1008, 1024, 1040, 1056, 1072 */
.................... 			case 0: 
.................... 				if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].startup=(int8) value;
.................... 				break;
.................... 
.................... 			/* 1009, 1025, 1041, 1057, 1073 */
.................... 			case 1: 
.................... 				if ( value > 4096 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].off_below_adc=value;
.................... 				break;
.................... 
.................... 			/* 1010, 1026, 1042, 1058, 1074 */
.................... 			case 2: 
.................... 				config.ch[ch].off_below_delay=value;
.................... 				break;
.................... 
.................... 			/* 1011, 1027, 1043, 1059, 1075 */
.................... 			case 3: 
.................... 				if ( value > 4096 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].on_above_adc=value;
.................... 				break;
.................... 
.................... 			/* 1012, 1028, 1044, 1060, 1076 */
.................... 			case 4: 
.................... 				config.ch[ch].on_above_delay=value;
.................... 				break;
.................... 
.................... 			/* 1013, 1029, 1045, 1061, 1077 */
.................... 			case 5: 
.................... 				config.ch[ch].override_timeout=value;
.................... 				break;
.................... 
.................... 			/* 1014, 1030, 1046, 1062, 1078 */
.................... 			case 6: 
.................... 				config.ch[ch].switch_type=value;
.................... 				break;
.................... 
.................... 			/* 1015, 1031, 1047, 1063, 1079 */
.................... 			case 7: 
.................... 				if ( value > 255 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].i_mon_offset=(signed int8) value;
.................... 				break;
.................... 
.................... 			/* 1016, 1032, 1048, 1064, 1080 */
.................... 			case 8: 
.................... 				if ( value > 16 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].adc_channel=(int8) value;
.................... 				break;
.................... 
.................... 			/* 1017, 1033, 1049, 1065, 1081 */
.................... 			case 9: 
.................... 				if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 				config.ch[ch].invert=(int8) value;
.................... 				break;
.................... 		}
.................... 
.................... 		/* no exception */
.................... 		return 0;		
.................... 	}
.................... 
.................... 
.................... 	/* publicly writeable addresses */
.................... 	switch ( address ) {
.................... 		case 0:
.................... 		case 1:
.................... 		case 2:
.................... 		case 3:
.................... 		case 4:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			current.p_on[(int8) address]=value;
.................... 			/* set counter that will be decremented in decision loop */
.................... 			current.override_timeout[(int8) address]=config.ch[(int8) address].override_timeout;
.................... 			break;
.................... 
.................... 		case 1006:
.................... 			/* Modbus address {0 to 127} */
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE;
.................... 			config.modbus_address=value;
.................... 			break;
.................... 		case 1007:
.................... 			/* Modbus mode {0,1} */
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.modbus_mode=value;
.................... 			break;
.................... 
.................... 
.................... #if 0
.................... 		/* inital state of the outputs */
.................... 		case 1008:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[0]=value;
.................... 			break;
.................... 		case 1009:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[1]=value;
.................... 			break;
.................... 		case 1010:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[2]=value;
.................... 			break;
.................... 		case 1011:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[3]=value;
.................... 			break;
.................... 		case 1012:
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE;
.................... 			config.p_startup[4]=value;
.................... 			break;
.................... #endif
.................... 
.................... 
.................... 		/* control */
.................... 		case 1997:
.................... 			/* reset now, won't acknowledge */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			reset_cpu();
.................... 			break;
.................... 		case 1998:
.................... 			/* write default config to EEPROM */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			write_default_param_file();
.................... 			break;
.................... 		case 1999:
.................... 			/* write config to EEPROM */
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE;
.................... 			write_param_file();
.................... 			break;
.................... 		case 19999:
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */
.................... 			if ( 1802 != value ) {
.................... 				current.factory_unlocked=0;
.................... 				return ILLEGAL_DATA_VALUE;
.................... 			}
.................... 			current.factory_unlocked=1;
.................... 			/* green LED for 2 seconds */
.................... 			timers.led_on_green=200;
.................... 			timers.led_on_red=0;
.................... 			break;
.................... 		default:
.................... 			return ILLEGAL_DATA_ADDRESS;
.................... 
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
.................... }
.................... 
.................... void modbus_process(void) {
.................... 	int16 start_addr;
.................... 	int16 num_registers;
.................... 	exception result;
.................... 	int8 i;
.................... 
.................... 
.................... 	/* check for message */
.................... 	if ( modbus_kbhit() ) {
.................... 		/* check if it is addressed to us */
.................... 		if ( modbus_rx.address==config.modbus_address ) {
.................... 			/* Modbus statistics */
.................... 			if ( current.modbus_our_packets < 65535 )
.................... 				current.modbus_our_packets++;
.................... 	
.................... 			/* green LED for 200 milliseconds */
.................... 			timers.led_on_green=20;
.................... 			timers.led_on_red=0;
.................... 
.................... 			switch(modbus_rx.func) {
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]);
.................... 	
.................... 					/* make sure our address is within range */
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					} else {
.................... 						modbus_read_register_response(modbus_rx.func,config.modbus_address,start_addr,num_registers);
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_SINGLE_COIL: /* 5 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 
.................... 					if ( start_addr <= MAX_COIL_REGISTER && modbus_rx.data[2]==0xFF && modbus_rx.data[3]==0x00 ) {
.................... 						/* turn on */
.................... 						modbus_write_register(start_addr, 1);
.................... 					} else if ( start_addr <= MAX_COIL_REGISTER && modbus_rx.data[2]==0x00 && modbus_rx.data[3]==0x00 ) {
.................... 						/* turn off */
.................... 						modbus_write_register(start_addr, 0);
.................... 					} else if ( start_addr > MAX_COIL_REGISTER ) {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
.................... 						current.modbus_last_error=ILLEGAL_DATA_ADDRESS;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					} else {
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_VALUE);
.................... 						current.modbus_last_error=ILLEGAL_DATA_VALUE;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 
.................... 					/* try the write */
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3]));
.................... 
.................... 					if ( result ) {
.................... 						/* exception */
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result);
.................... 						current.modbus_last_error=result;
.................... 
.................... 						/* red LED for 1 second */
.................... 						timers.led_on_red=100;
.................... 						timers.led_on_green=0;
.................... 					}  else {
.................... 						/* no exception, send ack */
.................... 						modbus_write_single_register_rsp(config.modbus_address,
.................... 							start_addr,
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3])
.................... 						);
.................... 					}
.................... 					break;
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]);
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]);
.................... 
.................... 					/* attempt to write each register. Stop if exception */
.................... 					for ( i=0 ; i<num_registers ; i++ ) {
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2]));
.................... 
.................... 						if ( result ) {
.................... 							/* exception */
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result);
.................... 							current.modbus_last_error=result;
.................... 	
.................... 							/* red LED for 1 second */
.................... 							timers.led_on_red=100;
.................... 							timers.led_on_green=0;
.................... 			
.................... 							break;
.................... 						}
.................... 					}
.................... 		
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */
.................... 					if ( 0 == result ) {
.................... 						/* no exception, send ack */
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers);
.................... 					}
.................... 
.................... 					break;  
.................... 				default:
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION);
.................... 					current.modbus_last_error=ILLEGAL_FUNCTION;
.................... 
.................... 					/* red led for 1 second */
.................... 					timers.led_on_red=100;
.................... 					timers.led_on_green=0;
.................... 			}
.................... 		} else {
.................... 			/* MODBUS packet for somebody else */
.................... 			if ( current.modbus_other_packets < 65535 )
.................... 				current.modbus_other_packets++;
.................... 
.................... 			/* yellow LED 200 milliseconds */
.................... 			timers.led_on_green=20;
.................... 			timers.led_on_red=20;
.................... 		}
.................... 	}
.................... }
.................... 
.................... 
.................... #include "filter_dcswcI2C.c"
.................... #define MEAN_FILTER_WIDTH    16
.................... #define MEAN_FILTER_CHANNELS 16
.................... 
.................... int16 mean_filter_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	static int8 num_elements[MEAN_FILTER_CHANNELS];
.................... 	int32 mean;
.................... 	int32 sum;
.................... 	int8 i;
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index[ch]] = latest_element;
*
0D44:  MOVLB  6
0D46:  CLRF   x2E
0D48:  MOVFF  621,62D
0D4C:  CLRF   x30
0D4E:  MOVLW  20
0D50:  MOVWF  x2F
0D52:  MOVLB  0
0D54:  RCALL  0C8C
0D56:  MOVFF  02,62E
0D5A:  MOVFF  01,62D
0D5E:  CLRF   03
0D60:  MOVLB  6
0D62:  MOVF   x21,W
0D64:  ADDLW  E9
0D66:  MOVWF  FE9
0D68:  MOVLW  03
0D6A:  ADDWFC 03,W
0D6C:  MOVWF  FEA
0D6E:  CLRF   03
0D70:  MOVFF  FEF,02
0D74:  BCF    FD8.0
0D76:  RLCF   02,F
0D78:  RLCF   03,F
0D7A:  MOVF   02,W
0D7C:  ADDWF  01,W
0D7E:  MOVWF  01
0D80:  MOVF   x2E,W
0D82:  ADDWFC 03,F
0D84:  MOVF   01,W
0D86:  ADDLW  E9
0D88:  MOVWF  FE9
0D8A:  MOVLW  01
0D8C:  ADDWFC 03,W
0D8E:  MOVWF  FEA
0D90:  MOVFF  623,FEC
0D94:  MOVF   FED,F
0D96:  MOVFF  622,FEF
.................... 	inbuf_index[ch]++;
0D9A:  CLRF   03
0D9C:  MOVF   x21,W
0D9E:  ADDLW  E9
0DA0:  MOVWF  FE9
0DA2:  MOVLW  03
0DA4:  ADDWFC 03,W
0DA6:  MOVWF  FEA
0DA8:  INCF   FEF,F
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
0DAA:  CLRF   03
0DAC:  MOVF   x21,W
0DAE:  ADDLW  E9
0DB0:  MOVWF  FE9
0DB2:  MOVLW  03
0DB4:  ADDWFC 03,W
0DB6:  MOVWF  FEA
0DB8:  MOVF   FEF,W
0DBA:  SUBLW  0F
0DBC:  BC    0DCE
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
0DBE:  CLRF   03
0DC0:  MOVF   x21,W
0DC2:  ADDLW  E9
0DC4:  MOVWF  FE9
0DC6:  MOVLW  03
0DC8:  ADDWFC 03,W
0DCA:  MOVWF  FEA
0DCC:  CLRF   FEF
.................... 
.................... 	if(num_elements[ch] < MEAN_FILTER_WIDTH)
0DCE:  CLRF   03
0DD0:  MOVF   x21,W
0DD2:  ADDLW  F9
0DD4:  MOVWF  FE9
0DD6:  MOVLW  03
0DD8:  ADDWFC 03,W
0DDA:  MOVWF  FEA
0DDC:  MOVF   FEF,W
0DDE:  SUBLW  0F
0DE0:  BNC   0DF2
.................... 	   num_elements[ch]++;
0DE2:  CLRF   03
0DE4:  MOVF   x21,W
0DE6:  ADDLW  F9
0DE8:  MOVWF  FE9
0DEA:  MOVLW  03
0DEC:  ADDWFC 03,W
0DEE:  MOVWF  FEA
0DF0:  INCF   FEF,F
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
0DF2:  CLRF   x2B
0DF4:  CLRF   x2A
0DF6:  CLRF   x29
0DF8:  CLRF   x28
.................... 	for(i = 0; i < num_elements[ch]; i++)
0DFA:  CLRF   x2C
0DFC:  CLRF   03
0DFE:  MOVF   x21,W
0E00:  ADDLW  F9
0E02:  MOVWF  FE9
0E04:  MOVLW  03
0E06:  ADDWFC 03,W
0E08:  MOVWF  FEA
0E0A:  MOVF   FEF,W
0E0C:  SUBWF  x2C,W
0E0E:  BC    0E64
.................... 		sum += input_buffer[ch][i];
0E10:  CLRF   x2E
0E12:  MOVFF  621,62D
0E16:  CLRF   x30
0E18:  MOVLW  20
0E1A:  MOVWF  x2F
0E1C:  MOVLB  0
0E1E:  RCALL  0C8C
0E20:  MOVFF  02,62E
0E24:  MOVFF  01,62D
0E28:  CLRF   03
0E2A:  MOVLB  6
0E2C:  MOVFF  62C,02
0E30:  BCF    FD8.0
0E32:  RLCF   02,F
0E34:  RLCF   03,F
0E36:  MOVF   02,W
0E38:  ADDWF  01,W
0E3A:  MOVWF  01
0E3C:  MOVF   x2E,W
0E3E:  ADDWFC 03,F
0E40:  MOVF   01,W
0E42:  ADDLW  E9
0E44:  MOVWF  FE9
0E46:  MOVLW  01
0E48:  ADDWFC 03,W
0E4A:  MOVWF  FEA
0E4C:  MOVFF  FEC,03
0E50:  MOVF   FED,F
0E52:  MOVF   FEF,W
0E54:  ADDWF  x28,F
0E56:  MOVF   03,W
0E58:  ADDWFC x29,F
0E5A:  MOVLW  00
0E5C:  ADDWFC x2A,F
0E5E:  ADDWFC x2B,F
0E60:  INCF   x2C,F
0E62:  BRA    0DFC
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... 	mean = (sum + (int32)(num_elements[ch] >> 1)) / num_elements[ch];
0E64:  CLRF   03
0E66:  MOVF   x21,W
0E68:  ADDLW  F9
0E6A:  MOVWF  FE9
0E6C:  MOVLW  03
0E6E:  ADDWFC 03,W
0E70:  MOVWF  FEA
0E72:  MOVFF  FEF,62D
0E76:  BCF    FD8.0
0E78:  RRCF   x2D,W
0E7A:  MOVWF  00
0E7C:  CLRF   01
0E7E:  CLRF   02
0E80:  CLRF   03
0E82:  MOVF   00,W
0E84:  ADDWF  x28,W
0E86:  MOVWF  x2D
0E88:  MOVF   01,W
0E8A:  ADDWFC x29,W
0E8C:  MOVWF  x2E
0E8E:  MOVF   02,W
0E90:  ADDWFC x2A,W
0E92:  MOVWF  x2F
0E94:  MOVF   03,W
0E96:  ADDWFC x2B,W
0E98:  MOVWF  x30
0E9A:  CLRF   03
0E9C:  MOVF   x21,W
0E9E:  ADDLW  F9
0EA0:  MOVWF  FE9
0EA2:  MOVLW  03
0EA4:  ADDWFC 03,W
0EA6:  MOVWF  FEA
0EA8:  MOVFF  FEF,638
0EAC:  MOVFF  FEA,633
0EB0:  MOVFF  FE9,632
0EB4:  BCF    FD8.1
0EB6:  MOVFF  630,637
0EBA:  MOVFF  62F,636
0EBE:  MOVFF  62E,635
0EC2:  MOVFF  62D,634
0EC6:  CLRF   x3B
0EC8:  CLRF   x3A
0ECA:  CLRF   x39
0ECC:  MOVLB  0
0ECE:  BRA    0CAE
0ED0:  MOVFF  633,FEA
0ED4:  MOVFF  632,FE9
0ED8:  MOVFF  03,627
0EDC:  MOVFF  02,626
0EE0:  MOVFF  01,625
0EE4:  MOVFF  00,624
.................... 
.................... 	return((int16)mean);
0EE8:  MOVLB  6
0EEA:  MOVFF  624,01
0EEE:  MOVFF  625,02
0EF2:  MOVLB  0
0EF4:  GOTO   1306 (RETURN)
.................... }
.................... 
.................... /* 
.................... special case of mean filter. For a 16 element filter, max value of 4096, and equal
.................... number of samples for each channel. Filter result doesn't become valid until at least
.................... 16 samples have been added
.................... */
.................... int16 mean_filter16_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	int16 sum;
.................... 	int16 min, max;
.................... 	int8 i;
.................... 
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index] = latest_element;
.................... 	inbuf_index[ch]++;
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	min=65535;
.................... 	max=0;
.................... 	sum = 0;
.................... 	for( i = 0; i < MEAN_FILTER_WIDTH ; i++ ) {
.................... 		sum += input_buffer[ch][i];
.................... 
.................... 		if ( input_buffer[ch][i] > max )
.................... 			max=input_buffer[ch][i];
.................... 		if ( input_buffer[ch][i] < min )
.................... 			min=input_buffer[ch][i];
.................... 	}
.................... 
.................... 	/* throw out the highest and lowest values */
.................... 	sum -= max;
.................... 	sum -= min;
.................... 
.................... 	return ( (sum+7) / 14 );
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... //	return ( (sum+8) >> 4 );
.................... }
.................... 
.................... 
.................... 
.................... void init() {
.................... 	int8 i;
.................... 
.................... 	setup_oscillator(OSC_8MHZ || OSC_INTRC); 
*
064E:  MOVLW  60
0650:  MOVWF  FD3
0652:  CLRF   F9B
0654:  CLRF   F64
.................... //	setup_adc(ADC_CLOCK_INTERNAL);
.................... 	setup_adc_ports(NO_ANALOGS);
0656:  MOVLB  F
0658:  MOVF   x5C,W
065A:  ANDLW  80
065C:  MOVWF  x5C
065E:  MOVLW  00
0660:  MOVWF  x5D
0662:  BCF    FC1.3
0664:  BCF    FC1.4
0666:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
0668:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
066A:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
066C:  MOVLW  1F
066E:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
0670:  MOVLW  F0
0672:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
0674:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
0676:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
0678:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
067A:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
067C:  BCF    F94.5
067E:  BCF    F8B.5
.................... 
.................... 	/* data structure initialization */
.................... 	timers.led_on_green=0;
0680:  MOVLB  0
0682:  CLRF   xDB
.................... 	timers.led_on_red=0;
0684:  CLRF   xDC
.................... 
.................... 	current.modbus_our_packets=0;
0686:  CLRF   x89
0688:  CLRF   x88
.................... 	current.modbus_other_packets=0;
068A:  CLRF   x8B
068C:  CLRF   x8A
.................... 	current.modbus_last_error=0;
068E:  CLRF   x8D
0690:  CLRF   x8C
.................... 	current.sequence_number=0;
0692:  CLRF   x8F
0694:  CLRF   x8E
.................... 	current.uptime_minutes=0;
0696:  CLRF   x91
0698:  CLRF   x90
.................... 	current.interval_milliseconds=0;
069A:  CLRF   x93
069C:  CLRF   x92
.................... 	current.factory_unlocked=0;
069E:  CLRF   x94
.................... 	current.restart_now=0;
06A0:  CLRF   xD9
.................... 
.................... 	for ( i=0 ; i<5 ; i++ ) {
06A2:  MOVLB  6
06A4:  CLRF   x1D
06A6:  MOVF   x1D,W
06A8:  SUBLW  04
06AA:  BNC   077E
.................... 		current.on_delay[i]=config.ch[i].on_above_delay;
06AC:  BCF    FD8.0
06AE:  RLCF   x1D,W
06B0:  CLRF   03
06B2:  ADDLW  BA
06B4:  MOVWF  01
06B6:  MOVLW  00
06B8:  ADDWFC 03,F
06BA:  MOVFF  01,61E
06BE:  MOVFF  03,61F
06C2:  MOVF   x1D,W
06C4:  MULLW  10
06C6:  MOVF   FF3,W
06C8:  CLRF   03
06CA:  ADDLW  06
06CC:  MOVWF  x20
06CE:  MOVLW  00
06D0:  ADDWFC 03,W
06D2:  MOVWF  x21
06D4:  MOVLW  07
06D6:  ADDWF  x20,W
06D8:  MOVWF  01
06DA:  MOVLW  00
06DC:  ADDWFC x21,W
06DE:  MOVWF  03
06E0:  MOVF   01,W
06E2:  ADDLW  21
06E4:  MOVWF  FE9
06E6:  MOVLW  00
06E8:  ADDWFC 03,W
06EA:  MOVWF  FEA
06EC:  MOVFF  FEC,03
06F0:  MOVF   FED,F
06F2:  MOVFF  FEF,620
06F6:  MOVFF  61F,FEA
06FA:  MOVFF  61E,FE9
06FE:  MOVFF  03,FEC
0702:  MOVF   FED,F
0704:  MOVFF  620,FEF
.................... 		current.off_delay[i]=config.ch[i].off_below_delay;
0708:  BCF    FD8.0
070A:  RLCF   x1D,W
070C:  CLRF   03
070E:  ADDLW  C4
0710:  MOVWF  01
0712:  MOVLW  00
0714:  ADDWFC 03,F
0716:  MOVFF  01,61E
071A:  MOVFF  03,61F
071E:  MOVF   x1D,W
0720:  MULLW  10
0722:  MOVF   FF3,W
0724:  CLRF   03
0726:  ADDLW  06
0728:  MOVWF  x20
072A:  MOVLW  00
072C:  ADDWFC 03,W
072E:  MOVWF  x21
0730:  MOVLW  03
0732:  ADDWF  x20,W
0734:  MOVWF  01
0736:  MOVLW  00
0738:  ADDWFC x21,W
073A:  MOVWF  03
073C:  MOVF   01,W
073E:  ADDLW  21
0740:  MOVWF  FE9
0742:  MOVLW  00
0744:  ADDWFC 03,W
0746:  MOVWF  FEA
0748:  MOVFF  FEC,03
074C:  MOVF   FED,F
074E:  MOVFF  FEF,620
0752:  MOVFF  61F,FEA
0756:  MOVFF  61E,FE9
075A:  MOVFF  03,FEC
075E:  MOVF   FED,F
0760:  MOVFF  620,FEF
.................... 		current.override_timeout[i]=0;
0764:  BCF    FD8.0
0766:  RLCF   x1D,W
0768:  CLRF   03
076A:  ADDLW  CE
076C:  MOVWF  FE9
076E:  MOVLW  00
0770:  ADDWFC 03,W
0772:  MOVWF  FEA
0774:  CLRF   FEC
0776:  MOVF   FED,F
0778:  CLRF   FEF
077A:  INCF   x1D,F
077C:  BRA    06A6
.................... 	}
.................... 
.................... 
.................... 
.................... 	/* interrupts */
.................... 	/* timer0 - Modbus slave timeout timer */
.................... 	/* configured in modbus_slave_sdc.c */
.................... 
.................... 	/* timer1 - unused */
.................... 
.................... 	/* timer2 - unused */
.................... 
.................... 	/* timer3 - general housekeeping Prescaler=1:1; TMR1 Preset=45536; Freq=100.00Hz; Period=10.00 ms */
.................... 	setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);
077E:  CLRF   FB0
0780:  MOVLW  07
0782:  MOVWF  FB1
.................... 	set_timer3(45536);
0784:  MOVLW  B1
0786:  MOVWF  FB3
0788:  MOVLW  E0
078A:  MOVWF  FB2
.................... 	enable_interrupts(INT_TIMER3);
078C:  BSF    FA0.1
.................... 
.................... 	/* timer4 - unused */
.................... 
.................... 	/* FTDI serial cable receive character */
.................... 	enable_interrupts(INT_RDA2);
078E:  BSF    FA3.5
.................... 
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
0790:  MOVLB  0
0792:  RCALL  054A
.................... 
.................... 
.................... 	/* initialize SCI UART @ 19200 */
.................... 	uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
0794:  MOVLW  06
0796:  MOVLB  6
0798:  MOVWF  x1E
079A:  MOVLB  0
079C:  BRA    05B0
.................... 
.................... 
.................... 	delay_ms(14);
079E:  MOVLW  0E
07A0:  MOVLB  6
07A2:  MOVWF  x1E
07A4:  MOVLB  0
07A6:  BRA    061C
07A8:  GOTO   128A (RETURN)
.................... 
.................... }
.................... 
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start();
*
10A6:  BSF    FC5.0
10A8:  BTFSC  FC5.0
10AA:  BRA    10A8
.................... 	status = i2c_write(address);  // Status = 0 if got an ACK
10AC:  MOVFF  61D,622
10B0:  CALL   0554
10B4:  MOVFF  01,61E
.................... 	i2c_stop();
10B8:  BSF    FC5.2
10BA:  BTFSC  FC5.2
10BC:  BRA    10BA
.................... 
.................... 	if ( 0 == status )
10BE:  MOVLB  6
10C0:  MOVF   x1E,F
10C2:  BNZ   10CA
.................... 		return TRUE;
10C4:  MOVLW  01
10C6:  MOVWF  01
10C8:  BRA    10CE
.................... 
....................    return FALSE;
10CA:  MOVLW  00
10CC:  MOVWF  01
10CE:  MOVLB  0
10D0:  RETURN 0
.................... }
.................... 
.................... void main(void) {
*
11CA:  CLRF   FF8
11CC:  BCF    FD0.7
11CE:  BSF    07.7
11D0:  MOVLW  62
11D2:  MOVWF  FD3
11D4:  CLRF   F9B
11D6:  CLRF   F64
11D8:  CLRF   20
11DA:  BCF    FA7.3
11DC:  MOVLW  0C
11DE:  MOVWF  FAF
11E0:  MOVLW  A2
11E2:  MOVWF  FAC
11E4:  MOVLW  90
11E6:  MOVWF  FAB
11E8:  BSF    FB9.3
11EA:  MOVLW  22
11EC:  MOVWF  F7B
11EE:  MOVLW  00
11F0:  MOVWF  F7C
11F2:  MOVLW  A6
11F4:  MOVWF  FBA
11F6:  MOVLW  90
11F8:  MOVWF  FA6
11FA:  BSF    F94.3
11FC:  BSF    F94.4
11FE:  MOVLW  04
1200:  MOVWF  FC8
1202:  MOVLW  28
1204:  MOVWF  FC6
1206:  BCF    FC7.7
1208:  BCF    FC7.6
120A:  BCF    xE2.0
120C:  CLRF   xE3
120E:  MOVLB  6
1210:  CLRF   x1A
1212:  CLRF   x19
1214:  MOVLB  F
1216:  MOVF   x5C,W
1218:  ANDLW  80
121A:  MOVWF  x5C
121C:  MOVLW  00
121E:  MOVWF  x5D
1220:  BCF    FC1.3
1222:  BCF    FC1.4
1224:  BCF    FC1.5
1226:  CLRF   x5E
1228:  CLRF   x5F
122A:  BRA    1246
122C:  DATA 02,00
122E:  DATA 1A,00
1230:  DATA 00,C1
1232:  DATA 40,21
1234:  DATA 00,FF
1236:  DATA 41,E9
1238:  DATA 00,FF
123A:  DATA C0,00
123C:  DATA FF,C0
123E:  DATA 00,FF
1240:  DATA C0,00
1242:  DATA 34,C0
1244:  DATA 00,00
1246:  MOVLW  00
1248:  MOVWF  FF8
124A:  MOVLW  12
124C:  MOVWF  FF7
124E:  MOVLW  2C
1250:  MOVWF  FF6
1252:  TBLRD*+
1254:  MOVF   FF5,W
1256:  MOVWF  00
1258:  XORLW  00
125A:  BZ    1282
125C:  TBLRD*+
125E:  MOVF   FF5,W
1260:  MOVWF  01
1262:  BTFSC  FE8.7
1264:  BRA    1270
1266:  ANDLW  3F
1268:  MOVWF  FEA
126A:  TBLRD*+
126C:  MOVFF  FF5,FE9
1270:  BTFSC  01.6
1272:  TBLRD*+
1274:  BTFSS  01.6
1276:  TBLRD*+
1278:  MOVFF  FF5,FEE
127C:  DCFSNZ 00,F
127E:  BRA    1252
1280:  BRA    1274
1282:  CLRF   FF8
.................... 	int8 i,j;
.................... 
.................... 	init();
1284:  MOVLB  0
1286:  GOTO   064E
.................... 	read_param_file();
128A:  BRA    0B40
.................... 
.................... 	if ( config.modbus_address > 127 ) {
128C:  MOVF   22,W
128E:  SUBLW  7F
1290:  BC    1296
.................... 		write_default_param_file();
1292:  CALL   0924
.................... 	}
.................... 
.................... 	/* start out Modbus slave */
.................... 	setup_uart(TRUE);
1296:  BSF    FAB.7
1298:  BSF    FAB.4
129A:  BSF    FAC.5
.................... 	/* modbus_init turns on global interrupts */
.................... 	modbus_init();
129C:  BRA    0BA8
.................... 	/* modbus initializes @ 9600 */
.................... 
.................... 	/* prime filters */
.................... 	for ( i=0 ; i<20 ; i++ ) {
129E:  MOVLB  6
12A0:  CLRF   x1B
12A2:  MOVF   x1B,W
12A4:  SUBLW  13
12A6:  BNC   1322
.................... 		for ( j=0 ; j<16 ; j++ ) {
12A8:  CLRF   x1C
12AA:  MOVF   x1C,W
12AC:  SUBLW  0F
12AE:  BNC   131E
.................... 			current.adc[j]=mean_filter_n(j,mcp3208_read(j) + config.adc_offset[j]);
12B0:  BCF    FD8.0
12B2:  RLCF   x1C,W
12B4:  CLRF   03
12B6:  ADDLW  9A
12B8:  MOVWF  01
12BA:  MOVLW  00
12BC:  ADDWFC 03,F
12BE:  MOVFF  01,61D
12C2:  MOVFF  03,61E
12C6:  MOVFF  61C,61F
12CA:  MOVLB  0
12CC:  BRA    0BB6
12CE:  MOVFF  02,620
12D2:  MOVFF  01,61F
12D6:  CLRF   03
12D8:  MOVLB  6
12DA:  MOVF   x1C,W
12DC:  ADDLW  77
12DE:  MOVWF  FE9
12E0:  MOVLW  00
12E2:  ADDWFC 03,W
12E4:  MOVWF  FEA
12E6:  MOVF   FEF,W
12E8:  CLRF   03
12EA:  MOVWF  00
12EC:  BTFSC  FE8.7
12EE:  DECF   03,F
12F0:  ADDWF  x1F,F
12F2:  MOVF   03,W
12F4:  ADDWFC x20,F
12F6:  MOVFF  61C,621
12FA:  MOVFF  620,623
12FE:  MOVFF  61F,622
1302:  MOVLB  0
1304:  BRA    0D44
1306:  MOVFF  61E,FEA
130A:  MOVFF  61D,FE9
130E:  MOVFF  02,FEC
1312:  MOVF   FED,F
1314:  MOVFF  01,FEF
1318:  MOVLB  6
131A:  INCF   x1C,F
131C:  BRA    12AA
.................... 		}
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... #if 1
131E:  INCF   x1B,F
1320:  BRA    12A2
.................... 	fprintf(STREAM_WORLD,"# dcswcI2C (%c%lu) start up (ds30 bootloader support) (worldData stream) (modbus address=%u) %s\r\n",
.................... 		config.serial_prefix,
.................... 		config.serial_number,
.................... 		config.modbus_address,
.................... 		__DATE__
.................... 	);
1322:  MOVLW  88
1324:  MOVWF  FF6
1326:  MOVLW  04
1328:  MOVWF  FF7
132A:  MOVLW  0C
132C:  MOVWF  x1E
132E:  MOVLB  0
1330:  RCALL  0EF8
1332:  MOVF   24,W
1334:  BTFSS  FA4.4
1336:  BRA    1334
1338:  MOVWF  F79
133A:  MOVLW  10
133C:  MOVWF  FE9
133E:  MOVFF  26,61E
1342:  MOVFF  25,61D
1346:  BRA    0F22
1348:  MOVLW  99
134A:  MOVWF  FF6
134C:  MOVLW  04
134E:  MOVWF  FF7
1350:  MOVLW  48
1352:  MOVLB  6
1354:  MOVWF  x1E
1356:  MOVLB  0
1358:  RCALL  0EF8
135A:  MOVFF  22,61D
135E:  MOVLW  1B
1360:  MOVLB  6
1362:  MOVWF  x1E
1364:  MOVLB  0
1366:  BRA    1004
1368:  MOVLW  29
136A:  BTFSS  FA4.4
136C:  BRA    136A
136E:  MOVWF  F79
1370:  MOVLW  20
1372:  BTFSS  FA4.4
1374:  BRA    1372
1376:  MOVWF  F79
1378:  MOVLW  EA
137A:  MOVWF  FF6
137C:  MOVLW  04
137E:  MOVWF  FF7
1380:  RCALL  1084
1382:  MOVLW  0D
1384:  BTFSS  FA4.4
1386:  BRA    1384
1388:  MOVWF  F79
138A:  MOVLW  0A
138C:  BTFSS  FA4.4
138E:  BRA    138C
1390:  MOVWF  F79
.................... #endif	
.................... 
.................... 
.................... #if 1
.................... 	/* scan I2C bus */
.................... 	for (i=0x10 ; i<0xF0 ; i+=2) {
1392:  MOVLW  10
1394:  MOVLB  6
1396:  MOVWF  x1B
1398:  MOVF   x1B,W
139A:  SUBLW  EF
139C:  BNC   13EE
.................... 		if ( get_ack_status(i) ) {
139E:  MOVFF  61B,61D
13A2:  MOVLB  0
13A4:  RCALL  10A6
13A6:  MOVF   01,F
13A8:  BZ    13E6
.................... 			fprintf(STREAM_WORLD,"# testing address 0x%02x ...",i);
13AA:  MOVLW  F4
13AC:  MOVWF  FF6
13AE:  MOVLW  04
13B0:  MOVWF  FF7
13B2:  MOVLW  14
13B4:  MOVLB  6
13B6:  MOVWF  x1E
13B8:  MOVLB  0
13BA:  RCALL  0EF8
13BC:  MOVFF  61B,61D
13C0:  MOVLW  57
13C2:  MOVLB  6
13C4:  MOVWF  x1E
13C6:  MOVLB  0
13C8:  BRA    10D2
13CA:  MOVLW  0C
13CC:  MOVWF  FF6
13CE:  MOVLW  05
13D0:  MOVWF  FF7
13D2:  MOVLW  04
13D4:  MOVLB  6
13D6:  MOVWF  x1E
13D8:  MOVLB  0
13DA:  RCALL  0EF8
.................... 			fprintf(STREAM_WORLD," got ack!\r\n");
13DC:  MOVLW  12
13DE:  MOVWF  FF6
13E0:  MOVLW  05
13E2:  MOVWF  FF7
13E4:  RCALL  1084
....................     	} else {
.................... //			fprintf(STREAM_FTDI," nothing\r\n");
.................... 		}
13E6:  MOVLW  02
13E8:  MOVLB  6
13EA:  ADDWF  x1B,F
13EC:  BRA    1398
....................    	}
.................... #endif
.................... 
.................... 
.................... 	config.uart_sc_sbd=get_ack_status(0x9a);
13EE:  MOVLW  9A
13F0:  MOVWF  x1D
13F2:  MOVLB  0
13F4:  RCALL  10A6
13F6:  MOVFF  01,87
.................... 
.................... 	timers.led_on_red=timers.led_on_green=0;
13FA:  CLRF   xDB
13FC:  MOVFF  DB,DC
.................... 
.................... #if 0
.................... 	/* set ports to their startup state */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		current.p_on[i]=config.ch[i].startup;
.................... 	}
.................... #endif
.................... 
.................... 
.................... 	i=0;
1400:  MOVLB  6
1402:  CLRF   x1B
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
1404:  CLRWDT
.................... 
.................... #if 0
.................... 		/* set the output bits to reflect their requested state */
.................... 		output_bit(CTRL_0,config.ch[0].invert ^ current.p_on[0]);
.................... 		output_bit(CTRL_1,config.ch[1].invert ^ current.p_on[1]);
.................... 		output_bit(CTRL_2,config.ch[2].invert ^ current.p_on[2]);
.................... 		output_bit(CTRL_3,config.ch[3].invert ^ current.p_on[3]);
.................... 		output_bit(CTRL_4,config.ch[4].invert ^ current.p_on[4]);
.................... 
.................... 		modbus_process();
.................... #endif
.................... 
.................... #if 0
.................... 		if ( current.adc_sample_ch != 0xff ) {
.................... 			/* read ADC (voltage) and add our offset */
.................... //			current.adc[current.adc_sample_ch]=mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch];
.................... 			current.adc[current.adc_sample_ch]=mean_filter_n(current.adc_sample_ch,mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch]);
.................... 	
.................... 			/* read the next channel (current) as soon as possible */
.................... 			current.adc_sample_ch++;
.................... //			current.adc[current.adc_sample_ch]=mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch];
.................... 			current.adc[current.adc_sample_ch]=mean_filter_n(current.adc_sample_ch,mcp3208_read(current.adc_sample_ch) + config.adc_offset[current.adc_sample_ch]);
.................... 
.................... 			/* wait until timer interrupt gives another sample flag */
.................... 			current.adc_sample_ch=0xff;
.................... 		}
.................... #endif
.................... 
.................... #if 0
.................... 		if ( current.decide_now ) {
.................... 			current.decide_now=0;
.................... 
.................... 			for ( i=0 ; i<5 ; i++ ) {
.................... 				if ( current.override_timeout[i] > 0 ) {
.................... 					current.override_timeout[i]--;
.................... 					continue;
.................... 				}
.................... 
.................... 				if ( config.ch[i].adc_channel < 15 && current.adc[config.ch[i].adc_channel] > config.ch[i].on_above_adc ) {
.................... 					if ( current.on_delay[i] > 0 ) {
.................... 						current.on_delay[i]--;
.................... 					} else {
.................... 						current.p_on[i]=1;
.................... 					}
.................... 				} else {
.................... 					current.on_delay[i]=config.ch[i].on_above_delay;
.................... 				}
.................... 			
.................... 
.................... 				if ( config.ch[i].adc_channel < 15 && current.adc[config.ch[i].adc_channel] < config.ch[i].off_below_adc ) {
.................... 					if ( current.off_delay[i] > 0 ) {
.................... 						current.off_delay[i]--;
.................... 					} else {
.................... 						current.p_on[i]=0;
.................... 					}
.................... 				} else {
.................... 					current.off_delay[i]=config.ch[i].off_below_delay;
.................... 				}
.................... 			}
.................... 		}
.................... #endif
.................... 
.................... 
.................... 
.................... 			if ( config.uart_sc_sbd && uart_kbhit() ) {
1406:  MOVLB  0
1408:  MOVF   x87,F
140A:  BZ    144C
140C:  BRA    11A4
140E:  MOVF   01,F
1410:  BZ    144C
.................... 				fprintf(STREAM_WORLD,"# RockBLOCK says: '%c'\r\n",uart_getc());	
*
141C:  MOVFF  01,61D
1420:  MOVLW  1E
1422:  MOVWF  FF6
1424:  MOVLW  05
1426:  MOVWF  FF7
1428:  MOVLW  13
142A:  MOVLB  6
142C:  MOVWF  x1E
142E:  MOVLB  0
1430:  RCALL  0EF8
1432:  MOVLB  6
1434:  MOVF   x1D,W
1436:  BTFSS  FA4.4
1438:  BRA    1436
143A:  MOVWF  F79
143C:  MOVLW  33
143E:  MOVWF  FF6
1440:  MOVLW  05
1442:  MOVWF  FF7
1444:  MOVLW  03
1446:  MOVWF  x1E
1448:  MOVLB  0
144A:  RCALL  0EF8
.................... 			}
.................... 			
.................... 
.................... 
.................... #if 1
.................... 		if ( current.restart_now ) {
144C:  MOVF   xD9,F
144E:  BZ    1490
.................... 			timers.led_on_green=200;
1450:  MOVLW  C8
1452:  MOVWF  xDB
.................... 			fprintf(STREAM_WORLD,"# you said '%c'\r\n",current.restart_now);
1454:  MOVLW  38
1456:  MOVWF  FF6
1458:  MOVLW  05
145A:  MOVWF  FF7
145C:  MOVLW  0C
145E:  MOVLB  6
1460:  MOVWF  x1E
1462:  MOVLB  0
1464:  RCALL  0EF8
1466:  MOVF   xD9,W
1468:  BTFSS  FA4.4
146A:  BRA    1468
146C:  MOVWF  F79
146E:  MOVLW  46
1470:  MOVWF  FF6
1472:  MOVLW  05
1474:  MOVWF  FF7
1476:  MOVLW  03
1478:  MOVLB  6
147A:  MOVWF  x1E
147C:  MOVLB  0
147E:  RCALL  0EF8
.................... 			if ( config.uart_sc_sbd ) {
1480:  MOVF   x87,F
1482:  BZ    148A
.................... 				uart_putc(current.restart_now);
1484:  MOVFF  D9,61D
1488:  BRA    11B8
.................... 			}
.................... 
.................... 			current.restart_now=0;
148A:  CLRF   xD9
.................... 			
.................... 
.................... 			output_toggle(CTRL_0);
148C:  BCF    F92.0
148E:  BTG    F89.0
.................... 
.................... 		}
.................... #endif
1490:  MOVLB  6
1492:  BRA    1404
.................... 
.................... 		
.................... 	}
.................... }
1494:  BRA    1494

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 3469   NOPUT NOBROWNOUT BORV27 ZPBORM NOWDT WDT8192
   Word  3: 0900   CANB MSSPMSK7
   Word  4: 0010   NOSTVREN BBSIZ2K DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E000   NOWRTC NOWRTB NOWRTD
   Word  7: 4000   NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
