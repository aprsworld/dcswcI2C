CCS PCH C Compiler, Version 5.090, 49113               06-Feb-22 19:27

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswcI2C\dcswcI2C.lst

               ROM used:   3952 bytes (12%)
                           Largest free fragment is 28812
               RAM used:   1169 (32%) at main() level
                           1201 (33%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   0C30
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.1
0056:  GOTO   0060
005A:  BTFSC  FA1.1
005C:  GOTO   00BA
0060:  BTFSS  FA3.5
0062:  GOTO   006C
0066:  BTFSC  FA4.5
0068:  GOTO   015E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswcI2C.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
*
016A:  DATA 23,20
016C:  DATA 64,63
016E:  DATA 73,77
0170:  DATA 63,49
0172:  DATA 32,43
0174:  DATA 20,28
0176:  DATA 25,63
0178:  DATA 25,6C
017A:  DATA 75,29
017C:  DATA 20,73
017E:  DATA 74,61
0180:  DATA 72,74
0182:  DATA 20,75
0184:  DATA 70,20
0186:  DATA 28,64
0188:  DATA 73,33
018A:  DATA 30,20
018C:  DATA 62,6F
018E:  DATA 6F,74
0190:  DATA 6C,6F
0192:  DATA 61,64
0194:  DATA 65,72
0196:  DATA 20,73
0198:  DATA 75,70
019A:  DATA 70,6F
019C:  DATA 72,74
019E:  DATA 29,20
01A0:  DATA 28,77
01A2:  DATA 6F,72
01A4:  DATA 6C,64
01A6:  DATA 44,61
01A8:  DATA 74,61
01AA:  DATA 20,73
01AC:  DATA 74,72
01AE:  DATA 65,61
01B0:  DATA 6D,29
01B2:  DATA 20,28
01B4:  DATA 6D,6F
01B6:  DATA 64,62
01B8:  DATA 75,73
01BA:  DATA 20,61
01BC:  DATA 64,64
01BE:  DATA 72,65
01C0:  DATA 73,73
01C2:  DATA 3D,25
01C4:  DATA 75,29
01C6:  DATA 20,25
01C8:  DATA 73,0D
01CA:  DATA 0A,00
01CC:  DATA 36,2D
01CE:  DATA 46,65
01D0:  DATA 62,2D
01D2:  DATA 32,32
01D4:  DATA 00,00
01D6:  DATA 23,20
01D8:  DATA 74,65
01DA:  DATA 73,74
01DC:  DATA 69,6E
01DE:  DATA 67,20
01E0:  DATA 61,64
01E2:  DATA 64,72
01E4:  DATA 65,73
01E6:  DATA 73,20
01E8:  DATA 30,78
01EA:  DATA 25,30
01EC:  DATA 32,78
01EE:  DATA 20,2E
01F0:  DATA 2E,2E
01F2:  DATA 00,00
01F4:  DATA 20,67
01F6:  DATA 6F,74
01F8:  DATA 20,61
01FA:  DATA 63,6B
01FC:  DATA 21,0D
01FE:  DATA 0A,00
0200:  DATA 23,20
0202:  DATA 52,6F
0204:  DATA 63,6B
0206:  DATA 42,4C
0208:  DATA 4F,43
020A:  DATA 4B,20
020C:  DATA 73,61
020E:  DATA 79,73
0210:  DATA 3A,20
0212:  DATA 27,25
0214:  DATA 63,27
0216:  DATA 0D,0A
0218:  DATA 00,00
021A:  DATA 23,20
021C:  DATA 79,6F
021E:  DATA 75,20
0220:  DATA 73,61
0222:  DATA 69,64
0224:  DATA 20,27
0226:  DATA 25,63
0228:  DATA 27,0D
022A:  DATA 0A,00
022C:  DATA 23,20
022E:  DATA 72,65
0230:  DATA 67,20
0232:  DATA 61,64
0234:  DATA 64,72
0236:  DATA 5B,30
0238:  DATA 78,25
023A:  DATA 30,32
023C:  DATA 78,5D
023E:  DATA 3D,30
0240:  DATA 78,25
0242:  DATA 30,34
0244:  DATA 6C,78
0246:  DATA 20,28
0248:  DATA 25,6C
024A:  DATA 75,29
024C:  DATA 0D,0A
024E:  DATA 00,00
*
0688:  MOVLB  4
068A:  MOVF   x9D,W
068C:  MULWF  x9F
068E:  MOVFF  FF3,01
0692:  MOVFF  FF4,00
0696:  MULWF  xA0
0698:  MOVF   FF3,W
069A:  ADDWF  00,F
069C:  MOVF   x9E,W
069E:  MULWF  x9F
06A0:  MOVF   FF3,W
06A2:  ADDWFC 00,W
06A4:  MOVWF  02
06A6:  MOVLB  0
06A8:  RETURN 0
06AA:  BTFSC  FD8.1
06AC:  BRA    06B6
06AE:  MOVLW  04
06B0:  MOVWF  FEA
06B2:  MOVLW  AC
06B4:  MOVWF  FE9
06B6:  CLRF   00
06B8:  CLRF   01
06BA:  CLRF   02
06BC:  CLRF   03
06BE:  MOVLB  4
06C0:  CLRF   xAC
06C2:  CLRF   xAD
06C4:  CLRF   xAE
06C6:  CLRF   xAF
06C8:  MOVF   xAB,W
06CA:  IORWF  xAA,W
06CC:  IORWF  xA9,W
06CE:  IORWF  xA8,W
06D0:  BZ    072A
06D2:  MOVLW  20
06D4:  MOVWF  xB0
06D6:  BCF    FD8.0
06D8:  RLCF   xA4,F
06DA:  RLCF   xA5,F
06DC:  RLCF   xA6,F
06DE:  RLCF   xA7,F
06E0:  RLCF   xAC,F
06E2:  RLCF   xAD,F
06E4:  RLCF   xAE,F
06E6:  RLCF   xAF,F
06E8:  MOVF   xAB,W
06EA:  SUBWF  xAF,W
06EC:  BNZ   06FE
06EE:  MOVF   xAA,W
06F0:  SUBWF  xAE,W
06F2:  BNZ   06FE
06F4:  MOVF   xA9,W
06F6:  SUBWF  xAD,W
06F8:  BNZ   06FE
06FA:  MOVF   xA8,W
06FC:  SUBWF  xAC,W
06FE:  BNC   071E
0700:  MOVF   xA8,W
0702:  SUBWF  xAC,F
0704:  MOVF   xA9,W
0706:  BTFSS  FD8.0
0708:  INCFSZ xA9,W
070A:  SUBWF  xAD,F
070C:  MOVF   xAA,W
070E:  BTFSS  FD8.0
0710:  INCFSZ xAA,W
0712:  SUBWF  xAE,F
0714:  MOVF   xAB,W
0716:  BTFSS  FD8.0
0718:  INCFSZ xAB,W
071A:  SUBWF  xAF,F
071C:  BSF    FD8.0
071E:  RLCF   00,F
0720:  RLCF   01,F
0722:  RLCF   02,F
0724:  RLCF   03,F
0726:  DECFSZ xB0,F
0728:  BRA    06D6
072A:  MOVFF  4AC,FEF
072E:  MOVFF  4AD,FEC
0732:  MOVFF  4AE,FEC
0736:  MOVFF  4AF,FEC
073A:  MOVLB  0
073C:  GOTO   08CC (RETURN)
*
08F4:  TBLRD*+
08F6:  MOVFF  FF6,48F
08FA:  MOVFF  FF7,490
08FE:  MOVF   FF5,W
0900:  BTFSS  FA4.4
0902:  BRA    0900
0904:  MOVWF  F79
0906:  MOVFF  48F,FF6
090A:  MOVFF  490,FF7
090E:  MOVLB  4
0910:  DECFSZ x8E,F
0912:  BRA    0916
0914:  BRA    091A
0916:  MOVLB  0
0918:  BRA    08F4
091A:  MOVLB  0
091C:  RETURN 0
091E:  MOVFF  FEA,495
0922:  MOVFF  FE9,494
0926:  MOVLB  4
0928:  SWAPF  x8E,W
092A:  IORLW  F0
092C:  MOVWF  x90
092E:  ADDWF  x90,F
0930:  ADDLW  E2
0932:  MOVWF  x91
0934:  ADDLW  32
0936:  MOVWF  x93
0938:  MOVF   x8E,W
093A:  ANDLW  0F
093C:  ADDWF  x91,F
093E:  ADDWF  x91,F
0940:  ADDWF  x93,F
0942:  ADDLW  E9
0944:  MOVWF  x92
0946:  ADDWF  x92,F
0948:  ADDWF  x92,F
094A:  SWAPF  x8D,W
094C:  ANDLW  0F
094E:  ADDWF  x92,F
0950:  ADDWF  x93,F
0952:  RLCF   x92,F
0954:  RLCF   x93,F
0956:  COMF   x93,F
0958:  RLCF   x93,F
095A:  MOVF   x8D,W
095C:  ANDLW  0F
095E:  ADDWF  x93,F
0960:  RLCF   x90,F
0962:  MOVLW  07
0964:  MOVWF  x8F
0966:  MOVLW  0A
0968:  DECF   x92,F
096A:  ADDWF  x93,F
096C:  BNC   0968
096E:  DECF   x91,F
0970:  ADDWF  x92,F
0972:  BNC   096E
0974:  DECF   x90,F
0976:  ADDWF  x91,F
0978:  BNC   0974
097A:  DECF   x8F,F
097C:  ADDWF  x90,F
097E:  BNC   097A
0980:  MOVLW  04
0982:  MOVWF  FEA
0984:  MOVLW  8F
0986:  MOVWF  FE9
0988:  MOVLW  07
098A:  ANDWF  x94,W
098C:  BCF    x94.6
098E:  ADDWF  FE9,F
0990:  MOVLW  00
0992:  ADDWFC FEA,F
0994:  MOVF   FE9,W
0996:  SUBLW  93
0998:  BNZ   09A2
099A:  MOVF   FEA,W
099C:  SUBLW  04
099E:  BNZ   09A2
09A0:  BSF    x94.6
09A2:  MOVF   FEF,W
09A4:  MOVWF  00
09A6:  BNZ   09B8
09A8:  BTFSC  x94.6
09AA:  BRA    09B8
09AC:  BTFSC  x94.4
09AE:  BRA    09C8
09B0:  BTFSC  x94.3
09B2:  BRA    09B8
09B4:  MOVLW  20
09B6:  BRA    09BE
09B8:  BSF    x94.3
09BA:  BCF    x94.4
09BC:  MOVLW  30
09BE:  ADDWF  00,F
09C0:  MOVF   00,W
09C2:  BTFSS  FA4.4
09C4:  BRA    09C2
09C6:  MOVWF  F79
09C8:  MOVF   FEE,W
09CA:  BTFSS  x94.6
09CC:  BRA    0994
09CE:  MOVLB  0
09D0:  RETURN 0
09D2:  MOVLB  4
09D4:  MOVF   x90,W
09D6:  CLRF   01
09D8:  SUBWF  x8F,W
09DA:  BC    09E2
09DC:  MOVFF  48F,00
09E0:  BRA    09FA
09E2:  CLRF   00
09E4:  MOVLW  08
09E6:  MOVWF  x91
09E8:  RLCF   x8F,F
09EA:  RLCF   00,F
09EC:  MOVF   x90,W
09EE:  SUBWF  00,W
09F0:  BTFSC  FD8.0
09F2:  MOVWF  00
09F4:  RLCF   01,F
09F6:  DECFSZ x91,F
09F8:  BRA    09E8
09FA:  MOVLB  0
09FC:  RETURN 0
09FE:  MOVF   01,W
0A00:  MOVFF  48D,48F
0A04:  MOVLW  64
0A06:  MOVLB  4
0A08:  MOVWF  x90
0A0A:  MOVLB  0
0A0C:  RCALL  09D2
0A0E:  MOVFF  00,48D
0A12:  MOVF   01,W
0A14:  MOVLW  30
0A16:  BNZ   0A28
0A18:  MOVLB  4
0A1A:  BTFSS  x8E.1
0A1C:  BRA    0A3A
0A1E:  BTFSC  x8E.3
0A20:  BRA    0A3A
0A22:  BTFSC  x8E.4
0A24:  MOVLW  20
0A26:  BRA    0A30
0A28:  MOVLB  4
0A2A:  BCF    x8E.3
0A2C:  BCF    x8E.4
0A2E:  BSF    x8E.0
0A30:  ADDWF  01,F
0A32:  MOVF   01,W
0A34:  BTFSS  FA4.4
0A36:  BRA    0A34
0A38:  MOVWF  F79
0A3A:  MOVFF  48D,48F
0A3E:  MOVLW  0A
0A40:  MOVWF  x90
0A42:  MOVLB  0
0A44:  RCALL  09D2
0A46:  MOVFF  00,48D
0A4A:  MOVF   01,W
0A4C:  MOVLW  30
0A4E:  BNZ   0A60
0A50:  MOVLB  4
0A52:  BTFSC  x8E.3
0A54:  BRA    0A6C
0A56:  BTFSS  x8E.0
0A58:  BRA    0A6C
0A5A:  BTFSC  x8E.4
0A5C:  MOVLW  20
0A5E:  MOVLB  0
0A60:  ADDWF  01,F
0A62:  MOVF   01,W
0A64:  BTFSS  FA4.4
0A66:  BRA    0A64
0A68:  MOVWF  F79
0A6A:  MOVLB  4
0A6C:  MOVLW  30
0A6E:  ADDWF  x8D,F
0A70:  MOVF   x8D,W
0A72:  BTFSS  FA4.4
0A74:  BRA    0A72
0A76:  MOVWF  F79
0A78:  MOVLB  0
0A7A:  GOTO   0D9A (RETURN)
0A7E:  TBLRD*+
0A80:  MOVF   FF5,F
0A82:  BZ    0A9E
0A84:  MOVFF  FF6,48D
0A88:  MOVFF  FF7,48E
0A8C:  MOVF   FF5,W
0A8E:  BTFSS  FA4.4
0A90:  BRA    0A8E
0A92:  MOVWF  F79
0A94:  MOVFF  48D,FF6
0A98:  MOVFF  48E,FF7
0A9C:  BRA    0A7E
0A9E:  RETURN 0
*
0ACC:  MOVLB  4
0ACE:  BTFSC  x8E.7
0AD0:  BRA    0AF2
0AD2:  MOVLW  0F
0AD4:  MOVWF  00
0AD6:  SWAPF  x8D,W
0AD8:  ANDWF  00,F
0ADA:  MOVLW  0A
0ADC:  SUBWF  00,W
0ADE:  BC    0AE6
0AE0:  MOVLW  30
0AE2:  ADDWF  00,F
0AE4:  BRA    0AEA
0AE6:  MOVF   x8E,W
0AE8:  ADDWF  00,F
0AEA:  MOVF   00,W
0AEC:  BTFSS  FA4.4
0AEE:  BRA    0AEC
0AF0:  MOVWF  F79
0AF2:  MOVLW  0F
0AF4:  ANDWF  x8D,F
0AF6:  MOVLW  0A
0AF8:  SUBWF  x8D,W
0AFA:  BC    0B00
0AFC:  MOVLW  30
0AFE:  BRA    0B04
0B00:  BCF    x8E.7
0B02:  MOVF   x8E,W
0B04:  ADDWF  x8D,F
0B06:  MOVF   x8D,W
0B08:  BTFSS  FA4.4
0B0A:  BRA    0B08
0B0C:  MOVWF  F79
0B0E:  MOVLB  0
0B10:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... 
.................... #if 1
.................... /* no boot loader */
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BORV30
.................... #fuses WDT32768
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... 
.................... #else
.................... 
.................... /* DS30 boot loader version 1.5.1 - engine 2.2.2 */
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */
.................... /* max mem address - 0x243, max mem address - 0x240 */
.................... #build(reset=0x7dbc:0x7dbf)
.................... /* max mem address - 0x23f, max mem address - see memory organization in datasheet */
.................... //#org 0x7dc0,0x7fff {}
.................... #org 0x7dc0,0x7fff {}
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
0322:  MOVLW  04
0324:  MOVWF  FEA
0326:  MOVLW  8D
0328:  MOVWF  FE9
032A:  MOVF   FEF,W
032C:  BZ    0350
032E:  MOVLW  02
0330:  MOVWF  01
0332:  MOVLW  BF
0334:  MOVWF  00
0336:  CLRWDT
0338:  DECFSZ 00,F
033A:  BRA    0336
033C:  DECFSZ 01,F
033E:  BRA    0332
0340:  MOVLW  96
0342:  MOVWF  00
0344:  DECFSZ 00,F
0346:  BRA    0344
0348:  BRA    034A
034A:  CLRWDT
034C:  DECFSZ FEF,F
034E:  BRA    032E
0350:  GOTO   03C4 (RETURN)
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x000
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... /* UART1 - RS-485 connection modbus */
.................... #use rs232(UART1,stream=MODBUS_SERIAL,baud=9600,xmit=PIN_C6,rcv=PIN_C7,errors)	
.................... 
.................... 
.................... #byte TXSTA=GETENV("SFR:txsta1")
.................... #bit  TRMT=TXSTA.1
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... #byte PORTB=GETENV("SFR:portb")
.................... #byte INTCON2=GETENV("SFR:intcon2")
.................... #bit RBPU=INTCON2.7
.................... 
.................... /* UART2 - FTDI cable */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600,errors)	
*
0146:  BTFSS  FA4.5
0148:  BRA    0146
014A:  MOVFF  FA6,1F
014E:  MOVFF  F7A,01
0152:  BTFSS  1F.1
0154:  BRA    015A
0156:  BCF    FA6.4
0158:  BSF    FA6.4
015A:  GOTO   0160 (RETURN)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
025A:  BCF    FC6.7
025C:  BCF    F9E.3
025E:  MOVFF  492,FC9
0262:  MOVLW  02
0264:  BTFSC  FC6.7
0266:  BRA    0272
0268:  BTFSS  F9E.3
026A:  BRA    0268
026C:  MOVLW  00
026E:  BTFSC  FC5.6
0270:  MOVLW  01
0272:  MOVWF  01
0274:  RETURN 0
*
0B12:  BCF    FC6.6
0B14:  BSF    FC5.3
0B16:  BTFSC  FC5.3
0B18:  BRA    0B16
0B1A:  BTFSC  00.0
0B1C:  BCF    FC5.5
0B1E:  BTFSS  00.0
0B20:  BSF    FC5.5
0B22:  BSF    FC5.4
0B24:  BTFSC  FC5.4
0B26:  BRA    0B24
0B28:  MOVFF  FC9,01
0B2C:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... /* Modbus defines */
.................... #define MODBUS_MODE_RTU     0
.................... #define MODBUS_MODE_TCP_RTU 1
.................... 
.................... #define SERIAL_PREFIX_DEFAULT 'Z'
.................... #define SERIAL_NUMBER_DEFAULT 2221
.................... 
.................... 
.................... #define DCSW_FPF2700_ACS714     0
.................... #define DCSW_LATCHING_CONTACTOR 1
.................... #define DCSW_SMALL48            2
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 revision;
.................... 	int8 modbus_address;
.................... 	int8 modbus_mode;
.................... 
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 
.................... 	int8 uart_sc_sbd;
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 	int16 adc[16];
.................... 	
.................... 	int8 restart_now;
.................... 	int8 adc_sample_ch;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	int8 led_on_green;
.................... 	int8 led_on_red;
.................... } struct_time_keep;
.................... 
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "i2c_access_dcswcI2C.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
0BC0:  BSF    FC5.0
0BC2:  BTFSC  FC5.0
0BC4:  BRA    0BC2
.................... 	delay_us(15);
0BC6:  CLRWDT
0BC8:  MOVLW  09
0BCA:  MOVWF  00
0BCC:  DECFSZ 00,F
0BCE:  BRA    0BCC
0BD0:  NOP   
.................... 	i2c_write(i2c_address);
0BD2:  MOVFF  48D,492
0BD6:  CALL   025A
.................... 	i2c_write(regaddr);
0BDA:  MOVFF  48E,492
0BDE:  CALL   025A
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
0BE2:  BSF    FC5.1
0BE4:  BTFSC  FC5.1
0BE6:  BRA    0BE4
.................... 	delay_us(15);
0BE8:  CLRWDT
0BEA:  MOVLW  09
0BEC:  MOVWF  00
0BEE:  DECFSZ 00,F
0BF0:  BRA    0BEE
0BF2:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
0BF4:  MOVLB  4
0BF6:  MOVF   x8D,W
0BF8:  IORLW  01
0BFA:  MOVWF  x91
0BFC:  MOVWF  x92
0BFE:  MOVLB  0
0C00:  CALL   025A
.................... 	msb=i2c_read(1);
0C04:  MOVLW  01
0C06:  MOVWF  00
0C08:  RCALL  0B12
0C0A:  MOVFF  01,48F
.................... 	lsb=i2c_read(0);                                
0C0E:  CLRF   00
0C10:  RCALL  0B12
0C12:  MOVFF  01,490
.................... 	i2c_stop();
0C16:  BSF    FC5.2
0C18:  BTFSC  FC5.2
0C1A:  BRA    0C18
.................... 
.................... 	return make16(msb,lsb);
0C1C:  MOVFF  48F,03
0C20:  MOVLB  4
0C22:  MOVFF  490,01
0C26:  MOVFF  03,02
0C2A:  MOVLB  0
0C2C:  GOTO   0EE0 (RETURN)
.................... }
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle         
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "uart_sc16is740_dcswcI2C.c"
.................... /* register map for SCI16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
0B2E:  BSF    FC5.0
0B30:  BTFSC  FC5.0
0B32:  BRA    0B30
.................... 	delay_us(15);
0B34:  CLRWDT
0B36:  MOVLW  09
0B38:  MOVWF  00
0B3A:  DECFSZ 00,F
0B3C:  BRA    0B3A
0B3E:  NOP   
.................... 	i2c_write(UART_ADDR);
0B40:  MOVLW  9A
0B42:  MOVLB  4
0B44:  MOVWF  x92
0B46:  MOVLB  0
0B48:  CALL   025A
.................... 	i2c_write(regaddr<<3);
0B4C:  MOVLB  4
0B4E:  RLCF   x8D,W
0B50:  MOVWF  x8F
0B52:  RLCF   x8F,F
0B54:  RLCF   x8F,F
0B56:  MOVLW  F8
0B58:  ANDWF  x8F,F
0B5A:  MOVFF  48F,492
0B5E:  MOVLB  0
0B60:  CALL   025A
.................... 	i2c_start();
0B64:  BSF    FC5.1
0B66:  BTFSC  FC5.1
0B68:  BRA    0B66
.................... 	delay_us(15);
0B6A:  CLRWDT
0B6C:  MOVLW  09
0B6E:  MOVWF  00
0B70:  DECFSZ 00,F
0B72:  BRA    0B70
0B74:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
0B76:  MOVLW  9B
0B78:  MOVLB  4
0B7A:  MOVWF  x92
0B7C:  MOVLB  0
0B7E:  CALL   025A
.................... 	data=i2c_read(0);
0B82:  CLRF   00
0B84:  RCALL  0B12
0B86:  MOVFF  01,48E
.................... 	i2c_stop();
0B8A:  BSF    FC5.2
0B8C:  BTFSC  FC5.2
0B8E:  BRA    0B8C
.................... 
.................... 	return data;
0B90:  MOVLB  4
0B92:  MOVFF  48E,01
0B96:  MOVLB  0
0B98:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
0276:  BSF    FC5.0
0278:  BTFSC  FC5.0
027A:  BRA    0278
.................... 	delay_us(15);                                                 
027C:  CLRWDT
027E:  MOVLW  09
0280:  MOVWF  00
0282:  DECFSZ 00,F
0284:  BRA    0282
0286:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
0288:  MOVLW  9A
028A:  MOVLB  4
028C:  MOVWF  x92
028E:  MOVLB  0
0290:  RCALL  025A
.................... 	i2c_write(regaddr<< 3);  // write cycle         
0292:  MOVLB  4
0294:  RLCF   x8E,W
0296:  MOVWF  x90
0298:  RLCF   x90,F
029A:  RLCF   x90,F
029C:  MOVLW  F8
029E:  ANDWF  x90,F
02A0:  MOVFF  490,492
02A4:  MOVLB  0
02A6:  RCALL  025A
.................... 	i2c_write(data);
02A8:  MOVFF  48F,492
02AC:  RCALL  025A
.................... 	i2c_stop();
02AE:  BSF    FC5.2
02B0:  BTFSC  FC5.2
02B2:  BRA    02B0
02B4:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
0BAE:  MOVLB  4
0BB0:  CLRF   x8E
0BB2:  MOVFF  48D,48F
0BB6:  MOVLB  0
0BB8:  CALL   0276
0BBC:  GOTO   0EC8 (RETURN)
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
0B9A:  MOVLW  05
0B9C:  MOVLB  4
0B9E:  MOVWF  x8D
0BA0:  MOVLB  0
0BA2:  RCALL  0B2E
0BA4:  MOVF   01,W
0BA6:  ANDLW  01
0BA8:  MOVWF  01
0BAA:  GOTO   0E40 (RETURN)
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
*
0E4A:  MOVLB  4
0E4C:  CLRF   x8D
0E4E:  MOVLB  0
0E50:  RCALL  0B2E
0E52:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
02B6:  MOVLW  03
02B8:  MOVLB  4
02BA:  MOVWF  x8E
02BC:  MOVLW  80
02BE:  MOVWF  x8F
02C0:  MOVLB  0
02C2:  RCALL  0276
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
02C4:  MOVLB  4
02C6:  CLRF   x8E
02C8:  MOVFF  48D,48F
02CC:  MOVLB  0
02CE:  RCALL  0276
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
02D0:  MOVLW  01
02D2:  MOVLB  4
02D4:  MOVWF  x8E
02D6:  CLRF   x8F
02D8:  MOVLB  0
02DA:  RCALL  0276
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
02DC:  MOVLW  03
02DE:  MOVLB  4
02E0:  MOVWF  x8E
02E2:  MOVLW  BF
02E4:  MOVWF  x8F
02E6:  MOVLB  0
02E8:  RCALL  0276
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
02EA:  MOVLW  02
02EC:  MOVLB  4
02EE:  MOVWF  x8E
02F0:  MOVLW  10
02F2:  MOVWF  x8F
02F4:  MOVLB  0
02F6:  RCALL  0276
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
02F8:  MOVLW  03
02FA:  MOVLB  4
02FC:  MOVWF  x8E
02FE:  MOVWF  x8F
0300:  MOVLB  0
0302:  RCALL  0276
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
0304:  MOVLW  01
0306:  MOVLB  4
0308:  MOVWF  x8E
030A:  CLRF   x8F
030C:  MOVLB  0
030E:  RCALL  0276
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0310:  MOVLW  02
0312:  MOVLB  4
0314:  MOVWF  x8E
0316:  MOVLW  07
0318:  MOVWF  x8F
031A:  MOVLB  0
031C:  RCALL  0276
031E:  GOTO   03BA (RETURN)
.................... }
.................... 
.................... 
.................... #include "mcp3208_dcswcI2C.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
*
0250:  BCF    F93.4
0252:  BSF    F8A.4
.................... 	output_high(CS_ADC0);
0254:  BCF    F93.0
0256:  BSF    F8A.0
0258:  RETURN 0
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
*
05B2:  BCF    F93.3
05B4:  BCF    F8A.3
.................... 	output_high(MCP3208_DIN);
05B6:  BCF    F93.1
05B8:  BSF    F8A.1
.................... 
.................... 
.................... 	if ( ch<8 ) {
05BA:  MOVLB  4
05BC:  MOVF   x8F,W
05BE:  SUBLW  07
05C0:  BNC   05C8
.................... 		output_low(CS_ADC0);
05C2:  BCF    F93.0
05C4:  BCF    F8A.0
.................... 	} else {
05C6:  BRA    05D0
.................... 		output_low(CS_ADC1);
05C8:  BCF    F93.4
05CA:  BCF    F8A.4
.................... 		ch-=8;
05CC:  MOVLW  08
05CE:  SUBWF  x8F,F
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
05D0:  MOVF   x8F,F
05D2:  BNZ   05DA
.................... 		c=0b00011;
05D4:  MOVLW  03
05D6:  MOVWF  x93
05D8:  BRA    0624
.................... 	else if ( 1 == ch ) 
05DA:  DECFSZ x8F,W
05DC:  BRA    05E4
.................... 		c=0b10011;
05DE:  MOVLW  13
05E0:  MOVWF  x93
05E2:  BRA    0624
.................... 	else if ( 2 == ch ) 
05E4:  MOVF   x8F,W
05E6:  SUBLW  02
05E8:  BNZ   05F0
.................... 		c=0b01011;
05EA:  MOVLW  0B
05EC:  MOVWF  x93
05EE:  BRA    0624
.................... 	else if ( 3 == ch ) 
05F0:  MOVF   x8F,W
05F2:  SUBLW  03
05F4:  BNZ   05FC
.................... 		c=0b11011;
05F6:  MOVLW  1B
05F8:  MOVWF  x93
05FA:  BRA    0624
.................... 	else if ( 4 == ch )
05FC:  MOVF   x8F,W
05FE:  SUBLW  04
0600:  BNZ   0608
.................... 		c=0b00111;
0602:  MOVLW  07
0604:  MOVWF  x93
0606:  BRA    0624
.................... 	else if ( 5 == ch ) 
0608:  MOVF   x8F,W
060A:  SUBLW  05
060C:  BNZ   0614
.................... 		c=0b10111;
060E:  MOVLW  17
0610:  MOVWF  x93
0612:  BRA    0624
.................... 	else if ( 6 == ch )
0614:  MOVF   x8F,W
0616:  SUBLW  06
0618:  BNZ   0620
.................... 		c=0b01111;
061A:  MOVLW  0F
061C:  MOVWF  x93
061E:  BRA    0624
.................... 	else
.................... 		c=0b11111;
0620:  MOVLW  1F
0622:  MOVWF  x93
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0624:  CLRF   x92
0626:  MOVF   x92,W
0628:  SUBLW  04
062A:  BNC   0648
.................... 		output_low(MCP3208_CLK);
062C:  BCF    F93.3
062E:  BCF    F8A.3
.................... 		output_bit(MCP3208_DIN,c&1);
0630:  BTFSC  x93.0
0632:  BRA    0638
0634:  BCF    F8A.1
0636:  BRA    063A
0638:  BSF    F8A.1
063A:  BCF    F93.1
.................... 		c=c>>1;
063C:  BCF    FD8.0
063E:  RRCF   x93,F
.................... 		output_high(MCP3208_CLK);
0640:  BCF    F93.3
0642:  BSF    F8A.3
0644:  INCF   x92,F
0646:  BRA    0626
.................... 	}
.................... 
.................... 
.................... 	value=0;
0648:  CLRF   x91
064A:  CLRF   x90
.................... 	for ( i=0 ; i<14 ; i++ ) {
064C:  CLRF   x92
064E:  MOVF   x92,W
0650:  SUBLW  0D
0652:  BNC   0670
.................... 		output_low(MCP3208_CLK);
0654:  BCF    F93.3
0656:  BCF    F8A.3
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
0658:  BSF    F93.2
065A:  BTFSC  F81.2
065C:  BRA    0662
065E:  BCF    FD8.0
0660:  BRA    0664
0662:  BSF    FD8.0
0664:  RLCF   x90,F
0666:  RLCF   x91,F
.................... 		output_high(MCP3208_CLK);
0668:  BCF    F93.3
066A:  BSF    F8A.3
066C:  INCF   x92,F
066E:  BRA    064E
.................... 	}
.................... 
.................... 	bit_clear(value,13);
0670:  BCF    x91.5
.................... 	bit_clear(value,12);
0672:  BCF    x91.4
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
0674:  MOVLB  0
0676:  RCALL  0250
.................... 
.................... 	return value;
0678:  MOVLB  4
067A:  MOVFF  490,01
067E:  MOVFF  491,02
0682:  MOVLB  0
0684:  GOTO   0D22 (RETURN)
.................... }
.................... 
.................... #include "interrupt_dcswcI2C.c"
.................... 
.................... #int_timer3
.................... void isr_10ms(void) {
.................... 	static int16 uptimeTicks=0;
.................... 	static int16 ticks=0;
.................... 	static int8 adc_ch=0;
.................... 
.................... 	/* preset so we trigger again in 10 milliseconds */
.................... 	set_timer3(45536);
*
00BA:  MOVLW  B1
00BC:  MOVWF  FB3
00BE:  MOVLW  E0
00C0:  MOVWF  FB2
.................... 
.................... 	/* scan adc channels */
.................... 	current.adc_sample_ch = adc_ch;
00C2:  MOVFF  56,4F
.................... 	/* each adc read gives us two channels */
.................... 	adc_ch+=2;
00C6:  MOVLW  02
00C8:  ADDWF  56,F
.................... 
.................... 	if ( adc_ch >= 16 ) 
00CA:  MOVF   56,W
00CC:  SUBLW  0F
00CE:  BC    00D2
.................... 		adc_ch=0;
00D0:  CLRF   56
.................... 
.................... 
.................... 	/* ticks(?) since last query */
.................... 	if ( current.interval_milliseconds < 65525 ) {
00D2:  MOVF   2C,W
00D4:  SUBLW  FF
00D6:  BNC   00EA
00D8:  BNZ   00E0
00DA:  MOVF   2B,W
00DC:  SUBLW  F4
00DE:  BNC   00EA
.................... 		current.interval_milliseconds+=10;
00E0:  MOVLW  0A
00E2:  ADDWF  2B,F
00E4:  MOVLW  00
00E6:  ADDWFC 2C,F
.................... 	} else {
00E8:  BRA    00EE
.................... 		current.interval_milliseconds=65535;
00EA:  SETF   2C
00EC:  SETF   2B
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
00EE:  INCF   54,F
00F0:  BTFSC  FD8.2
00F2:  INCF   55,F
.................... 	if ( ticks >= 100 ) {
00F4:  MOVF   55,F
00F6:  BNZ   00FE
00F8:  MOVF   54,W
00FA:  SUBLW  63
00FC:  BC    0102
.................... 		ticks=0;
00FE:  CLRF   55
0100:  CLRF   54
.................... 	}
.................... 	
.................... 
.................... 	/* uptime counter */
.................... 	uptimeTicks++;
0102:  INCF   52,F
0104:  BTFSC  FD8.2
0106:  INCF   53,F
.................... 	if ( 6000 == uptimeTicks ) {
0108:  MOVF   52,W
010A:  SUBLW  70
010C:  BNZ   0128
010E:  MOVF   53,W
0110:  SUBLW  17
0112:  BNZ   0128
.................... 		uptimeTicks=0;
0114:  CLRF   53
0116:  CLRF   52
.................... 		if ( current.uptime_minutes < 65535 ) 
0118:  INCFSZ 29,W
011A:  BRA    0122
011C:  INCFSZ 2A,W
011E:  BRA    0122
0120:  BRA    0128
.................... 			current.uptime_minutes++;
0122:  INCF   29,F
0124:  BTFSC  FD8.2
0126:  INCF   2A,F
.................... 	}
.................... 
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
0128:  MOVF   50,F
012A:  BNZ   0132
.................... 		output_low(LED_GREEN);
012C:  BCF    F93.5
012E:  BCF    F8A.5
.................... 	} else {
0130:  BRA    0138
.................... 		output_high(LED_GREEN);
0132:  BCF    F93.5
0134:  BSF    F8A.5
.................... 		timers.led_on_green--;
0136:  DECF   50,F
.................... 	}
.................... 
.................... 	if ( 0==timers.led_on_red ) {
0138:  MOVF   51,F
013A:  BNZ   013E
.................... //		output_low(LED_RED);
.................... 	} else {
013C:  BRA    0140
.................... //		output_high(LED_RED);
.................... 		timers.led_on_red--;
013E:  DECF   51,F
.................... 	}
.................... }
.................... 
0140:  BCF    FA1.1
0142:  GOTO   006C
.................... #int_rda2
.................... /* any character on FTDI serial port (UART2) will case a reset */
.................... void ftdi_isr(void) {
.................... 	current.restart_now=fgetc(STREAM_WORLD);
*
015E:  BRA    0146
0160:  MOVFF  01,4E
.................... //	current.restart_now=1;
.................... }
.................... 
.................... #include "param_dcswcI2C.c"
0164:  BCF    FA4.5
0166:  GOTO   006C
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0434:  MOVF   x99,W
0436:  XORWF  x9A,W
0438:  MOVWF  01
*
0482:  MOVF   x99,W
0484:  XORWF  x9A,W
0486:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
03C8:  MOVLB  4
03CA:  CLRF   x96
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
03CC:  MOVFF  495,498
03D0:  MOVF   x94,W
03D2:  BTFSC  FD8.2
03D4:  DECF   x95,F
03D6:  DECF   x94,F
03D8:  MOVWF  x97
03DA:  MOVF   x97,F
03DC:  BNZ   03E2
03DE:  MOVF   x98,F
03E0:  BZ    0446
.................... 		*data = read_eeprom( address++ );
03E2:  MOVFF  493,03
03E6:  MOVF   x92,W
03E8:  MOVWF  FE9
03EA:  MOVFF  03,FEA
03EE:  MOVF   x91,W
03F0:  MOVWF  03
03F2:  MOVF   x90,W
03F4:  INCF   x90,F
03F6:  BTFSC  FD8.2
03F8:  INCF   x91,F
03FA:  MOVWF  x99
03FC:  MOVFF  03,49A
0400:  MOVFF  FF2,49B
0404:  BCF    FF2.7
0406:  MOVFF  49A,F75
040A:  MOVFF  499,F74
040E:  BCF    F7F.6
0410:  BCF    F7F.7
0412:  BSF    F7F.0
0414:  MOVF   F73,W
0416:  BTFSC  x9B.7
0418:  BSF    FF2.7
041A:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
041C:  MOVFF  493,03
0420:  MOVF   x92,W
0422:  MOVWF  FE9
0424:  MOVFF  03,FEA
0428:  MOVFF  FEF,497
042C:  MOVFF  496,499
0430:  MOVFF  497,49A
*
043A:  MOVFF  01,496
.................... 		data++;
043E:  INCF   x92,F
0440:  BTFSC  FD8.2
0442:  INCF   x93,F
0444:  BRA    03CC
.................... 	}
.................... 	return crc;
0446:  MOVFF  496,01
044A:  MOVLB  0
044C:  GOTO   057A (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
0450:  MOVLB  4
0452:  CLRF   x97
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0454:  MOVFF  496,499
0458:  MOVF   x95,W
045A:  BTFSC  FD8.2
045C:  DECF   x96,F
045E:  DECF   x95,F
0460:  MOVWF  x98
0462:  MOVF   x98,F
0464:  BNZ   046A
0466:  MOVF   x99,F
0468:  BZ    04E6
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
046A:  MOVFF  494,03
046E:  MOVF   x93,W
0470:  MOVWF  FE9
0472:  MOVFF  03,FEA
0476:  MOVFF  FEF,498
047A:  MOVFF  497,499
047E:  MOVFF  498,49A
*
0488:  MOVFF  01,497
.................... 		write_eeprom( address++, *data++ );
048C:  MOVF   x92,W
048E:  MOVWF  03
0490:  MOVF   x91,W
0492:  INCF   x91,F
0494:  BTFSC  FD8.2
0496:  INCF   x92,F
0498:  MOVWF  x98
049A:  MOVFF  03,499
049E:  MOVF   x94,W
04A0:  MOVWF  03
04A2:  MOVF   x93,W
04A4:  INCF   x93,F
04A6:  BTFSC  FD8.2
04A8:  INCF   x94,F
04AA:  MOVWF  FE9
04AC:  MOVFF  03,FEA
04B0:  MOVFF  FEF,49A
04B4:  MOVF   FF2,W
04B6:  MOVWF  00
04B8:  BCF    FF2.7
04BA:  MOVFF  499,F75
04BE:  MOVFF  498,F74
04C2:  MOVFF  49A,F73
04C6:  BCF    F7F.6
04C8:  BCF    F7F.7
04CA:  BSF    F7F.2
04CC:  MOVLB  F
04CE:  MOVLW  55
04D0:  MOVWF  F7E
04D2:  MOVLW  AA
04D4:  MOVWF  F7E
04D6:  BSF    F7F.1
04D8:  BTFSC  F7F.1
04DA:  BRA    04D8
04DC:  BCF    F7F.2
04DE:  MOVF   00,W
04E0:  IORWF  FF2,F
04E2:  MOVLB  4
04E4:  BRA    0454
.................... 	}
.................... 
.................... 	return crc;
04E6:  MOVFF  497,01
04EA:  MOVLB  0
04EC:  GOTO   050C (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
04F0:  MOVLB  4
04F2:  MOVLW  20
04F4:  MOVWF  x8F
04F6:  CLRF   x92
04F8:  MOVLW  02
04FA:  MOVWF  x91
04FC:  CLRF   x94
04FE:  MOVFF  48F,493
0502:  CLRF   x96
0504:  MOVLW  07
0506:  MOVWF  x95
0508:  MOVLB  0
050A:  BRA    0450
050C:  MOVFF  01,48E
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
0510:  MOVF   FF2,W
0512:  MOVWF  00
0514:  BCF    FF2.7
0516:  CLRF   F75
0518:  CLRF   F74
051A:  MOVFF  48E,F73
051E:  BCF    F7F.6
0520:  BCF    F7F.7
0522:  BSF    F7F.2
0524:  MOVLB  F
0526:  MOVLW  55
0528:  MOVWF  F7E
052A:  MOVLW  AA
052C:  MOVWF  F7E
052E:  BSF    F7F.1
0530:  BTFSC  F7F.1
0532:  BRA    0530
0534:  BCF    F7F.2
0536:  MOVF   00,W
0538:  IORWF  FF2,F
053A:  MOVLB  0
053C:  GOTO   055C (RETURN)
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0540:  MOVLW  96
0542:  MOVWF  50
.................... 
.................... 	config.revision='a';
0544:  MOVLW  61
0546:  MOVWF  20
.................... 
.................... 	config.modbus_address=37;
0548:  MOVLW  25
054A:  MOVWF  21
.................... 	config.modbus_mode=MODBUS_MODE_RTU;
054C:  CLRF   22
.................... 
.................... 	config.serial_prefix=SERIAL_PREFIX_DEFAULT;
054E:  MOVLW  5A
0550:  MOVWF  23
.................... 	config.serial_number=SERIAL_NUMBER_DEFAULT;
0552:  MOVLW  08
0554:  MOVWF  25
0556:  MOVLW  AD
0558:  MOVWF  24
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
055A:  BRA    04F0
055C:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
055E:  MOVLB  4
0560:  MOVLW  20
0562:  MOVWF  x8E
0564:  CLRF   x91
0566:  MOVLW  02
0568:  MOVWF  x90
056A:  CLRF   x93
056C:  MOVFF  48E,492
0570:  CLRF   x95
0572:  MOVLW  07
0574:  MOVWF  x94
0576:  MOVLB  0
0578:  BRA    03C8
057A:  MOVFF  01,48D
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) {
057E:  MOVFF  FF2,48E
0582:  BCF    FF2.7
0584:  CLRF   F75
0586:  CLRF   F74
0588:  BCF    F7F.6
058A:  BCF    F7F.7
058C:  BSF    F7F.0
058E:  MOVF   F73,W
0590:  MOVLB  4
0592:  BTFSC  x8E.7
0594:  BSF    FF2.7
0596:  SUBWF  x8D,W
0598:  BNZ   05A6
059A:  MOVF   20,W
059C:  SUBLW  60
059E:  BC    05A6
05A0:  MOVF   20,W
05A2:  SUBLW  7A
05A4:  BC    05AC
.................... 		write_default_param_file();
05A6:  MOVLB  0
05A8:  RCALL  0540
05AA:  MOVLB  4
.................... 	}
05AC:  MOVLB  0
05AE:  GOTO   0CEA (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include "filter_dcswcI2C.c"
.................... #define MEAN_FILTER_WIDTH    16
.................... #define MEAN_FILTER_CHANNELS 16
.................... 
.................... int16 mean_filter_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	static int8 num_elements[MEAN_FILTER_CHANNELS];
.................... 	int32 mean;
.................... 	int32 sum;
.................... 	int8 i;
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index[ch]] = latest_element;
*
0740:  MOVLB  4
0742:  CLRF   x9E
0744:  MOVFF  491,49D
0748:  CLRF   xA0
074A:  MOVLW  20
074C:  MOVWF  x9F
074E:  MOVLB  0
0750:  RCALL  0688
0752:  MOVFF  02,49E
0756:  MOVFF  01,49D
075A:  CLRF   03
075C:  MOVLB  4
075E:  MOVF   x91,W
0760:  ADDLW  57
0762:  MOVWF  FE9
0764:  MOVLW  02
0766:  ADDWFC 03,W
0768:  MOVWF  FEA
076A:  CLRF   03
076C:  MOVFF  FEF,02
0770:  BCF    FD8.0
0772:  RLCF   02,F
0774:  RLCF   03,F
0776:  MOVF   02,W
0778:  ADDWF  01,W
077A:  MOVWF  01
077C:  MOVF   x9E,W
077E:  ADDWFC 03,F
0780:  MOVF   01,W
0782:  ADDLW  57
0784:  MOVWF  FE9
0786:  MOVLW  00
0788:  ADDWFC 03,W
078A:  MOVWF  FEA
078C:  MOVFF  493,FEC
0790:  MOVF   FED,F
0792:  MOVFF  492,FEF
.................... 	inbuf_index[ch]++;
0796:  CLRF   03
0798:  MOVF   x91,W
079A:  ADDLW  57
079C:  MOVWF  FE9
079E:  MOVLW  02
07A0:  ADDWFC 03,W
07A2:  MOVWF  FEA
07A4:  INCF   FEF,F
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
07A6:  CLRF   03
07A8:  MOVF   x91,W
07AA:  ADDLW  57
07AC:  MOVWF  FE9
07AE:  MOVLW  02
07B0:  ADDWFC 03,W
07B2:  MOVWF  FEA
07B4:  MOVF   FEF,W
07B6:  SUBLW  0F
07B8:  BC    07CA
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
07BA:  CLRF   03
07BC:  MOVF   x91,W
07BE:  ADDLW  57
07C0:  MOVWF  FE9
07C2:  MOVLW  02
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  CLRF   FEF
.................... 
.................... 	if(num_elements[ch] < MEAN_FILTER_WIDTH)
07CA:  CLRF   03
07CC:  MOVF   x91,W
07CE:  ADDLW  67
07D0:  MOVWF  FE9
07D2:  MOVLW  02
07D4:  ADDWFC 03,W
07D6:  MOVWF  FEA
07D8:  MOVF   FEF,W
07DA:  SUBLW  0F
07DC:  BNC   07EE
.................... 	   num_elements[ch]++;
07DE:  CLRF   03
07E0:  MOVF   x91,W
07E2:  ADDLW  67
07E4:  MOVWF  FE9
07E6:  MOVLW  02
07E8:  ADDWFC 03,W
07EA:  MOVWF  FEA
07EC:  INCF   FEF,F
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
07EE:  CLRF   x9B
07F0:  CLRF   x9A
07F2:  CLRF   x99
07F4:  CLRF   x98
.................... 	for(i = 0; i < num_elements[ch]; i++)
07F6:  CLRF   x9C
07F8:  CLRF   03
07FA:  MOVF   x91,W
07FC:  ADDLW  67
07FE:  MOVWF  FE9
0800:  MOVLW  02
0802:  ADDWFC 03,W
0804:  MOVWF  FEA
0806:  MOVF   FEF,W
0808:  SUBWF  x9C,W
080A:  BC    0860
.................... 		sum += input_buffer[ch][i];
080C:  CLRF   x9E
080E:  MOVFF  491,49D
0812:  CLRF   xA0
0814:  MOVLW  20
0816:  MOVWF  x9F
0818:  MOVLB  0
081A:  RCALL  0688
081C:  MOVFF  02,49E
0820:  MOVFF  01,49D
0824:  CLRF   03
0826:  MOVLB  4
0828:  MOVFF  49C,02
082C:  BCF    FD8.0
082E:  RLCF   02,F
0830:  RLCF   03,F
0832:  MOVF   02,W
0834:  ADDWF  01,W
0836:  MOVWF  01
0838:  MOVF   x9E,W
083A:  ADDWFC 03,F
083C:  MOVF   01,W
083E:  ADDLW  57
0840:  MOVWF  FE9
0842:  MOVLW  00
0844:  ADDWFC 03,W
0846:  MOVWF  FEA
0848:  MOVFF  FEC,03
084C:  MOVF   FED,F
084E:  MOVF   FEF,W
0850:  ADDWF  x98,F
0852:  MOVF   03,W
0854:  ADDWFC x99,F
0856:  MOVLW  00
0858:  ADDWFC x9A,F
085A:  ADDWFC x9B,F
085C:  INCF   x9C,F
085E:  BRA    07F8
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... 	mean = (sum + (int32)(num_elements[ch] >> 1)) / num_elements[ch];
0860:  CLRF   03
0862:  MOVF   x91,W
0864:  ADDLW  67
0866:  MOVWF  FE9
0868:  MOVLW  02
086A:  ADDWFC 03,W
086C:  MOVWF  FEA
086E:  MOVFF  FEF,49D
0872:  BCF    FD8.0
0874:  RRCF   x9D,W
0876:  MOVWF  00
0878:  CLRF   01
087A:  CLRF   02
087C:  CLRF   03
087E:  MOVF   00,W
0880:  ADDWF  x98,W
0882:  MOVWF  x9D
0884:  MOVF   01,W
0886:  ADDWFC x99,W
0888:  MOVWF  x9E
088A:  MOVF   02,W
088C:  ADDWFC x9A,W
088E:  MOVWF  x9F
0890:  MOVF   03,W
0892:  ADDWFC x9B,W
0894:  MOVWF  xA0
0896:  CLRF   03
0898:  MOVF   x91,W
089A:  ADDLW  67
089C:  MOVWF  FE9
089E:  MOVLW  02
08A0:  ADDWFC 03,W
08A2:  MOVWF  FEA
08A4:  MOVFF  FEF,4A8
08A8:  MOVFF  FEA,4A3
08AC:  MOVFF  FE9,4A2
08B0:  BCF    FD8.1
08B2:  MOVFF  4A0,4A7
08B6:  MOVFF  49F,4A6
08BA:  MOVFF  49E,4A5
08BE:  MOVFF  49D,4A4
08C2:  CLRF   xAB
08C4:  CLRF   xAA
08C6:  CLRF   xA9
08C8:  MOVLB  0
08CA:  BRA    06AA
08CC:  MOVFF  4A3,FEA
08D0:  MOVFF  4A2,FE9
08D4:  MOVFF  03,497
08D8:  MOVFF  02,496
08DC:  MOVFF  01,495
08E0:  MOVFF  00,494
.................... 
.................... 	return((int16)mean);
08E4:  MOVLB  4
08E6:  MOVFF  494,01
08EA:  MOVFF  495,02
08EE:  MOVLB  0
08F0:  GOTO   0D38 (RETURN)
.................... }
.................... 
.................... /* 
.................... special case of mean filter. For a 16 element filter, max value of 4096, and equal
.................... number of samples for each channel. Filter result doesn't become valid until at least
.................... 16 samples have been added
.................... */
.................... int16 mean_filter16_n(int8 ch, int16 latest_element) {
.................... 	static int16 input_buffer[MEAN_FILTER_CHANNELS][MEAN_FILTER_WIDTH];
.................... 	static int8 inbuf_index[MEAN_FILTER_CHANNELS];
.................... 	int16 sum;
.................... 	int16 min, max;
.................... 	int8 i;
.................... 
.................... 
.................... 	// Insert incoming data element into circular input buffer.
.................... 	input_buffer[ch][inbuf_index] = latest_element;
.................... 	inbuf_index[ch]++;
.................... 	if(inbuf_index[ch] >= MEAN_FILTER_WIDTH)  // If index went past buffer end
.................... 	   inbuf_index[ch] = 0;       // then reset it to start of buffer
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	min=65535;
.................... 	max=0;
.................... 	sum = 0;
.................... 	for( i = 0; i < MEAN_FILTER_WIDTH ; i++ ) {
.................... 		sum += input_buffer[ch][i];
.................... 
.................... 		if ( input_buffer[ch][i] > max )
.................... 			max=input_buffer[ch][i];
.................... 		if ( input_buffer[ch][i] < min )
.................... 			min=input_buffer[ch][i];
.................... 	}
.................... 
.................... 	/* throw out the highest and lowest values */
.................... 	sum -= max;
.................... 	sum -= min;
.................... 
.................... 	return ( (sum+7) / 14 );
.................... 
.................... 	// Round-off the result by adding half the divisor to
.................... 	// the numerator.
.................... //	return ( (sum+8) >> 4 );
.................... }
.................... 
.................... 
.................... 
.................... void init() {
.................... 	setup_oscillator(OSC_8MHZ || OSC_INTRC); 
*
0354:  MOVLW  60
0356:  MOVWF  FD3
0358:  CLRF   F9B
035A:  CLRF   F64
.................... //	setup_adc(ADC_CLOCK_INTERNAL);
.................... 	setup_adc_ports(NO_ANALOGS);
035C:  MOVLB  F
035E:  MOVF   x5C,W
0360:  ANDLW  80
0362:  MOVWF  x5C
0364:  MOVLW  00
0366:  MOVWF  x5D
0368:  BCF    FC1.3
036A:  BCF    FC1.4
036C:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
036E:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
0370:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
0372:  MOVLW  1F
0374:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
0376:  MOVLW  F0
0378:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
037A:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
037C:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
037E:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
0380:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
0382:  BCF    F94.5
0384:  BCF    F8B.5
.................... 
.................... 	/* data structure initialization */
.................... 	timers.led_on_green=0;
0386:  CLRF   50
.................... 	timers.led_on_red=0;
0388:  CLRF   51
.................... 
.................... 	current.sequence_number=0;
038A:  CLRF   28
038C:  CLRF   27
.................... 	current.uptime_minutes=0;
038E:  CLRF   2A
0390:  CLRF   29
.................... 	current.interval_milliseconds=0;
0392:  CLRF   2C
0394:  CLRF   2B
.................... 	current.factory_unlocked=0;
0396:  CLRF   2D
.................... 	current.restart_now=0;
0398:  CLRF   4E
.................... 
.................... 
.................... 	/* interrupts */
.................... 	/* timer0 - Modbus slave timeout timer */
.................... 	/* configured in modbus_slave_sdc.c */
.................... 
.................... 	/* timer1 - unused */
.................... 
.................... 	/* timer2 - unused */
.................... 
.................... 	/* timer3 - general housekeeping Prescaler=1:1; TMR1 Preset=45536; Freq=100.00Hz; Period=10.00 ms */
.................... 	setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);
039A:  CLRF   FB0
039C:  MOVLW  07
039E:  MOVWF  FB1
.................... 	set_timer3(45536);
03A0:  MOVLW  B1
03A2:  MOVWF  FB3
03A4:  MOVLW  E0
03A6:  MOVWF  FB2
.................... 	enable_interrupts(INT_TIMER3);
03A8:  BSF    FA0.1
.................... 
.................... 	/* timer4 - unused */
.................... 
.................... 	/* FTDI serial cable receive character */
.................... 	enable_interrupts(INT_RDA2);
03AA:  BSF    FA3.5
.................... 
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
03AC:  MOVLB  0
03AE:  RCALL  0250
.................... 
.................... 
.................... 	/* initialize SCI UART @ 19200 */
.................... 	uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
03B0:  MOVLW  06
03B2:  MOVLB  4
03B4:  MOVWF  x8D
03B6:  MOVLB  0
03B8:  BRA    02B6
.................... 
.................... 
.................... 	delay_ms(14);
03BA:  MOVLW  0E
03BC:  MOVLB  4
03BE:  MOVWF  x8D
03C0:  MOVLB  0
03C2:  BRA    0322
03C4:  GOTO   0CE8 (RETURN)
.................... 
.................... }
.................... 
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start();
*
0AA0:  BSF    FC5.0
0AA2:  BTFSC  FC5.0
0AA4:  BRA    0AA2
.................... 	status = i2c_write(address);  // Status = 0 if got an ACK
0AA6:  MOVFF  48D,492
0AAA:  CALL   025A
0AAE:  MOVFF  01,48E
.................... 	i2c_stop();
0AB2:  BSF    FC5.2
0AB4:  BTFSC  FC5.2
0AB6:  BRA    0AB4
.................... 
.................... 	if ( 0 == status )
0AB8:  MOVLB  4
0ABA:  MOVF   x8E,F
0ABC:  BNZ   0AC4
.................... 		return TRUE;
0ABE:  MOVLW  01
0AC0:  MOVWF  01
0AC2:  BRA    0AC8
.................... 
....................    return FALSE;
0AC4:  MOVLW  00
0AC6:  MOVWF  01
0AC8:  MOVLB  0
0ACA:  RETURN 0
.................... }
.................... 
.................... void main(void) {
*
0C30:  CLRF   FF8
0C32:  BCF    FD0.7
0C34:  BSF    07.7
0C36:  MOVLW  62
0C38:  MOVWF  FD3
0C3A:  CLRF   F9B
0C3C:  CLRF   F64
0C3E:  CLRF   1F
0C40:  BCF    FA7.3
0C42:  MOVLW  0C
0C44:  MOVWF  FAF
0C46:  MOVLW  A2
0C48:  MOVWF  FAC
0C4A:  MOVLW  90
0C4C:  MOVWF  FAB
0C4E:  BSF    FB9.3
0C50:  MOVLW  22
0C52:  MOVWF  F7B
0C54:  MOVLW  00
0C56:  MOVWF  F7C
0C58:  MOVLW  A6
0C5A:  MOVWF  FBA
0C5C:  MOVLW  90
0C5E:  MOVWF  FA6
0C60:  BSF    F94.3
0C62:  BSF    F94.4
0C64:  MOVLW  04
0C66:  MOVWF  FC8
0C68:  MOVLW  28
0C6A:  MOVWF  FC6
0C6C:  BCF    FC7.7
0C6E:  BCF    FC7.6
0C70:  MOVLB  4
0C72:  CLRF   x88
0C74:  CLRF   x87
0C76:  MOVLB  F
0C78:  MOVF   x5C,W
0C7A:  ANDLW  80
0C7C:  MOVWF  x5C
0C7E:  MOVLW  00
0C80:  MOVWF  x5D
0C82:  BCF    FC1.3
0C84:  BCF    FC1.4
0C86:  BCF    FC1.5
0C88:  CLRF   x5E
0C8A:  CLRF   x5F
0C8C:  BRA    0CA4
0C8E:  DATA 02,00
0C90:  DATA 19,00
0C92:  DATA 00,FF
0C94:  DATA 40,20
0C96:  DATA 00,FF
0C98:  DATA C0,00
0C9A:  DATA FF,C0
0C9C:  DATA 00,FF
0C9E:  DATA C0,00
0CA0:  DATA 6B,C0
0CA2:  DATA 00,00
0CA4:  MOVLW  00
0CA6:  MOVWF  FF8
0CA8:  MOVLW  0C
0CAA:  MOVWF  FF7
0CAC:  MOVLW  8E
0CAE:  MOVWF  FF6
0CB0:  TBLRD*+
0CB2:  MOVF   FF5,W
0CB4:  MOVWF  00
0CB6:  XORLW  00
0CB8:  BZ    0CE0
0CBA:  TBLRD*+
0CBC:  MOVF   FF5,W
0CBE:  MOVWF  01
0CC0:  BTFSC  FE8.7
0CC2:  BRA    0CCE
0CC4:  ANDLW  3F
0CC6:  MOVWF  FEA
0CC8:  TBLRD*+
0CCA:  MOVFF  FF5,FE9
0CCE:  BTFSC  01.6
0CD0:  TBLRD*+
0CD2:  BTFSS  01.6
0CD4:  TBLRD*+
0CD6:  MOVFF  FF5,FEE
0CDA:  DCFSNZ 00,F
0CDC:  BRA    0CB0
0CDE:  BRA    0CD2
0CE0:  CLRF   FF8
.................... 	int8 i,j;
.................... 	int16 l;
.................... 
.................... 	init();
0CE2:  MOVLB  0
0CE4:  GOTO   0354
.................... 	read_param_file();
0CE8:  BRA    055E
.................... 
.................... 	if ( config.modbus_address > 127 ) {
0CEA:  MOVF   21,W
0CEC:  SUBLW  7F
0CEE:  BC    0CF2
.................... 		write_default_param_file();
0CF0:  RCALL  0540
.................... 	}
.................... 
.................... 
.................... 	/* prime filters */
.................... 	for ( i=0 ; i<20 ; i++ ) {
0CF2:  MOVLB  4
0CF4:  CLRF   x89
0CF6:  MOVF   x89,W
0CF8:  SUBLW  13
0CFA:  BNC   0D54
.................... 		for ( j=0 ; j<16 ; j++ ) {
0CFC:  CLRF   x8A
0CFE:  MOVF   x8A,W
0D00:  SUBLW  0F
0D02:  BNC   0D50
.................... 			current.adc[j]=mean_filter_n(j,mcp3208_read(j));
0D04:  BCF    FD8.0
0D06:  RLCF   x8A,W
0D08:  CLRF   03
0D0A:  ADDLW  2E
0D0C:  MOVWF  01
0D0E:  MOVLW  00
0D10:  ADDWFC 03,F
0D12:  MOVFF  01,48D
0D16:  MOVFF  03,48E
0D1A:  MOVFF  48A,48F
0D1E:  MOVLB  0
0D20:  BRA    05B2
0D22:  MOVFF  02,490
0D26:  MOVFF  01,48F
0D2A:  MOVFF  48A,491
0D2E:  MOVFF  02,493
0D32:  MOVFF  01,492
0D36:  BRA    0740
0D38:  MOVFF  48E,FEA
0D3C:  MOVFF  48D,FE9
0D40:  MOVFF  02,FEC
0D44:  MOVF   FED,F
0D46:  MOVFF  01,FEF
0D4A:  MOVLB  4
0D4C:  INCF   x8A,F
0D4E:  BRA    0CFE
.................... 		}
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... #if 1
0D50:  INCF   x89,F
0D52:  BRA    0CF6
.................... 	fprintf(STREAM_WORLD,"# dcswcI2C (%c%lu) start up (ds30 bootloader support) (worldData stream) (modbus address=%u) %s\r\n",
.................... 		config.serial_prefix,
.................... 		config.serial_number,
.................... 		config.modbus_address,
.................... 		__DATE__
.................... 	);
0D54:  MOVLW  6A
0D56:  MOVWF  FF6
0D58:  MOVLW  01
0D5A:  MOVWF  FF7
0D5C:  MOVLW  0C
0D5E:  MOVWF  x8E
0D60:  MOVLB  0
0D62:  RCALL  08F4
0D64:  MOVF   23,W
0D66:  BTFSS  FA4.4
0D68:  BRA    0D66
0D6A:  MOVWF  F79
0D6C:  MOVLW  10
0D6E:  MOVWF  FE9
0D70:  MOVFF  25,48E
0D74:  MOVFF  24,48D
0D78:  RCALL  091E
0D7A:  MOVLW  7B
0D7C:  MOVWF  FF6
0D7E:  MOVLW  01
0D80:  MOVWF  FF7
0D82:  MOVLW  48
0D84:  MOVLB  4
0D86:  MOVWF  x8E
0D88:  MOVLB  0
0D8A:  RCALL  08F4
0D8C:  MOVFF  21,48D
0D90:  MOVLW  1B
0D92:  MOVLB  4
0D94:  MOVWF  x8E
0D96:  MOVLB  0
0D98:  BRA    09FE
0D9A:  MOVLW  29
0D9C:  BTFSS  FA4.4
0D9E:  BRA    0D9C
0DA0:  MOVWF  F79
0DA2:  MOVLW  20
0DA4:  BTFSS  FA4.4
0DA6:  BRA    0DA4
0DA8:  MOVWF  F79
0DAA:  MOVLW  CC
0DAC:  MOVWF  FF6
0DAE:  MOVLW  01
0DB0:  MOVWF  FF7
0DB2:  RCALL  0A7E
0DB4:  MOVLW  0D
0DB6:  BTFSS  FA4.4
0DB8:  BRA    0DB6
0DBA:  MOVWF  F79
0DBC:  MOVLW  0A
0DBE:  BTFSS  FA4.4
0DC0:  BRA    0DBE
0DC2:  MOVWF  F79
.................... #endif	
.................... 
.................... 
.................... #if 1
.................... 	/* scan I2C bus */
.................... 	for (i=0x10 ; i<0xF0 ; i+=2) {
0DC4:  MOVLW  10
0DC6:  MOVLB  4
0DC8:  MOVWF  x89
0DCA:  MOVF   x89,W
0DCC:  SUBLW  EF
0DCE:  BNC   0E20
.................... 		if ( get_ack_status(i) ) {
0DD0:  MOVFF  489,48D
0DD4:  MOVLB  0
0DD6:  RCALL  0AA0
0DD8:  MOVF   01,F
0DDA:  BZ    0E18
.................... 			fprintf(STREAM_WORLD,"# testing address 0x%02x ...",i);
0DDC:  MOVLW  D6
0DDE:  MOVWF  FF6
0DE0:  MOVLW  01
0DE2:  MOVWF  FF7
0DE4:  MOVLW  14
0DE6:  MOVLB  4
0DE8:  MOVWF  x8E
0DEA:  MOVLB  0
0DEC:  RCALL  08F4
0DEE:  MOVFF  489,48D
0DF2:  MOVLW  57
0DF4:  MOVLB  4
0DF6:  MOVWF  x8E
0DF8:  MOVLB  0
0DFA:  RCALL  0ACC
0DFC:  MOVLW  EE
0DFE:  MOVWF  FF6
0E00:  MOVLW  01
0E02:  MOVWF  FF7
0E04:  MOVLW  04
0E06:  MOVLB  4
0E08:  MOVWF  x8E
0E0A:  MOVLB  0
0E0C:  RCALL  08F4
.................... 			fprintf(STREAM_WORLD," got ack!\r\n");
0E0E:  MOVLW  F4
0E10:  MOVWF  FF6
0E12:  MOVLW  01
0E14:  MOVWF  FF7
0E16:  RCALL  0A7E
....................     	} else {
.................... //			fprintf(STREAM_FTDI," nothing\r\n");
.................... 		}
0E18:  MOVLW  02
0E1A:  MOVLB  4
0E1C:  ADDWF  x89,F
0E1E:  BRA    0DCA
....................    	}
.................... #endif
.................... 
.................... 
.................... 	config.uart_sc_sbd=get_ack_status(0x9a);
0E20:  MOVLW  9A
0E22:  MOVWF  x8D
0E24:  MOVLB  0
0E26:  RCALL  0AA0
0E28:  MOVFF  01,26
.................... 
.................... 	timers.led_on_red=timers.led_on_green=0;
0E2C:  CLRF   50
0E2E:  MOVFF  50,51
.................... 
.................... #if 0
.................... 	/* set ports to their startup state */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		current.p_on[i]=config.ch[i].startup;
.................... 	}
.................... #endif
.................... 
.................... 	i=0;
0E32:  MOVLB  4
0E34:  CLRF   x89
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0E36:  CLRWDT
.................... 
.................... 			if ( config.uart_sc_sbd && uart_kbhit() ) {
0E38:  MOVF   26,F
0E3A:  BZ    0E86
0E3C:  MOVLB  0
0E3E:  BRA    0B9A
0E40:  MOVF   01,F
0E42:  BTFSS  FD8.2
0E44:  BRA    0E4A
0E46:  MOVLB  4
0E48:  BRA    0E86
.................... 				fprintf(STREAM_WORLD,"# RockBLOCK says: '%c'\r\n",uart_getc());	
*
0E54:  MOVFF  01,48D
0E58:  MOVLW  00
0E5A:  MOVWF  FF6
0E5C:  MOVLW  02
0E5E:  MOVWF  FF7
0E60:  MOVLW  13
0E62:  MOVLB  4
0E64:  MOVWF  x8E
0E66:  MOVLB  0
0E68:  RCALL  08F4
0E6A:  MOVLB  4
0E6C:  MOVF   x8D,W
0E6E:  BTFSS  FA4.4
0E70:  BRA    0E6E
0E72:  MOVWF  F79
0E74:  MOVLW  15
0E76:  MOVWF  FF6
0E78:  MOVLW  02
0E7A:  MOVWF  FF7
0E7C:  MOVLW  03
0E7E:  MOVWF  x8E
0E80:  MOVLB  0
0E82:  RCALL  08F4
0E84:  MOVLB  4
.................... 			}
.................... 			
.................... 
.................... #if 1
.................... 		if ( current.restart_now ) {
0E86:  MOVF   4E,F
0E88:  BTFSC  FD8.2
0E8A:  BRA    0F70
.................... 			timers.led_on_green=200;
0E8C:  MOVLW  C8
0E8E:  MOVWF  50
.................... 
.................... 			output_high(CTRL_0);
0E90:  BCF    F92.0
0E92:  BSF    F89.0
.................... 
.................... 			fprintf(STREAM_WORLD,"# you said '%c'\r\n",current.restart_now);
0E94:  MOVLW  1A
0E96:  MOVWF  FF6
0E98:  MOVLW  02
0E9A:  MOVWF  FF7
0E9C:  MOVLW  0C
0E9E:  MOVWF  x8E
0EA0:  MOVLB  0
0EA2:  RCALL  08F4
0EA4:  MOVF   4E,W
0EA6:  BTFSS  FA4.4
0EA8:  BRA    0EA6
0EAA:  MOVWF  F79
0EAC:  MOVLW  28
0EAE:  MOVWF  FF6
0EB0:  MOVLW  02
0EB2:  MOVWF  FF7
0EB4:  MOVLW  03
0EB6:  MOVLB  4
0EB8:  MOVWF  x8E
0EBA:  MOVLB  0
0EBC:  RCALL  08F4
.................... 			if ( config.uart_sc_sbd ) {
0EBE:  MOVF   26,F
0EC0:  BZ    0EC8
.................... 				uart_putc(current.restart_now);
0EC2:  MOVFF  4E,48D
0EC6:  BRA    0BAE
.................... 			}
.................... 
.................... 			current.restart_now=0;
0EC8:  CLRF   4E
.................... 
.................... 
.................... #if 0
.................... 			/* read a block of bytes from device */
.................... 			i2c_start();
.................... 			delay_us(15);
.................... 			i2c_write(0x36);
.................... 			i2c_write(0); /* register address 0 */
.................... 			i2c_start();
.................... 			delay_us(15);
.................... 			i2c_write(0x36 | 1); /* read */
.................... 			
.................... 			for ( i=0 ; i<16 ; i++ ) {
.................... 				j=i2c_read(1);
.................... 
.................... 				fprintf(STREAM_WORLD,"# byte addr[0x%02x]=0x%02x (%u)\r\n",
.................... 					i,
.................... 					j,
.................... 					j
.................... 				);
.................... 			}
.................... 			i2c_read(0);
.................... #endif
.................... 
.................... #if 1
.................... 			/* 16 bit registers, but byte addressed */
.................... 			for ( i=0 ; i<18 ; i ++ ) {
0ECA:  MOVLB  4
0ECC:  CLRF   x89
0ECE:  MOVF   x89,W
0ED0:  SUBLW  11
0ED2:  BNC   0F6C
.................... 				l=i2c_register_read16(0x36,i);
0ED4:  MOVLW  36
0ED6:  MOVWF  x8D
0ED8:  MOVFF  489,48E
0EDC:  MOVLB  0
0EDE:  BRA    0BC0
0EE0:  MOVFF  02,48C
0EE4:  MOVFF  01,48B
.................... 				fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%04lx (%lu)\r\n",i,l,l);
0EE8:  MOVLW  2C
0EEA:  MOVWF  FF6
0EEC:  MOVLW  02
0EEE:  MOVWF  FF7
0EF0:  MOVLW  0D
0EF2:  MOVLB  4
0EF4:  MOVWF  x8E
0EF6:  MOVLB  0
0EF8:  RCALL  08F4
0EFA:  MOVFF  489,48D
0EFE:  MOVLW  57
0F00:  MOVLB  4
0F02:  MOVWF  x8E
0F04:  MOVLB  0
0F06:  RCALL  0ACC
0F08:  MOVLW  3D
0F0A:  MOVWF  FF6
0F0C:  MOVLW  02
0F0E:  MOVWF  FF7
0F10:  MOVLW  04
0F12:  MOVLB  4
0F14:  MOVWF  x8E
0F16:  MOVLB  0
0F18:  RCALL  08F4
0F1A:  MOVFF  48C,48D
0F1E:  MOVLW  57
0F20:  MOVLB  4
0F22:  MOVWF  x8E
0F24:  MOVLB  0
0F26:  RCALL  0ACC
0F28:  MOVFF  48B,48D
0F2C:  MOVLW  57
0F2E:  MOVLB  4
0F30:  MOVWF  x8E
0F32:  MOVLB  0
0F34:  RCALL  0ACC
0F36:  MOVLW  20
0F38:  BTFSS  FA4.4
0F3A:  BRA    0F38
0F3C:  MOVWF  F79
0F3E:  MOVLW  28
0F40:  BTFSS  FA4.4
0F42:  BRA    0F40
0F44:  MOVWF  F79
0F46:  MOVLW  10
0F48:  MOVWF  FE9
0F4A:  MOVFF  48C,48E
0F4E:  MOVFF  48B,48D
0F52:  RCALL  091E
0F54:  MOVLW  4B
0F56:  MOVWF  FF6
0F58:  MOVLW  02
0F5A:  MOVWF  FF7
0F5C:  MOVLW  03
0F5E:  MOVLB  4
0F60:  MOVWF  x8E
0F62:  MOVLB  0
0F64:  RCALL  08F4
.................... 			}
.................... #endif
.................... 
.................... #if 0
0F66:  MOVLB  4
0F68:  INCF   x89,F
0F6A:  BRA    0ECE
.................... 			fprintf(STREAM_WORLD,"# writing 0x%04lx to register 1\r\n",n);
.................... 			i2c_register_write16(0x36,1,n);
.................... 			n+=200;
.................... #endif
.................... 			output_low(CTRL_0);
0F6C:  BCF    F92.0
0F6E:  BCF    F89.0
.................... 
.................... 		}
.................... #endif
0F70:  BRA    0E36
.................... 
.................... 
.................... 
.................... 		
.................... 	}
.................... }
0F72:  SLEEP 

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 3F66   PUT BROWNOUT BORV30 ZPBORM WDT WDT32768
   Word  3: 0900   CANB MSSPMSK7
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E000   NOWRTC NOWRTB NOWRTD
   Word  7: 4000   NOEBTRB
